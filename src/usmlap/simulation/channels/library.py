"""
This module contains definitions of data channels.
"""

import simulation.channels.functions as fcn
from utils.units import Unit

from .channel import Channel, ChannelFcn


class CentripetalForce(Channel, name="Centripetal Force", unit=Unit.NEWTON):
    """Centripetal force acting on the vehicle."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.vehicle_state.centripetal_force for node in solution.nodes
        ]


class Downforce(Channel, name="Downforce", unit=Unit.NEWTON):
    """Aerodynamic downforce."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.vehicle_state.downforce for node in solution.nodes
        ]


class Drag(Channel, name="Drag", unit=Unit.NEWTON):
    """Aerodynamic drag force."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.vehicle_state.drag for node in solution.nodes
        ]


class DragPower(Channel, name="Drag Power", unit=Unit.KILOWATT):
    """Aerodynamic drag power."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return fcn.product(Drag, Velocity)


class DragEnergy(Channel, name="Drag Energy", unit=Unit.JOULE):
    """Aerodynamic drag energy."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return fcn.integral(Drag, Distance)


class ResistiveFx(Channel, name="Resistive Force", unit=Unit.NEWTON):
    """Total resistive force acting on the vehicle."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.vehicle_state.resistive_fx for node in solution.nodes
        ]


class RequiredFy(Channel, name="Required Fy", unit=Unit.NEWTON):
    """Lateral force required to navigate the track."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.vehicle_state.required_fy for node in solution.nodes
        ]


class NormalForce(Channel, name="Normal Force", unit=Unit.NEWTON):
    """Total normal force exerted by the vehicle."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.vehicle_state.normal_force for node in solution.nodes
        ]


class TotalLateralTraction(
    Channel, name="Total Lateral Traction", unit=Unit.NEWTON
):
    """Total lateral traction force generated by the tyres."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.vehicle_state.total_lateral_traction for node in solution.nodes
        ]


class MotorSpeed(Channel, name="Motor Speed", unit=Unit.RADIANS_PER_SECOND):
    """Rotational velocity of the motor."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.vehicle_state.motor_speed for node in solution.nodes
        ]


class MotorTorque(Channel, name="Motor Torque", unit=Unit.NEWTON_METER):
    """Torque generated by the motor."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.vehicle_state.motor_torque for node in solution.nodes
        ]


class MotorPower(Channel, name="Motor Power", unit=Unit.KILOWATT):
    """Power output by the motor."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return fcn.product(MotorTorque, MotorSpeed)


class MotorEnergy(Channel, name="Motor Energy", unit=Unit.KILOWATT_HOUR):
    """Energy output by the motor."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return fcn.integral(MotorPower, Time)


class MotorForce(Channel, name="Motor Force", unit=Unit.NEWTON):
    """Equivalent motor force measured at the wheels."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.vehicle_state.motor_force for node in solution.nodes
        ]


class Curvature(Channel, name="Curvature", unit=Unit.PER_METER):
    """Curvature of the track."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.track_node.curvature for node in solution.nodes
        ]


class CornerRadius(Channel, name="Corner Radius", unit=Unit.METER):
    """Radius of the track."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.track_node.radius for node in solution.nodes
        ]


class Distance(Channel, name="Distance", unit=Unit.METER):
    """Length of the track segment."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.track_node.length for node in solution.nodes
        ]


class Position(Channel, name="Position", unit=Unit.METER):
    """Position of the vehicle."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.track_node.position for node in solution.nodes
        ]


class Velocity(Channel, name="Velocity", unit=Unit.KILOMETER_PER_HOUR):
    """Velocity of the vehicle."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.average_velocity for node in solution.nodes
        ]


class MaximumVelocity(
    Channel, name="Maximum Velocity", unit=Unit.KILOMETER_PER_HOUR
):
    """Maximum, velocity of the vehicle, limited by lateral grip."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.maximum_velocity for node in solution.nodes
        ]


class Time(Channel, name="Time", unit=Unit.SECOND):
    """The time taken to traverse the track segment."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [node.time for node in solution.nodes]


class LateralAcceleration(Channel, name="Lateral Acceleration", unit=Unit.G):
    """Lateral acceleration of the vehicle."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.lateral_acceleration for node in solution.nodes
        ]


class LongitudinalAcceleration(
    Channel, name="Longitudinal Acceleration", unit=Unit.G
):
    """Longitudinal acceleration of the vehicle."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.longitudinal_acceleration for node in solution.nodes
        ]


class ResultantAcceleration(
    Channel, name="Resultant Acceleration", unit=Unit.G
):
    """Resultant acceleration of the vehicle."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return fcn.hypotenuse(LongitudinalAcceleration, LateralAcceleration)


class StateOfCharge(Channel, name="State of Charge", unit=Unit.UNITLESS):
    """State of charge of the battery."""

    @classmethod
    def _channel_fcn(cls) -> ChannelFcn:
        return lambda solution: [
            node.state_variables.state_of_charge for node in solution.nodes
        ]
