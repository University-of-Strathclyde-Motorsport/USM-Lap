{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"USM Lap","text":"<p>Laptime simulator built by the University of Strathclyde Motorsport team.</p>"},{"location":"autoapi/summary/","title":"Summary","text":"<ul> <li>usmlap<ul> <li>__main__</li> <li>datatypes</li> <li>track<ul> <li>mesh</li> <li>track_data</li> </ul> </li> <li>utils<ul> <li>array</li> <li>geometry</li> <li>proportion</li> </ul> </li> <li>vehicle<ul> <li>brakes</li> <li>common</li> <li>steering</li> <li>suspension</li> <li>transmission</li> <li>tyre<ul> <li>magic_formula</li> <li>tir</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/usmlap/","title":"usmlap","text":""},{"location":"autoapi/usmlap/__main__/","title":"__main__","text":""},{"location":"autoapi/usmlap/datatypes/","title":"datatypes","text":"<p>This module defines custom datatypes used throughout the project.</p>"},{"location":"autoapi/usmlap/datatypes/#usmlap.datatypes.Coordinate","title":"<code>Coordinate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a coordinate with x, y, and z components.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>x component.</p> <code>y</code> <code>float</code> <p>y component.</p> <code>z</code> <code>float</code> <p>z component (default: 0).</p> Source code in <code>src\\usmlap\\datatypes.py</code> <pre><code>class Coordinate(BaseModel):\n    \"\"\"\n    Represents a coordinate with x, y, and z components.\n\n    Attributes:\n        x (float): x component.\n        y (float): y component.\n        z (float): z component (default: 0).\n    \"\"\"\n\n    x: float\n    y: float\n    z: float = 0\n\n    def norm(self) -&gt; float:\n        return math.sqrt(self.x**2 + self.y**2 + self.z**2)\n</code></pre>"},{"location":"autoapi/usmlap/datatypes/#usmlap.datatypes.FrontRear","title":"<code>FrontRear</code>","text":"<p>               Bases: <code>tuple[T, T]</code></p> <p>Represents a property with a front and rear value.</p> <p>Used for properties which differ on each axle of the vehicle.</p> <p>Attributes:</p> Name Type Description <code>front</code> <code>T</code> <p>Value for the front axle.</p> <code>rear</code> <code>T</code> <p>Value for the rear axle.</p> Source code in <code>src\\usmlap\\datatypes.py</code> <pre><code>class FrontRear(tuple[T, T]):\n    \"\"\"\n    Represents a property with a front and rear value.\n\n    Used for properties which differ on each axle of the vehicle.\n\n    Attributes:\n        front (T): Value for the front axle.\n        rear (T): Value for the rear axle.\n    \"\"\"\n\n    @property\n    def front(self) -&gt; T:\n        return self[0]\n\n    @property\n    def rear(self) -&gt; T:\n        return self[1]\n\n    def __str__(self) -&gt; str:\n        return f\"front: {self.front}, rear: {self.rear}\"\n</code></pre>"},{"location":"autoapi/usmlap/track/","title":"track","text":""},{"location":"autoapi/usmlap/track/mesh/","title":"mesh","text":"<p>This module contains code for generating a track mesh.</p>"},{"location":"autoapi/usmlap/track/mesh/#usmlap.track.mesh.Mesh","title":"<code>Mesh</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A mesh of a track.</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>list[Node]</code> <p>A list of nodes making up the track.</p> <code>configuration</code> <code>Configuration</code> <p>The configuration of the track (OPEN or CLOSED).</p> Source code in <code>src\\usmlap\\track\\mesh.py</code> <pre><code>class Mesh(BaseModel):\n    \"\"\"\n    A mesh of a track.\n\n    Attributes:\n        nodes (list[Node]): A list of nodes making up the track.\n        configuration (Configuration): The configuration of the track\n            (OPEN or CLOSED).\n    \"\"\"\n\n    nodes: list[Node]\n    configuration: Configuration\n\n    @property\n    def node_count(self) -&gt; float:\n        return len(self.nodes)\n\n    @property\n    def track_length(self) -&gt; float:\n        return sum(node.length for node in self.nodes)\n\n    @property\n    def resolution(self) -&gt; float:\n        return self.track_length / self.node_count\n</code></pre>"},{"location":"autoapi/usmlap/track/mesh/#usmlap.track.mesh.MeshGenerator","title":"<code>MeshGenerator</code>","text":"<p>               Bases: <code>object</code></p> <p>Generates a mesh from a track data object.</p> Source code in <code>src\\usmlap\\track\\mesh.py</code> <pre><code>class MeshGenerator(object):\n    \"\"\"\n    Generates a mesh from a track data object.\n    \"\"\"\n\n    def generate_mesh(self, track_data: TrackData) -&gt; Mesh:\n        \"\"\"\n        Generate a mesh from a track data object.\n\n        Args:\n            track_data (TrackData): The track data object.\n\n        Returns:\n            mesh (Mesh): A mesh of the track.\n        \"\"\"\n        self.track_data = track_data\n        self.track_length = track_data.total_length\n\n        length = [shape.length for shape in track_data.shape]\n        position = list(accumulate(length))\n        position.insert(0, 0)\n        position.pop()\n        # fractional_position = [p / self.track_length for p in position]\n\n        curvature = self._interpolate_curvature(position)\n        # TODO: Implement code for closing the track\n\n        elevation = track_data.elevation.interpolate(position)\n        banking = track_data.banking.interpolate(position)\n        grip_factor = track_data.grip_factor.interpolate(position)\n        sector = track_data.sector.interpolate(position)\n\n        inclination = self._calculate_inclination(position, elevation)\n\n        nodes = [\n            Node(\n                position=position[i],\n                length=length[i],\n                curvature=curvature[i],\n                elevation=elevation[i],\n                inclination=inclination[i],\n                banking=banking[i],\n                grip_factor=grip_factor[i],\n                sector=sector[i],\n            )\n            for i in range(len(position))\n        ]\n\n        return Mesh(nodes=nodes, configuration=track_data.configuration)\n\n    def _interpolate_curvature(self, position: list[float]) -&gt; list[float]:\n        curvature_position = cumsum([s.length for s in self.track_data.shape])\n        curvature_value = [s.curvature for s in self.track_data.shape]\n        if self.track_data.configuration == Configuration.CLOSED:\n            curvature_position.append(curvature_position[0] + self.track_length)\n            curvature_value.append(curvature_value[0])\n        return np.interp(position, curvature_position, curvature_value).tolist()\n\n    @staticmethod\n    def _calculate_inclination(\n        position: list[float], elevation: list[float]\n    ) -&gt; list[float]:\n        diff_position = diff(position)\n        diff_elevation = diff(elevation)\n        inclination_position = [\n            position[i] + diff_position[i] / 2\n            for i in range(len(diff_position))\n        ]\n        inclination_value = [\n            atan(diff_elevation[i] / diff_position[i])\n            for i in range(len(diff_position))\n        ]\n        return np.interp(\n            position, inclination_position, inclination_value\n        ).tolist()\n</code></pre>"},{"location":"autoapi/usmlap/track/mesh/#usmlap.track.mesh.MeshGenerator.generate_mesh","title":"<code>generate_mesh(track_data)</code>","text":"<p>Generate a mesh from a track data object.</p> <p>Parameters:</p> Name Type Description Default <code>track_data</code> <code>TrackData</code> <p>The track data object.</p> required <p>Returns:</p> Name Type Description <code>mesh</code> <code>Mesh</code> <p>A mesh of the track.</p> Source code in <code>src\\usmlap\\track\\mesh.py</code> <pre><code>def generate_mesh(self, track_data: TrackData) -&gt; Mesh:\n    \"\"\"\n    Generate a mesh from a track data object.\n\n    Args:\n        track_data (TrackData): The track data object.\n\n    Returns:\n        mesh (Mesh): A mesh of the track.\n    \"\"\"\n    self.track_data = track_data\n    self.track_length = track_data.total_length\n\n    length = [shape.length for shape in track_data.shape]\n    position = list(accumulate(length))\n    position.insert(0, 0)\n    position.pop()\n    # fractional_position = [p / self.track_length for p in position]\n\n    curvature = self._interpolate_curvature(position)\n    # TODO: Implement code for closing the track\n\n    elevation = track_data.elevation.interpolate(position)\n    banking = track_data.banking.interpolate(position)\n    grip_factor = track_data.grip_factor.interpolate(position)\n    sector = track_data.sector.interpolate(position)\n\n    inclination = self._calculate_inclination(position, elevation)\n\n    nodes = [\n        Node(\n            position=position[i],\n            length=length[i],\n            curvature=curvature[i],\n            elevation=elevation[i],\n            inclination=inclination[i],\n            banking=banking[i],\n            grip_factor=grip_factor[i],\n            sector=sector[i],\n        )\n        for i in range(len(position))\n    ]\n\n    return Mesh(nodes=nodes, configuration=track_data.configuration)\n</code></pre>"},{"location":"autoapi/usmlap/track/mesh/#usmlap.track.mesh.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A node of a track.</p> <p>Attributes:</p> Name Type Description <code>Position</code> <code>float</code> <p>The position of the node from the start of the track.</p> <code>Length</code> <code>float</code> <p>The length of the track section.</p> <code>Curvature</code> <code>float</code> <p>The curvature of the track section.</p> <code>Elevation</code> <code>float</code> <p>The elevation of the track section.</p> <code>Inclination</code> <code>float</code> <p>The inclination angle of the track section.</p> <code>Banking</code> <code>float</code> <p>The banking angle of the track section.</p> <code>GripFactor</code> <code>float</code> <p>The grip factor of the track section.</p> <code>Sector</code> <code>int</code> <p>The sector of the track section.</p> Source code in <code>src\\usmlap\\track\\mesh.py</code> <pre><code>class Node(BaseModel):\n    \"\"\"\n    A node of a track.\n\n    Attributes:\n        Position (float): The position of the node from the start of the track.\n        Length (float): The length of the track section.\n        Curvature (float): The curvature of the track section.\n        Elevation (float): The elevation of the track section.\n        Inclination (float): The inclination angle of the track section.\n        Banking (float): The banking angle of the track section.\n        GripFactor (float): The grip factor of the track section.\n        Sector (int): The sector of the track section.\n    \"\"\"\n\n    position: float = Field(ge=0)\n    length: float = Field(gt=0)\n    curvature: float\n    elevation: float\n    inclination: float = Field(gt=-pi / 2, lt=pi / 2, default=0)\n    banking: float = Field(ge=-pi / 2, le=pi / 2, default=0)\n    grip_factor: float = Field(gt=0, default=1)\n    sector: int = Field(gt=0, default=1)\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/","title":"track_data","text":"<p>This module contains code for reading track data from an Excel file.</p>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.BankingData","title":"<code>BankingData</code>","text":"<p>               Bases: <code>LocationData</code></p> <p>Data describing the banking angle of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass BankingData(LocationData):\n    \"\"\"\n    Data describing the banking angle of the track.\n    \"\"\"\n\n    value: list[\n        Annotated[float, Field(ge=-math.pi / 2, le=math.pi / 2), Unit(\"rad\")]\n    ]\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Configuration","title":"<code>Configuration</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the configuration of the track.</p> <p>A closed track returns back to its starting position. An open track can start and end in different locations.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class Configuration(Enum):\n    \"\"\"\n    Enum representing the configuration of the track.\n\n    A closed track returns back to its starting position.\n    An open track can start and end in different locations.\n    \"\"\"\n\n    CLOSED = \"Closed\"\n    OPEN = \"Open\"\n\n    def __str__(self) -&gt; str:\n        return self.name.lower().capitalize()\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Direction","title":"<code>Direction</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the direction of driving.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class Direction(Enum):\n    \"\"\"\n    Enum representing the direction of driving.\n    \"\"\"\n\n    FORWARD = 1\n    BACKWARD = -1\n\n    def __str__(self) -&gt; str:\n        return self.name.lower().capitalize()\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.ElevationData","title":"<code>ElevationData</code>","text":"<p>               Bases: <code>LocationData</code></p> <p>Data describing the elevation of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass ElevationData(LocationData):\n    \"\"\"\n    Data describing the elevation of the track.\n    \"\"\"\n\n    value: list[Annotated[float, Unit(\"m\")]]\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the type of event the track is suitable for.</p> <p>If a track is used to simulate an unsuitable event, a warning will be issued.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class Event(Enum):\n    \"\"\"\n    Enum representing the type of event the track is suitable for.\n\n    If a track is used to simulate an unsuitable event,\n    a warning will be issued.\n    \"\"\"\n\n    ACCELERATION = \"Acceleration\"\n    SKIDPAD = \"Skidpad\"\n    AUTOX = \"AutoX\"\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.GripFactorData","title":"<code>GripFactorData</code>","text":"<p>               Bases: <code>StartpointData[float]</code></p> <p>Data describing the grip factor of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass GripFactorData(StartpointData[float]):\n    \"\"\"\n    Data describing the grip factor of the track.\n    \"\"\"\n\n    value: list[Annotated[float, Field(gt=0)]]\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.LocationData","title":"<code>LocationData</code>","text":"<p>               Bases: <code>PositionData[float]</code></p> <p>Base class for data recorded at a number of locations.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class LocationData(PositionData[float]):\n    \"\"\"\n    Base class for data recorded at a number of locations.\n    \"\"\"\n\n    def interpolate(self, position: list[float]) -&gt; list[float]:\n        return np.interp(position, self.position, self.value).tolist()\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Metadata","title":"<code>Metadata</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata for a track.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the track.</p> <code>country</code> <code>str</code> <p>The country the track is located in.</p> <code>city</code> <code>str</code> <p>The city the track is located near.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class Metadata(BaseModel):\n    \"\"\"\n    Metadata for a track.\n\n    Attributes:\n        name (str): The name of the track.\n        country (str): The country the track is located in.\n        city (str): The city the track is located near.\n    \"\"\"\n\n    name: str | None\n    country: str | None\n    city: str | None\n\n    @property\n    def display_name(self) -&gt; str:\n        \"\"\"\n        The display name for the track.\n\n        If the track has a name, this is returned.\n        Otherwise, \"Unnamed Track\" is returned.\n        \"\"\"\n        return self.name if self.name else \"Unnamed Track\"\n\n    @property\n    def location(self) -&gt; str:\n        \"\"\"\n        The location of the track.\n\n        Uses the city and/or country attributes, if present.\n        Otherwise, an empty string is returned.\n        \"\"\"\n        if self.city and self.country:\n            location = f\"{self.city}, {self.country}\"\n        elif self.city:\n            location = self.city\n        elif self.country:\n            location = self.country\n        else:\n            location = \"\"\n        return location\n\n    def __str__(self) -&gt; str:\n        return f\"{self.display_name}, {self.location}\".strip(\", \")\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Metadata.display_name","title":"<code>display_name</code>  <code>property</code>","text":"<p>The display name for the track.</p> <p>If the track has a name, this is returned. Otherwise, \"Unnamed Track\" is returned.</p>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Metadata.location","title":"<code>location</code>  <code>property</code>","text":"<p>The location of the track.</p> <p>Uses the city and/or country attributes, if present. Otherwise, an empty string is returned.</p>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.PositionData","title":"<code>PositionData</code>","text":"<p>               Bases: <code>Sequence[T]</code>, <code>ABC</code></p> <p>Abstract base class for data recorded against a series of positions.</p> <p>Subclasses must implement the <code>interpolate</code> method.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>list[float]</code> <p>The positions of the data.</p> <code>value</code> <code>list[T]</code> <p>The values of the data at each position.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass PositionData[T](Sequence[T], ABC):\n    \"\"\"\n    Abstract base class for data recorded against a series of positions.\n\n    Subclasses must implement the `interpolate` method.\n\n    Attributes:\n        position (list[float]): The positions of the data.\n        value (list[T]): The values of the data at each position.\n    \"\"\"\n\n    position: list[Annotated[float, Field(ge=0), Unit(\"m\")]]\n    value: list[T]\n\n    def __post_init__(self) -&gt; None:\n        if len(self.position) != len(self.value):\n            raise ValueError(\"position and value must have the same length\")\n\n    def __len__(self) -&gt; int:\n        return len(self.value)\n\n    @overload\n    def __getitem__(self, key: int) -&gt; T: ...\n\n    @overload\n    def __getitem__(self, key: slice) -&gt; Sequence[T]: ...\n\n    def __getitem__(self, key: int | slice) -&gt; Sequence[T] | T:\n        if isinstance(key, int):\n            return self.value[key]\n        else:\n            return self.__class__(self.position[key], self.value[key])\n\n    @abstractmethod\n    def interpolate(self, position: list[float]) -&gt; list[T]: ...\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.SectionType","title":"<code>SectionType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the type of section of track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class SectionType(Enum):\n    \"\"\"\n    Enum representing the type of section of track.\n    \"\"\"\n\n    STRAIGHT = 0\n    LEFT = 1\n    RIGHT = -1\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.SectorData","title":"<code>SectorData</code>","text":"<p>               Bases: <code>StartpointData[int]</code></p> <p>Data specifying sectors of the track.</p> <p>Sector data has no impact on the simulation, and is used purely for visualisation.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass SectorData(StartpointData[int]):\n    \"\"\"\n    Data specifying sectors of the track.\n\n    Sector data has no impact on the simulation,\n    and is used purely for visualisation.\n    \"\"\"\n\n    value: list[Annotated[int, Field(gt=0)]]\n\n    def list_sectors(self) -&gt; str:\n        return \", \".join(str(value) for value in self.value)\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.ShapeData","title":"<code>ShapeData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Data describing the shape of a section of track.</p> <p>Attributes:</p> Name Type Description <code>section_type</code> <code>SectionType</code> <p>The type of track section (STRAIGHT, LEFT, or RIGHT).</p> <code>length</code> <code>float</code> <p>The length of the track section.</p> <code>corner_radius</code> <code>float</code> <p>The radius of the section of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class ShapeData(BaseModel):\n    \"\"\"\n    Data describing the shape of a section of track.\n\n    Attributes:\n        section_type (SectionType):\n            The type of track section (STRAIGHT, LEFT, or RIGHT).\n        length (float): The length of the track section.\n        corner_radius (float): The radius of the section of the track.\n    \"\"\"\n\n    model_config = ConfigDict(use_enum_values=True)\n\n    section_type: SectionType\n    length: Annotated[float, Field(gt=0), Unit(\"m\")]\n    corner_radius: Annotated[float, Unit(\"m\")]\n\n    def __init__(\n        self, section_type: SectionType, length: float, corner_radius: float\n    ) -&gt; None:\n        if section_type == SectionType.STRAIGHT:\n            corner_radius = math.inf\n        else:\n            corner_radius = corner_radius * section_type.value\n        super().__init__(\n            section_type=section_type,\n            length=length,\n            corner_radius=corner_radius,\n        )\n\n    @property\n    def curvature(self) -&gt; float:\n        return 1 / self.corner_radius\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.StartpointData","title":"<code>StartpointData</code>","text":"<p>               Bases: <code>PositionData[T]</code></p> <p>Base class for data recorded with a series of startpoints.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class StartpointData[T](PositionData[T]):\n    \"\"\"\n    Base class for data recorded with a series of startpoints.\n    \"\"\"\n\n    def interpolate(self, position: list[float]) -&gt; list[T]:\n        return interp_previous(position, self.position, self.value)\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackData","title":"<code>TrackData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains information about a racetrack.</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>Metadata</code> <p>Metadata for the track, such as name and location.</p> <code>shape</code> <code>list[ShapeData]</code> <p>Data describing the shape of the track.</p> <code>elevation</code> <code>ElevationData</code> <p>Data describing the track elevation.</p> <code>banking</code> <code>BankingData</code> <p>Data describing the track banking.</p> <code>grip_factor</code> <code>list[GripFactorData]</code> <p>Grip factor data for the track.</p> <code>sector</code> <code>list[SectorData]</code> <p>Data specifying sectors of the track.</p> <code>event</code> <code>Event</code> <p>The type of event the track is suitable for.</p> <code>configuration</code> <code>Configuration</code> <p>The configuration of the track.</p> <code>direction</code> <code>Direction</code> <p>The direction of driving (default = FORWARD).</p> <code>mirror</code> <code>bool</code> <p>Whether the track should be mirrored (default = False).</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class TrackData(BaseModel):\n    \"\"\"\n    Contains information about a racetrack.\n\n    Attributes:\n        metadata (Metadata): Metadata for the track, such as name and location.\n        shape (list[ShapeData]): Data describing the shape of the track.\n        elevation (ElevationData): Data describing the track elevation.\n        banking (BankingData): Data describing the track banking.\n        grip_factor (list[GripFactorData]): Grip factor data for the track.\n        sector (list[SectorData]): Data specifying sectors of the track.\n        event (Event): The type of event the track is suitable for.\n        configuration (Configuration): The configuration of the track.\n        direction (Direction): The direction of driving (default = FORWARD).\n        mirror (bool): Whether the track should be mirrored (default = False).\n    \"\"\"\n\n    model_config = ConfigDict()\n\n    metadata: Metadata\n    shape: list[ShapeData]\n    elevation: ElevationData\n    banking: BankingData\n    grip_factor: GripFactorData\n    sector: SectorData\n    event: Event\n    configuration: Configuration\n    direction: Direction = Direction.FORWARD\n    mirror: bool = False\n\n    @property\n    def total_length(self) -&gt; float:\n        return sum(segment.length for segment in self.shape)\n\n    def __str__(self) -&gt; str:\n        return (\n            f\"{self.metadata}\\n\\n\"\n            f\"Length: {self.total_length} m\\n\"\n            f\"Configuration: {str(self.configuration)}\\n\"\n            f\"Direction: {str(self.direction)}\\n\"\n            f\"Mirrored: {self.mirror}\\n\\n\"\n            f\"Shape data: {len(self.shape)} segments\\n\"\n            f\"Elevation data: {len(self.elevation)} points \"\n            f\"(high: {max(self.elevation)} m, low: {min(self.elevation)} m)\\n\"\n            f\"Banking data: {len(self.banking)} points \"\n            f\"(max: {math.degrees(max(self.banking, key=abs))}\u00b0)\\n\"\n            f\"Grip factor data: {len(self.grip_factor)} points \"\n            f\"(max: {max(self.grip_factor)}, min: {min(self.grip_factor)})\\n\"\n            f\"Sector data: {len(self.sector)} sectors \"\n            f\"({self.sector.list_sectors()})\\n\"\n        )\n\n    @classmethod\n    def load_track_from_spreadsheet(cls, filepath: str) -&gt; Self:\n        reader = TrackReader(filepath)\n        return cls(\n            metadata=reader.get_metadata(),\n            shape=reader.get_shape_data(),\n            elevation=reader.get_elevation_data(),\n            banking=reader.get_banking_data(),\n            grip_factor=reader.get_grip_factor_data(),\n            sector=reader.get_sector_data(),\n            event=Event.AUTOX,\n            configuration=reader.get_configuration(),\n            direction=reader.get_direction(),\n            mirror=reader.get_mirror(),\n        )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader","title":"<code>TrackReader</code>","text":"<p>               Bases: <code>object</code></p> <p>Reads track data from an OpenLAP Excel spreadsheet.</p> <p>Attributes:</p> Name Type Description <code>workbook</code> <code>ExcelFile</code> <p>The Excel file containing the track data.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class TrackReader(object):\n    \"\"\"\n    Reads track data from an OpenLAP Excel spreadsheet.\n\n    Attributes:\n        workbook (pandas.ExcelFile): The Excel file containing the track data.\n    \"\"\"\n\n    def __init__(self, filepath: str) -&gt; None:\n        \"\"\"\n        Initialises the TrackReader from a filepath.\n\n        Args:\n            filepath (str): Path to the Excel file to be read.\n        \"\"\"\n        self.workbook = pandas.ExcelFile(filepath, engine=\"openpyxl\")\n\n    def _get_info(self) -&gt; pandas.DataFrame:\n        return pandas.read_excel(\n            self.workbook,\n            header=None,\n            sheet_name=\"Info\",\n            usecols=\"A:B\",\n            index_col=0,\n            dtype=str,\n        )\n\n    def get_metadata(self) -&gt; Metadata:\n        \"\"\"Returns the metadata for the track.\"\"\"\n        info = self._get_info()\n        return Metadata(\n            name=str(info.at[\"Name\", 1]),\n            country=str(info.at[\"Country\", 1]),\n            city=str(info.at[\"City\", 1]),\n        )\n\n    def get_shape_data(self) -&gt; list[ShapeData]:\n        \"\"\"Returns the shape data for the track.\"\"\"\n        dataframe = pandas.read_excel(self.workbook, sheet_name=\"Shape\")\n        return [\n            ShapeData(\n                section_type=SectionType[row[\"Type\"].upper()],\n                length=row[\"Section Length\"],\n                corner_radius=row[\"Corner Radius\"],\n            )\n            for _, row in dataframe.iterrows()\n        ]\n\n    def get_elevation_data(self) -&gt; ElevationData:\n        \"\"\"Returns the elevation data for the track.\"\"\"\n        dataframe = pandas.read_excel(self.workbook, sheet_name=\"Elevation\")\n        return ElevationData(\n            position=dataframe[\"Point [m]\"].tolist(),\n            value=dataframe[\"Elevation [m]\"].tolist(),\n        )\n\n    def get_banking_data(self) -&gt; BankingData:\n        \"\"\"Returns the banking data for the track.\"\"\"\n        dataframe = pandas.read_excel(self.workbook, sheet_name=\"Banking\")\n        return BankingData(\n            position=dataframe[\"Point [m]\"].tolist(),\n            value=dataframe[\"Banking [deg]\"].apply(math.radians).tolist(),\n        )\n\n    def get_grip_factor_data(self) -&gt; GripFactorData:\n        \"\"\"Returns the grip factor data for the track.\"\"\"\n        dataframe = pandas.read_excel(self.workbook, sheet_name=\"Grip Factors\")\n        return GripFactorData(\n            position=dataframe[\"Start Point [m]\"].tolist(),\n            value=dataframe[\"Grip Factor [-]\"].tolist(),\n        )\n\n    def get_sector_data(self) -&gt; SectorData:\n        \"\"\"Returns the sector data for the track.\"\"\"\n        dataframe = pandas.read_excel(self.workbook, sheet_name=\"Sectors\")\n        return SectorData(\n            position=dataframe[\"Start Point [m]\"].tolist(),\n            value=dataframe[\"Sector\"].tolist(),\n        )\n\n    def get_configuration(self) -&gt; Configuration:\n        \"\"\"Returns the configuration of the track.\"\"\"\n        return Configuration[\n            str(self._get_info().at[\"Configuration\", 1]).upper()\n        ]\n\n    def get_direction(self) -&gt; Direction:\n        \"\"\"Returns the direction of driving.\"\"\"\n        return Direction[str(self._get_info().at[\"Direction\", 1]).upper()]\n\n    def get_mirror(self) -&gt; bool:\n        \"\"\"Returns whether the track should be mirrored.\"\"\"\n        mirror_str = str(self._get_info().at[\"Mirror\", 1])\n        return True if mirror_str.lower() in [\"on\", \"yes\", \"true\"] else False\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.__init__","title":"<code>__init__(filepath)</code>","text":"<p>Initialises the TrackReader from a filepath.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the Excel file to be read.</p> required Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def __init__(self, filepath: str) -&gt; None:\n    \"\"\"\n    Initialises the TrackReader from a filepath.\n\n    Args:\n        filepath (str): Path to the Excel file to be read.\n    \"\"\"\n    self.workbook = pandas.ExcelFile(filepath, engine=\"openpyxl\")\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_banking_data","title":"<code>get_banking_data()</code>","text":"<p>Returns the banking data for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_banking_data(self) -&gt; BankingData:\n    \"\"\"Returns the banking data for the track.\"\"\"\n    dataframe = pandas.read_excel(self.workbook, sheet_name=\"Banking\")\n    return BankingData(\n        position=dataframe[\"Point [m]\"].tolist(),\n        value=dataframe[\"Banking [deg]\"].apply(math.radians).tolist(),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_configuration","title":"<code>get_configuration()</code>","text":"<p>Returns the configuration of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_configuration(self) -&gt; Configuration:\n    \"\"\"Returns the configuration of the track.\"\"\"\n    return Configuration[\n        str(self._get_info().at[\"Configuration\", 1]).upper()\n    ]\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_direction","title":"<code>get_direction()</code>","text":"<p>Returns the direction of driving.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_direction(self) -&gt; Direction:\n    \"\"\"Returns the direction of driving.\"\"\"\n    return Direction[str(self._get_info().at[\"Direction\", 1]).upper()]\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_elevation_data","title":"<code>get_elevation_data()</code>","text":"<p>Returns the elevation data for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_elevation_data(self) -&gt; ElevationData:\n    \"\"\"Returns the elevation data for the track.\"\"\"\n    dataframe = pandas.read_excel(self.workbook, sheet_name=\"Elevation\")\n    return ElevationData(\n        position=dataframe[\"Point [m]\"].tolist(),\n        value=dataframe[\"Elevation [m]\"].tolist(),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_grip_factor_data","title":"<code>get_grip_factor_data()</code>","text":"<p>Returns the grip factor data for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_grip_factor_data(self) -&gt; GripFactorData:\n    \"\"\"Returns the grip factor data for the track.\"\"\"\n    dataframe = pandas.read_excel(self.workbook, sheet_name=\"Grip Factors\")\n    return GripFactorData(\n        position=dataframe[\"Start Point [m]\"].tolist(),\n        value=dataframe[\"Grip Factor [-]\"].tolist(),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_metadata","title":"<code>get_metadata()</code>","text":"<p>Returns the metadata for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_metadata(self) -&gt; Metadata:\n    \"\"\"Returns the metadata for the track.\"\"\"\n    info = self._get_info()\n    return Metadata(\n        name=str(info.at[\"Name\", 1]),\n        country=str(info.at[\"Country\", 1]),\n        city=str(info.at[\"City\", 1]),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_mirror","title":"<code>get_mirror()</code>","text":"<p>Returns whether the track should be mirrored.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_mirror(self) -&gt; bool:\n    \"\"\"Returns whether the track should be mirrored.\"\"\"\n    mirror_str = str(self._get_info().at[\"Mirror\", 1])\n    return True if mirror_str.lower() in [\"on\", \"yes\", \"true\"] else False\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_sector_data","title":"<code>get_sector_data()</code>","text":"<p>Returns the sector data for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_sector_data(self) -&gt; SectorData:\n    \"\"\"Returns the sector data for the track.\"\"\"\n    dataframe = pandas.read_excel(self.workbook, sheet_name=\"Sectors\")\n    return SectorData(\n        position=dataframe[\"Start Point [m]\"].tolist(),\n        value=dataframe[\"Sector\"].tolist(),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_shape_data","title":"<code>get_shape_data()</code>","text":"<p>Returns the shape data for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_shape_data(self) -&gt; list[ShapeData]:\n    \"\"\"Returns the shape data for the track.\"\"\"\n    dataframe = pandas.read_excel(self.workbook, sheet_name=\"Shape\")\n    return [\n        ShapeData(\n            section_type=SectionType[row[\"Type\"].upper()],\n            length=row[\"Section Length\"],\n            corner_radius=row[\"Corner Radius\"],\n        )\n        for _, row in dataframe.iterrows()\n    ]\n</code></pre>"},{"location":"autoapi/usmlap/utils/","title":"utils","text":""},{"location":"autoapi/usmlap/utils/array/","title":"array","text":"<p>This module contains functions for working with arrays.</p>"},{"location":"autoapi/usmlap/utils/array/#usmlap.utils.array.cumsum","title":"<code>cumsum(values)</code>","text":"<p>Returns the cumulative sum of a list.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[float]</code> <p>The input list.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The cumulative sum of values.</p> Source code in <code>src\\usmlap\\utils\\array.py</code> <pre><code>def cumsum(values: list[float]) -&gt; list[float]:\n    \"\"\"\n    Returns the cumulative sum of a list.\n\n    Args:\n        values (list[float]): The input list.\n\n    Returns:\n        list[float]: The cumulative sum of values.\n    \"\"\"\n    return list(accumulate(values))\n</code></pre>"},{"location":"autoapi/usmlap/utils/array/#usmlap.utils.array.diff","title":"<code>diff(x)</code>","text":"<p>Compute the difference between consecutive elements of a list.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>The input list.</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>list[float]</code> <p>The difference between consecutive elements of x. y has one fewer elements than x.</p> Source code in <code>src\\usmlap\\utils\\array.py</code> <pre><code>def diff(x: list[float]) -&gt; list[float]:\n    \"\"\"\n    Compute the difference between consecutive elements of a list.\n\n    Args:\n        x (list[float]): The input list.\n\n    Returns:\n        y (list[float]): The difference between consecutive elements of x.\n            y has one fewer elements than x.\n    \"\"\"\n    assert len(x) &gt; 1, \"x must have at least two elements\"\n    return [x[i + 1] - x[i] for i in range(len(x) - 1)]\n</code></pre>"},{"location":"autoapi/usmlap/utils/array/#usmlap.utils.array.interp_previous","title":"<code>interp_previous(x, xp, yp)</code>","text":"<p>Interpolate a list of values by choosing the previous value.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>The x-coordinates at which to evaluate the interpolated values.</p> required <code>xp</code> <code>list[float]</code> <p>The x-coordinates of the data points. Must be strictly increasing.</p> required <code>yp</code> <code>list[T]</code> <p>The y-coordinates of the data points. Must be the same length as xp.</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>list[T]</code> <p>The interpolated values. The same length as x.</p> Source code in <code>src\\usmlap\\utils\\array.py</code> <pre><code>def interp_previous(x: list[float], xp: list[float], yp: list[T]) -&gt; list[T]:\n    \"\"\"\n    Interpolate a list of values by choosing the previous value.\n\n    Args:\n        x (list[float]):\n            The x-coordinates at which to evaluate the interpolated values.\n        xp (list[float]):\n            The x-coordinates of the data points. Must be strictly increasing.\n        yp (list[T]):\n            The y-coordinates of the data points. Must be the same length as xp.\n\n    Returns:\n        y (list[T]): The interpolated values. The same length as x.\n    \"\"\"\n    assert len(xp) == len(yp), \"xp and yp must have the same length\"\n    xp.append(math.inf)\n    yp.append(yp[-1])\n\n    pos = 0\n    y: list[T] = []\n\n    for i in range(len(x)):\n        while x[i] &gt;= xp[pos + 1]:\n            pos += 1\n        y.append(yp[pos])\n\n    return y\n</code></pre>"},{"location":"autoapi/usmlap/utils/geometry/","title":"geometry","text":"<p>This module contains utility functions for working with geometry, such as calculating areas and volumes.</p>"},{"location":"autoapi/usmlap/utils/geometry/#usmlap.utils.geometry.area_of_circle","title":"<code>area_of_circle(diameter)</code>","text":"<p>Calculate the area of a circle from its diameter.</p> <p>Parameters:</p> Name Type Description Default <code>diameter</code> <code>float</code> <p>Diameter of the circle.</p> required <p>Returns:</p> Name Type Description <code>area</code> <code>float</code> <p>Area of the circle.</p> Source code in <code>src\\usmlap\\utils\\geometry.py</code> <pre><code>def area_of_circle(diameter: float) -&gt; float:\n    \"\"\"\n    Calculate the area of a circle from its diameter.\n\n    Args:\n        diameter (float): Diameter of the circle.\n\n    Returns:\n        area (float): Area of the circle.\n    \"\"\"\n    return pow(diameter, 2) * (pi / 4)\n</code></pre>"},{"location":"autoapi/usmlap/utils/proportion/","title":"proportion","text":"<p>This module contains utility functions for working with proportions.</p>"},{"location":"autoapi/usmlap/utils/proportion/#usmlap.utils.proportion.normalise","title":"<code>normalise(values)</code>","text":"<p>Normalise a tuple of values.</p> <p>Values retain their relative proportions, but sum to 1.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>tuple[float, float]</code> <p>Tuple of values</p> required <p>Returns:</p> Name Type Description <code>normalised_values</code> <code>tuple[float, float]</code> <p>Tuple of normalised values</p> Source code in <code>src\\usmlap\\utils\\proportion.py</code> <pre><code>def normalise(values: tuple[float, ...]):\n    \"\"\"\n    Normalise a tuple of values.\n\n    Values retain their relative proportions, but sum to 1.\n\n    Args:\n        values (tuple[float, float]): Tuple of values\n\n    Returns:\n        normalised_values (tuple[float, float]): Tuple of normalised values\n    \"\"\"\n    total = sum(values)\n    return tuple(v / total for v in values)\n</code></pre>"},{"location":"autoapi/usmlap/utils/proportion/#usmlap.utils.proportion.split","title":"<code>split(total, proportions)</code>","text":"<p>Split a value proportionally</p> <p>Parameters:</p> Name Type Description Default <code>total</code> <code>float</code> <p>Total value</p> required <code>proportions</code> <code>tuple[float, ...]</code> <p>List of proportions</p> required <p>Returns:</p> Name Type Description <code>split_value</code> <code>tuple[float, ...]</code> <p>Total split proportionally according to proportions</p> Source code in <code>src\\usmlap\\utils\\proportion.py</code> <pre><code>def split(total: float, proportions: tuple[float, ...]):\n    \"\"\"\n    Split a value proportionally\n\n    Args:\n        total (float): Total value\n        proportions (tuple[float, ...]): List of proportions\n\n    Returns:\n        split_value (tuple[float, ...]):\n            Total split proportionally according to proportions\n    \"\"\"\n    return tuple(p * total / sum(proportions) for p in proportions)\n</code></pre>"},{"location":"autoapi/usmlap/utils/proportion/#usmlap.utils.proportion.with_complement","title":"<code>with_complement(proportion)</code>","text":"<p>Get a tuple containing a proportion and its complement</p> <p>Parameters:</p> Name Type Description Default <code>proportion</code> <code>float</code> <p>Value between 0 and 1</p> required <p>Returns:</p> Name Type Description <code>proportion_with_complement</code> <code>tuple[float, float]</code> <p>Tuple of proportion and (1 - proportion)</p> Source code in <code>src\\usmlap\\utils\\proportion.py</code> <pre><code>def with_complement(proportion: float) -&gt; tuple[float, float]:\n    \"\"\"\n    Get a tuple containing a proportion and its complement\n\n    Args:\n        proportion (float): Value between 0 and 1\n\n    Returns:\n        proportion_with_complement (tuple[float, float]):\n            Tuple of proportion and (1 - proportion)\n    \"\"\"\n    complement = 1 - proportion\n    return proportion, complement\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/","title":"vehicle","text":""},{"location":"autoapi/usmlap/vehicle/brakes/","title":"brakes","text":"<p>This module models the brake system of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeCaliper","title":"<code>BrakeCaliper</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The brake caliper, transmitting force from the brake line to the wheel.</p> <p>Attributes:</p> Name Type Description <code>piston_count</code> <code>int</code> <p>The number of pistons in the caliper.</p> <code>piston_diameter</code> <code>float</code> <p>The diameter of the piston.</p> <code>piston_area</code> <code>float</code> <p>The total area of the pistons.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class BrakeCaliper(Subsystem):\n    \"\"\"\n    The brake caliper, transmitting force from the brake line to the wheel.\n\n    Attributes:\n        piston_count (int): The number of pistons in the caliper.\n        piston_diameter (float): The diameter of the piston.\n        piston_area (float): The total area of the pistons.\n    \"\"\"\n\n    piston_count: PositiveInt\n    piston_diameter: Annotated[PositiveFloat, Unit(\"m\")]\n\n    @property\n    def piston_area(self) -&gt; float:\n        return self.piston_count * geometry.area_of_circle(self.piston_diameter)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeDisc","title":"<code>BrakeDisc</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The brake disc attached to the wheel.</p> <p>Attributes:</p> Name Type Description <code>outer_diameter</code> <code>float</code> <p>The outer diameter of the brake disc.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class BrakeDisc(Subsystem):\n    \"\"\"\n    The brake disc attached to the wheel.\n\n    Attributes:\n        outer_diameter (float): The outer diameter of the brake disc.\n    \"\"\"\n\n    outer_diameter: Annotated[PositiveFloat, Unit(\"m\")]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine","title":"<code>BrakeLine</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>An individual brake line.</p> <p>Attributes:</p> Name Type Description <code>cylinder</code> <code>MasterCylinder</code> <p>The master cylinder attached to the pedal.</p> <code>caliper</code> <code>BrakeCaliper</code> <p>The brake caliper attached to the wheel.</p> <code>disc</code> <code>BrakeDisc</code> <p>The brake disc attached to the wheel.</p> <code>pad</code> <code>BrakePad</code> <p>The brake pad attached to the caliper.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class BrakeLine(Subsystem):\n    \"\"\"\n    An individual brake line.\n\n    Attributes:\n        cylinder (MasterCylinder): The master cylinder attached to the pedal.\n        caliper (BrakeCaliper): The brake caliper attached to the wheel.\n        disc (BrakeDisc): The brake disc attached to the wheel.\n        pad (BrakePad): The brake pad attached to the caliper.\n    \"\"\"\n\n    cylinder: MasterCylinder\n    caliper: BrakeCaliper\n    disc: BrakeDisc\n    pad: BrakePad\n\n    @property\n    def _area_scaling_factor(self) -&gt; float:\n        \"\"\"The force scaling factor between the cylinder and caliper.\"\"\"\n        return self.caliper.piston_area / self.cylinder.piston_area\n\n    @property\n    def _effective_radius(self) -&gt; float:\n        \"\"\"The radius at which the braking force is applied to the wheel.\"\"\"\n        return 0.5 * (self.disc.outer_diameter - self.pad.height)\n\n    @property\n    def _force_to_torque_scaling_factor(self) -&gt; float:\n        \"\"\"The ratio between braking torque and master cylinder force.\"\"\"\n        return (\n            self._area_scaling_factor\n            * self.pad.coefficient_of_friction\n            * self._effective_radius\n        )\n\n    def get_brake_pressure(self, cylinder_force: float) -&gt; float:\n        \"\"\"\n        Calculate the pressure of the brake fluid.\n\n        Args:\n            cylinder_force (float): Force applied to the master cylinder.\n\n        Returns:\n            brake_pressure (float): Gauge pressure of the brake fluid.\n        \"\"\"\n        return cylinder_force / self.cylinder.piston_area\n\n    def force_to_torque(self, cylinder_force: float) -&gt; float:\n        \"\"\"\n        Calculate the braking torque applied to the wheel.\n\n        Args:\n            cylinder_force (float): Force applied to the master cylinder.\n\n        Returns:\n            braking_torque (float): Torque applied to the wheel.\n        \"\"\"\n        return cylinder_force * self._force_to_torque_scaling_factor\n\n    def torque_to_force(self, braking_torque: float) -&gt; float:\n        \"\"\"\n        Calculate the force required to apply a torque to the wheel.\n\n        Args:\n            braking_torque (float): Braking torque required on the wheel.\n\n        Returns:\n            cylinder_force (float): Force required on the master cylinder.\n        \"\"\"\n        return braking_torque / self._force_to_torque_scaling_factor\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine.force_to_torque","title":"<code>force_to_torque(cylinder_force)</code>","text":"<p>Calculate the braking torque applied to the wheel.</p> <p>Parameters:</p> Name Type Description Default <code>cylinder_force</code> <code>float</code> <p>Force applied to the master cylinder.</p> required <p>Returns:</p> Name Type Description <code>braking_torque</code> <code>float</code> <p>Torque applied to the wheel.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>def force_to_torque(self, cylinder_force: float) -&gt; float:\n    \"\"\"\n    Calculate the braking torque applied to the wheel.\n\n    Args:\n        cylinder_force (float): Force applied to the master cylinder.\n\n    Returns:\n        braking_torque (float): Torque applied to the wheel.\n    \"\"\"\n    return cylinder_force * self._force_to_torque_scaling_factor\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine.get_brake_pressure","title":"<code>get_brake_pressure(cylinder_force)</code>","text":"<p>Calculate the pressure of the brake fluid.</p> <p>Parameters:</p> Name Type Description Default <code>cylinder_force</code> <code>float</code> <p>Force applied to the master cylinder.</p> required <p>Returns:</p> Name Type Description <code>brake_pressure</code> <code>float</code> <p>Gauge pressure of the brake fluid.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>def get_brake_pressure(self, cylinder_force: float) -&gt; float:\n    \"\"\"\n    Calculate the pressure of the brake fluid.\n\n    Args:\n        cylinder_force (float): Force applied to the master cylinder.\n\n    Returns:\n        brake_pressure (float): Gauge pressure of the brake fluid.\n    \"\"\"\n    return cylinder_force / self.cylinder.piston_area\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine.torque_to_force","title":"<code>torque_to_force(braking_torque)</code>","text":"<p>Calculate the force required to apply a torque to the wheel.</p> <p>Parameters:</p> Name Type Description Default <code>braking_torque</code> <code>float</code> <p>Braking torque required on the wheel.</p> required <p>Returns:</p> Name Type Description <code>cylinder_force</code> <code>float</code> <p>Force required on the master cylinder.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>def torque_to_force(self, braking_torque: float) -&gt; float:\n    \"\"\"\n    Calculate the force required to apply a torque to the wheel.\n\n    Args:\n        braking_torque (float): Braking torque required on the wheel.\n\n    Returns:\n        cylinder_force (float): Force required on the master cylinder.\n    \"\"\"\n    return braking_torque / self._force_to_torque_scaling_factor\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakePad","title":"<code>BrakePad</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The brake pad attached to the caliper.</p> <p>Attributes:</p> Name Type Description <code>height</code> <code>float</code> <p>The height of the brake pad.</p> <code>coefficient_of_friction</code> <code>float</code> <p>The coefficient of friction between the brake pad and brake disc.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class BrakePad(Subsystem):\n    \"\"\"\n    The brake pad attached to the caliper.\n\n    Attributes:\n        height (float): The height of the brake pad.\n        coefficient_of_friction (float):\n            The coefficient of friction between the brake pad and brake disc.\n    \"\"\"\n\n    height: Annotated[PositiveFloat, Unit(\"m\")]\n    coefficient_of_friction: PositiveFloat\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.Brakes","title":"<code>Brakes</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The brake system of the vehicle.</p> <p>Attributes:</p> Name Type Description <code>front</code> <code>BrakeLine</code> <p>Brake line for the front wheels.</p> <code>rear</code> <code>BrakeLine</code> <p>Brake line for the rear wheels.</p> <code>pedal_ratio</code> <code>float</code> <p>Ratio of master cylinder force to pedal force.</p> <code>front_brake_bias</code> <code>float</code> <p>Proportion of force applied to the front master cylinder (value between 0 and 1).</p> <code>regen_torque</code> <code>float</code> <p>Maximum regenerative braking torque.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class Brakes(Subsystem):\n    \"\"\"\n    The brake system of the vehicle.\n\n    Attributes:\n        front (BrakeLine): Brake line for the front wheels.\n        rear (BrakeLine): Brake line for the rear wheels.\n        pedal_ratio (float): Ratio of master cylinder force to pedal force.\n        front_brake_bias (float):\n            Proportion of force applied to the front master cylinder\n            (value between 0 and 1).\n        regen_torque (float): Maximum regenerative braking torque.\n    \"\"\"\n\n    front: BrakeLine\n    rear: BrakeLine\n    pedal_ratio: PositiveFloat\n    front_brake_bias: Percentage\n    regen_torque: Annotated[PositiveFloat, Unit(\"Nm\")]\n\n    @property\n    def brake_bias(self) -&gt; FrontRear[float]:\n        \"\"\"Tuple of brake biases for the front and rear wheels.\"\"\"\n        return FrontRear(proportion.with_complement(self.front_brake_bias))\n\n    @property\n    def brake_lines(self) -&gt; FrontRear[BrakeLine]:\n        \"\"\"Tuple of front and rear brake lines.\"\"\"\n        return FrontRear((self.front, self.rear))\n\n    def _get_front_brake_balance(self) -&gt; float:\n        front_multiplier = self.front.force_to_torque(1)\n        rear_multiplier = self.rear.force_to_torque(1)\n        return front_multiplier / (front_multiplier + rear_multiplier)\n\n    def _get_cylinder_forces(self, pedal_force: float) -&gt; FrontRear[float]:\n        \"\"\"\n        Get the force applied to the front and rear master cylinders.\n\n        Args:\n            pedal_force (float): Force applied to the pedal.\n\n        Returns:\n            cylinder_forces (FrontRear[float]):\n                Force applied to the master cylinders.\n        \"\"\"\n        total_force = pedal_force * self.pedal_ratio\n        return FrontRear([total_force * bias for bias in self.brake_bias])\n\n    def pedal_force_to_wheel_torque(\n        self, pedal_force: float\n    ) -&gt; FrontRear[float]:\n        cylinder_forces = self._get_cylinder_forces(pedal_force)\n        return FrontRear(\n            brake_line.force_to_torque(force)\n            for brake_line, force in zip(self.brake_lines, cylinder_forces)\n        )\n\n    def get_overall_brake_balance(self) -&gt; FrontRear[float]:\n        torques = self.pedal_force_to_wheel_torque(1)\n        return FrontRear(proportion.normalise(torques))\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.Brakes.brake_bias","title":"<code>brake_bias</code>  <code>property</code>","text":"<p>Tuple of brake biases for the front and rear wheels.</p>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.Brakes.brake_lines","title":"<code>brake_lines</code>  <code>property</code>","text":"<p>Tuple of front and rear brake lines.</p>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.MasterCylinder","title":"<code>MasterCylinder</code>","text":"<p>               Bases: <code>Component</code></p> <p>The master cylinder, transmitting force from the pedal to the brake line.</p> <p>Attributes:</p> Name Type Description <code>piston_diameter</code> <code>float</code> <p>The diameter of the piston.</p> <code>colour</code> <code>str</code> <p>The colour of the master cylinder.</p> <code>piston_area</code> <code>float</code> <p>The area of the piston.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class MasterCylinder(Component):\n    \"\"\"\n    The master cylinder, transmitting force from the pedal to the brake line.\n\n    Attributes:\n        piston_diameter (float): The diameter of the piston.\n        colour (str): The colour of the master cylinder.\n        piston_area (float): The area of the piston.\n    \"\"\"\n\n    piston_diameter: Annotated[PositiveFloat, Unit(\"m\")]\n    colour: str\n\n    @property\n    def piston_area(self) -&gt; float:\n        return geometry.area_of_circle(self.piston_diameter)\n\n    @classmethod\n    def library_name(cls) -&gt; str:\n        return \"master_cylinders.json\"\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/","title":"common","text":"<p>This module contains code shared by all vehicle components.</p>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>ABC</code>, <code>Subsystem</code></p> <p>Abstract base class for vehicle components.</p> <p>Provides functionality for loading components from a library.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>class Component(ABC, Subsystem):\n    \"\"\"\n    Abstract base class for vehicle components.\n\n    Provides functionality for loading components from a library.\n    \"\"\"\n\n    @classmethod\n    @abstractmethod\n    def library_name(cls) -&gt; str:\n        pass\n\n    @classmethod\n    def _get_library_path(cls) -&gt; str:\n        return \"appdata/library/components/\" + cls.library_name()\n\n    @classmethod\n    def load_library(cls) -&gt; dict[str, Self]:\n        with open(cls._get_library_path(), \"r\") as library_file:\n            library = json.load(library_file)\n            return {\n                name: cls(**dictionary) for name, dictionary in library.items()\n            }\n\n    @classmethod\n    def from_library(cls, name: str) -&gt; Self:\n        library = cls.load_library()\n        library_name = cls.library_name()\n        if name not in library:\n            raise KeyError(\n                f\"Component '{name}' not found in library '{library_name}'\"\n                f\" (available components: {list(library.keys())})\"\n            )\n        return library[name]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Subsystem","title":"<code>Subsystem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Abstract base class for vehicle subsystems.</p> <p>Provides functionality for loading from, and saving to, JSON.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>class Subsystem(BaseModel):\n    \"\"\"\n    Abstract base class for vehicle subsystems.\n\n    Provides functionality for loading from, and saving to, JSON.\n    \"\"\"\n\n    @classmethod\n    def from_json(cls, filepath: str) -&gt; Self:\n        \"\"\"\n        Load a subsystem from a JSON file.\n\n        Args:\n            filepath (str): The path to the JSON file.\n\n        Returns:\n            subsystem (Self): The loaded subsystem.\n        \"\"\"\n        with open(filepath, \"r\") as file:\n            return cls.model_validate_json(file.read())\n\n    def to_json(self) -&gt; str:\n        \"\"\"\n        Converts a subsystem to a JSON string.\n\n        Args:\n            self (Subsystem): The subsystem to convert.\n\n        Returns:\n            json_string (str): The JSON string representation of the subsystem.\n        \"\"\"\n        return self.model_dump_json(indent=4)\n\n    def __str__(self) -&gt; str:\n        return self.to_json()\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Subsystem.from_json","title":"<code>from_json(filepath)</code>  <code>classmethod</code>","text":"<p>Load a subsystem from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Name Type Description <code>subsystem</code> <code>Self</code> <p>The loaded subsystem.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>@classmethod\ndef from_json(cls, filepath: str) -&gt; Self:\n    \"\"\"\n    Load a subsystem from a JSON file.\n\n    Args:\n        filepath (str): The path to the JSON file.\n\n    Returns:\n        subsystem (Self): The loaded subsystem.\n    \"\"\"\n    with open(filepath, \"r\") as file:\n        return cls.model_validate_json(file.read())\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Subsystem.to_json","title":"<code>to_json()</code>","text":"<p>Converts a subsystem to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>Subsystem</code> <p>The subsystem to convert.</p> required <p>Returns:</p> Name Type Description <code>json_string</code> <code>str</code> <p>The JSON string representation of the subsystem.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"\n    Converts a subsystem to a JSON string.\n\n    Args:\n        self (Subsystem): The subsystem to convert.\n\n    Returns:\n        json_string (str): The JSON string representation of the subsystem.\n    \"\"\"\n    return self.model_dump_json(indent=4)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/steering/","title":"steering","text":"<p>This module models the steering system of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/steering/#usmlap.vehicle.steering.Steering","title":"<code>Steering</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The steering system of the vehicle.</p> <p>Attributes:</p> Name Type Description <code>steering_ratio</code> <code>float</code> <p>The ratio of steering angle to wheel angle. A steering ratio of 5 means that for every 5 degrees the steering wheel is rotated, the wheels rotate 1 degree.</p> <code>steering_wheel_radius</code> <code>float</code> <p>The radius of the steering wheel.</p> Source code in <code>src\\usmlap\\vehicle\\steering.py</code> <pre><code>class Steering(Subsystem):\n    \"\"\"\n    The steering system of the vehicle.\n\n    Attributes:\n        steering_ratio (float): The ratio of steering angle to wheel angle.\n            A steering ratio of 5 means that\n            for every 5 degrees the steering wheel is rotated,\n            the wheels rotate 1 degree.\n        steering_wheel_radius (float): The radius of the steering wheel.\n    \"\"\"\n\n    steering_ratio: PositiveFloat\n    steering_wheel_radius: Annotated[PositiveFloat, Unit(\"m\")]\n\n    def get_steering_wheel_angle(self, wheel_angle: float) -&gt; float:\n        \"\"\"\n        Calculate the steering wheel angle required for a given wheel angle.\n\n        Args:\n            wheel_angle (float):\n                Angular displacement of the wheel from static\n                (clockwise positive).\n\n        Returns:\n            steering_wheel_angle (float):\n                Angular displacement of the steering wheel from neutral\n                (clockwise positive).\n        \"\"\"\n        return wheel_angle * self.steering_ratio\n\n    def get_wheel_angle(self, steering_wheel_angle: float) -&gt; float:\n        \"\"\"\n        Calculate the wheel angle for a given steering angle.\n\n        Args:\n            steering_wheel_angle (float):\n                Angular displacement of the steering wheel from neutral\n                (clockwise positive).\n\n        Returns:\n            wheel_angle (float):\n                Angular displacement of the wheels from static\n                (clockwise positive).\n        \"\"\"\n        return steering_wheel_angle / self.steering_ratio\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/steering/#usmlap.vehicle.steering.Steering.get_steering_wheel_angle","title":"<code>get_steering_wheel_angle(wheel_angle)</code>","text":"<p>Calculate the steering wheel angle required for a given wheel angle.</p> <p>Parameters:</p> Name Type Description Default <code>wheel_angle</code> <code>float</code> <p>Angular displacement of the wheel from static (clockwise positive).</p> required <p>Returns:</p> Name Type Description <code>steering_wheel_angle</code> <code>float</code> <p>Angular displacement of the steering wheel from neutral (clockwise positive).</p> Source code in <code>src\\usmlap\\vehicle\\steering.py</code> <pre><code>def get_steering_wheel_angle(self, wheel_angle: float) -&gt; float:\n    \"\"\"\n    Calculate the steering wheel angle required for a given wheel angle.\n\n    Args:\n        wheel_angle (float):\n            Angular displacement of the wheel from static\n            (clockwise positive).\n\n    Returns:\n        steering_wheel_angle (float):\n            Angular displacement of the steering wheel from neutral\n            (clockwise positive).\n    \"\"\"\n    return wheel_angle * self.steering_ratio\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/steering/#usmlap.vehicle.steering.Steering.get_wheel_angle","title":"<code>get_wheel_angle(steering_wheel_angle)</code>","text":"<p>Calculate the wheel angle for a given steering angle.</p> <p>Parameters:</p> Name Type Description Default <code>steering_wheel_angle</code> <code>float</code> <p>Angular displacement of the steering wheel from neutral (clockwise positive).</p> required <p>Returns:</p> Name Type Description <code>wheel_angle</code> <code>float</code> <p>Angular displacement of the wheels from static (clockwise positive).</p> Source code in <code>src\\usmlap\\vehicle\\steering.py</code> <pre><code>def get_wheel_angle(self, steering_wheel_angle: float) -&gt; float:\n    \"\"\"\n    Calculate the wheel angle for a given steering angle.\n\n    Args:\n        steering_wheel_angle (float):\n            Angular displacement of the steering wheel from neutral\n            (clockwise positive).\n\n    Returns:\n        wheel_angle (float):\n            Angular displacement of the wheels from static\n            (clockwise positive).\n    \"\"\"\n    return steering_wheel_angle / self.steering_ratio\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/suspension/","title":"suspension","text":"<p>This module models the suspension of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/suspension/#usmlap.vehicle.suspension.Suspension","title":"<code>Suspension</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The suspension system of a vehicle.</p> <p>Attributes:</p> Name Type Description <code>front</code> <code>SuspensionAxle</code> <p>Front axle suspension.</p> <code>rear</code> <code>SuspensionAxle</code> <p>Rear axle suspension.</p> <code>wheelbase</code> <code>float</code> <p>The distance between the front and rear wheels, measured between contact patches.</p> <code>front_track_width</code> <code>float</code> <p>The width of the front track, measured between contact patches.</p> <code>rear_track_width</code> <code>float</code> <p>The width of the rear track, measured between contact patches.</p> <code>centre_of_gravity_height</code> <code>float</code> <p>The height of the centre of gravity above the ground plane.</p> Source code in <code>src\\usmlap\\vehicle\\suspension.py</code> <pre><code>class Suspension(Subsystem):\n    \"\"\"\n    The suspension system of a vehicle.\n\n    Attributes:\n        front (SuspensionAxle):\n            Front axle suspension.\n        rear (SuspensionAxle):\n            Rear axle suspension.\n        wheelbase (float):\n            The distance between the front and rear wheels,\n            measured between contact patches.\n        front_track_width (float):\n            The width of the front track,\n            measured between contact patches.\n        rear_track_width (float):\n            The width of the rear track,\n            measured between contact patches.\n        centre_of_gravity_height (float):\n            The height of the centre of gravity above the ground plane.\n    \"\"\"\n\n    front: SuspensionAxle\n    rear: SuspensionAxle\n    wheelbase: Annotated[PositiveFloat, Unit(\"m\")]\n    front_track_width: Annotated[PositiveFloat, Unit(\"m\")]\n    rear_track_width: Annotated[PositiveFloat, Unit(\"m\")]\n    centre_of_gravity_height: Annotated[PositiveFloat, Unit(\"m\")]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/suspension/#usmlap.vehicle.suspension.SuspensionAxle","title":"<code>SuspensionAxle</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The suspension for a single axle of a vehicle.</p> Source code in <code>src\\usmlap\\vehicle\\suspension.py</code> <pre><code>class SuspensionAxle(Subsystem):\n    \"\"\"\n    The suspension for a single axle of a vehicle.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/transmission/","title":"transmission","text":"<p>This module models the transmission of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/transmission/#usmlap.vehicle.transmission.Transmission","title":"<code>Transmission</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The transmission of the vehicle.</p> <p>Transmits power from the motor to the wheels.</p> <p>Attributes:</p> Name Type Description <code>primary_gear_reduction</code> <code>float</code> <p>The reduction of the primary gear.</p> <code>final_gear_reduction</code> <code>float</code> <p>The reduction of the final gear.</p> <code>gear_ratio</code> <code>list[float]</code> <p>The ratios of the gears.</p> Source code in <code>src\\usmlap\\vehicle\\transmission.py</code> <pre><code>class Transmission(Subsystem):\n    \"\"\"\n    The transmission of the vehicle.\n\n    Transmits power from the motor to the wheels.\n\n    Attributes:\n        primary_gear_reduction (float): The reduction of the primary gear.\n        final_gear_reduction (float): The reduction of the final gear.\n        gear_ratio (list[float]): The ratios of the gears.\n    \"\"\"\n\n    primary_gear_reduction: PositiveFloat\n    final_gear_reduction: PositiveFloat\n    gear_ratio: Annotated[list[PositiveFloat], MinLen(1)]\n\n    @property\n    def overall_gear_ratio(self) -&gt; list[float]:\n        gear_reduction = self.primary_gear_reduction * self.final_gear_reduction\n        return [gear_reduction * ratio for ratio in self.gear_ratio]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/","title":"tyre","text":""},{"location":"autoapi/usmlap/vehicle/tyre/magic_formula/","title":"magic_formula","text":"<p>This module implements the Pacejka Magic Formula tyre model.</p> <p>Equations are taken from Chapter 4.3.2 of Tire and Vehicle Dynamics (3rd Edition) by Hans Pacejka, and numbered accordingly. https://www.sciencedirect.com/book/9780080970165/tire-and-vehicle-dynamics</p> <p>These equations are in accordance with the MF-Tire/MF-Swift 6.1.2 Equation Manual, or MF612 for short.</p> <p>The following repositories have been used as a starting point for this module:</p> <ul> <li> <p>Tire Dynamics (Python):     https://github.com/JyNing04/Pacejka-tire-model/tree/main</p> </li> <li> <p>Magic Formula Tyre Library (MATLAB):     https://github.com/teasit/magic-formula-tyre-library/tree/main</p> </li> </ul>"},{"location":"autoapi/usmlap/vehicle/tyre/magic_formula/#usmlap.vehicle.tyre.magic_formula.MagicFormula","title":"<code>MagicFormula</code>","text":"<p>               Bases: <code>object</code></p> <p>Contains the Pacejka Magic Formula equations.</p> <p>Attributes:</p> Name Type Description <code>parameters</code> <code>TIRParameters</code> <p>Tyre parameters loaded from a .TIR file.</p> <code>AMU</code> <code>float</code> <p>Constant used in calculation of digressive friction factor.</p> <code>LMUV</code> <code>float</code> <p>Scaling factor with slip speed vs decaying friction.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\magic_formula.py</code> <pre><code>class MagicFormula(object):\n    \"\"\"\n    Contains the Pacejka Magic Formula equations.\n\n    Attributes:\n        parameters (TIRParameters):\n            Tyre parameters loaded from a .TIR file.\n        AMU (float):\n            Constant used in calculation of digressive friction factor.\n        LMUV (float):\n            Scaling factor with slip speed vs decaying friction.\n    \"\"\"\n\n    def __init__(self, parameters: TIRParameters, tyre: TyreAttitude) -&gt; None:\n        self.parameters = parameters\n        self.tyre = tyre\n        self.AMU = 1  # Used in calculation of digressive friction factor.\n        self.LMUV = 0  # Scaling factor with slip speed vs decaying friction.\n        self.use_alpha_star = True\n\n    @property\n    def Fz(self) -&gt; float:  # noqa: S100\n        return self.Fz\n\n    @property\n    def R0(self) -&gt; float:  # noqa: S100\n        return self.parameters.DIMENSION.UNLOADED_RADIUS\n\n    @property\n    def pressure_ratio(self) -&gt; float:\n        return self.tyre.pressure / self.parameters.OPERATING_CONDITIONS.NOMPRES\n\n    @property  # (4.E1)\n    def Fz0_prime(self) -&gt; float:  # noqa: S100\n        nominal_load = self.parameters.VERTICAL.FNOMIN\n        nominal_load_scaling_factor = self.parameters.SCALING_COEFFICIENTS.LFZO\n        return nominal_load_scaling_factor * nominal_load\n\n    @property  # (4.E2a)\n    def dfz(self) -&gt; float:\n        return (self.Fz / self.Fz0_prime) - 1\n\n    @property  # (4.E2b)\n    def dpi(self) -&gt; float:\n        return self.pressure_ratio - 1\n\n    @property  # (4.E3)\n    def alpha(self) -&gt; float:\n        if self.use_alpha_star:\n            return tan(self.tyre.alpha) * sign(self.tyre.Vc.x)\n        else:\n            return self.tyre.alpha\n\n    @property  # (4.E4)\n    def gamma(self) -&gt; float:\n        return sin(self.tyre.gamma)\n\n    @property  # (4.E5)\n    def kappa(self) -&gt; float:\n        return self.tyre.kappa\n\n    @property  # (4.E6)\n    def cos_a(self) -&gt; float:\n        return self.tyre.Vc.x / (self.tyre.Vc.norm() + EPSILON)\n\n    @property  # (4.E7a)\n    def lmux_star(self) -&gt; float:  # With LMUV = 0, LMU* = LMU\n        return self.parameters.SCALING_COEFFICIENTS.LMUX\n\n    @property  # (4.E7b)\n    def lmuy_star(self) -&gt; float:  # With LMUV = 0, LMU* = LMU\n        return self.parameters.SCALING_COEFFICIENTS.LMUY\n\n    # Helper function for (4.E8)\n    def digressive_friction_factor(self, lmu_star: float) -&gt; float:\n        return self.AMU * lmu_star / (1 + (self.AMU - 1) * lmu_star)\n\n    @property  # (4.E8a)\n    def lmux_prime(self) -&gt; float:\n        return self.digressive_friction_factor(self.lmux_star)\n\n    @property  # (4.E8b)\n    def lmuy_prime(self) -&gt; float:\n        return self.digressive_friction_factor(self.lmuy_star)\n\n    @property  # (4.E9)\n    def Fx0(self) -&gt; float:  # noqa: S100\n        return self.magic_formula(\n            self.Bx, self.Cx, self.Dx, self.Ex, self.kx, self.SVx\n        )\n\n    @property  # (4.E10)\n    def kx(self) -&gt; float:\n        return self.kappa + self.SHx\n\n    @property  # (4.E11)\n    def Cx(self) -&gt; float:  # noqa: S100\n        PCX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PCX1\n        LCX = self.parameters.SCALING_COEFFICIENTS.LCX\n        return PCX1 * LCX\n\n    @property  # (4.E12)\n    def Dx(self) -&gt; float:  # noqa: S100\n        return self.mux * self.Fz\n\n    @property  # (4.E13)\n    def mux(self) -&gt; float:\n        PDX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PDX1\n        PDX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PDX2\n        PPX3 = self.parameters.LONGITUDINAL_COEFFICIENTS.PPX3\n        PPX4 = self.parameters.LONGITUDINAL_COEFFICIENTS.PPX4\n        PDX3 = self.parameters.LONGITUDINAL_COEFFICIENTS.PDX3\n        load_factor = PDX1 + PDX2 * self.dfz\n        pressure_factor = 1 + PPX3 * self.dpi + PPX4 * self.dpi**2\n        camber_factor = 1 - PDX3 * self.tyre.gamma**2\n        return load_factor * pressure_factor * camber_factor * self.lmux_star\n\n    @property  # (4.E14)\n    def Ex(self) -&gt; float:  # noqa: S100\n        PEX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PEX1\n        PEX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PEX2\n        PEX3 = self.parameters.LONGITUDINAL_COEFFICIENTS.PEX3\n        PEX4 = self.parameters.LONGITUDINAL_COEFFICIENTS.PEX4\n        LEX = self.parameters.SCALING_COEFFICIENTS.LEX\n        load_factor = PEX1 + PEX2 * self.dfz + PEX3 * self.dfz**2\n        slip_factor = 1 - PEX4 * sign(self.kx)\n        return load_factor * slip_factor * LEX\n\n    @property  # (4.E15)\n    def Kxk(self) -&gt; float:  # noqa: S100\n        PKX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PKX1\n        PKX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PKX2\n        PKX3 = self.parameters.LONGITUDINAL_COEFFICIENTS.PKX3\n        PPX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PPX1\n        PPX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PPX2\n        load_factor = self.Fz * (PKX1 + PKX2 * self.dfz) * exp(PKX3 * self.dfz)\n        pressure_factor = 1 + PPX1 * self.dpi + PPX2 * self.dpi**2\n        return load_factor * pressure_factor\n\n    @property  # (4.E16)\n    def Bx(self) -&gt; float:  # noqa: S100\n        return self.Kxk / (self.Cx * self.Dx + EPSILON)\n\n    @property  # (4.E17)\n    def SHx(self) -&gt; float:  # noqa: S100\n        PHX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PHX1\n        PHX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PHX2\n        LHX = self.parameters.SCALING_COEFFICIENTS.LHX\n        return (PHX1 + PHX2 * self.dfz) * LHX\n\n    @property  # (4.E18)\n    def SVx(self) -&gt; float:  # noqa: S100\n        PVX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PVX1\n        PVX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PVX2\n        LVX = self.parameters.SCALING_COEFFICIENTS.LVX\n        return self.Fz * (PVX1 + PVX2 * self.dfz) * LVX * self.lmux_prime\n\n    @property  # (4.E19)\n    def Fy0(self) -&gt; float:  # noqa: S100\n        return self.magic_formula(\n            self.By, self.Cy, self.Dy, self.Ey, self.alpha_y, self.SVy\n        )\n\n    @property  # (4.E20)\n    def alpha_y(self) -&gt; float:\n        return self.alpha + self.SHy\n\n    @property  # (4.E21)\n    def Cy(self) -&gt; float:  # noqa: S100\n        PCY1 = self.parameters.LATERAL_COEFFICIENTS.PCY1\n        LCY = self.parameters.SCALING_COEFFICIENTS.LCY\n        return PCY1 * LCY\n\n    @property  # (4.E22)\n    def Dy(self) -&gt; float:  # noqa: S100\n        return self.muy * self.Fz\n\n    @property  # (4.E23)\n    def muy(self) -&gt; float:\n        PDY1 = self.parameters.LATERAL_COEFFICIENTS.PDY1\n        PDY2 = self.parameters.LATERAL_COEFFICIENTS.PDY2\n        PPY3 = self.parameters.LATERAL_COEFFICIENTS.PPY3\n        PPY4 = self.parameters.LATERAL_COEFFICIENTS.PPY4\n        PDY3 = self.parameters.LATERAL_COEFFICIENTS.PDY3\n        load_factor = PDY1 + PDY2 * self.dfz\n        pressure_factor = 1 + PPY3 * self.dpi + PPY4 * self.dpi**2\n        camber_factor = 1 - PDY3 * self.gamma**2\n        return load_factor * pressure_factor * camber_factor * self.lmuy_star\n\n    @property  # (4.E24)\n    def Ey(self) -&gt; float:  # noqa: S100\n        PEY1 = self.parameters.LATERAL_COEFFICIENTS.PEY1\n        PEY2 = self.parameters.LATERAL_COEFFICIENTS.PEY2\n        PEY3 = self.parameters.LATERAL_COEFFICIENTS.PEY3\n        PEY4 = self.parameters.LATERAL_COEFFICIENTS.PEY4\n        PEY5 = self.parameters.LATERAL_COEFFICIENTS.PEY5\n        LEY = self.parameters.SCALING_COEFFICIENTS.LEY\n        load_factor = PEY1 + PEY2 * self.dfz\n        camber_term = (PEY3 + PEY4 * self.gamma) * sign(self.alpha_y)\n        return load_factor * (1 - camber_term + PEY5 * self.gamma**2) * LEY\n\n    @property  # (4.E25)\n    def Kya(self) -&gt; float:  # noqa: S100\n        PKY1 = self.parameters.LATERAL_COEFFICIENTS.PKY1\n        PKY2 = self.parameters.LATERAL_COEFFICIENTS.PKY2\n        PKY3 = self.parameters.LATERAL_COEFFICIENTS.PKY3\n        PKY4 = self.parameters.LATERAL_COEFFICIENTS.PKY4\n        PKY5 = self.parameters.LATERAL_COEFFICIENTS.PKY5\n        PPY1 = self.parameters.LATERAL_COEFFICIENTS.PPY1\n        PPY2 = self.parameters.LATERAL_COEFFICIENTS.PPY2\n        LKY = self.parameters.SCALING_COEFFICIENTS.LKY\n        load_factor = PKY1 * self.Fz0_prime\n        pressure_factor = 1 + PPY1 * self.dpi\n        camber_factor = 1 - PKY3 * abs(self.gamma)\n        adapted_load_ratio = self.Fz / self.Fz0_prime\n        factor_K = (PKY2 + PKY5 * self.gamma**2) * (1 + PPY2 * self.dpi)\n        sine_factor = sin(PKY4 * atan(adapted_load_ratio / factor_K))\n        return load_factor * pressure_factor * camber_factor * sine_factor * LKY\n\n    @property  # (4.E26)\n    def By(self) -&gt; float:  # noqa: S100\n        return self.Kya / (self.Cy * self.Dy + EPSILON)\n\n    @property  # (4.E27)\n    def SHy(self) -&gt; float:  # noqa: S100\n        PHY1 = self.parameters.LATERAL_COEFFICIENTS.PHY1\n        PHY2 = self.parameters.LATERAL_COEFFICIENTS.PHY2\n        LHY = self.parameters.SCALING_COEFFICIENTS.LHY\n        nominal_shift = (PHY1 + PHY2 * self.dfz) * LHY\n        stiffness_factor = self.Kya + EPSILON\n        camber_shift = (self.Kyc0 * self.gamma - self.SVyc) / stiffness_factor\n        return nominal_shift + camber_shift\n\n    @property  # (4.E28)\n    def SVyc(self) -&gt; float:  # noqa: S100\n        PVY3 = self.parameters.LATERAL_COEFFICIENTS.PVY3\n        PVY4 = self.parameters.LATERAL_COEFFICIENTS.PVY4\n        LKYC = self.parameters.SCALING_COEFFICIENTS.LKYC\n        load_factor = self.Fz * (PVY3 + PVY4 * self.dfz)\n        return load_factor * self.gamma * LKYC * self.lmuy_prime\n\n    @property  # (4.E29)\n    def SVy(self) -&gt; float:  # noqa: S100\n        PVY1 = self.parameters.LATERAL_COEFFICIENTS.PVY1\n        PVY2 = self.parameters.LATERAL_COEFFICIENTS.PVY2\n        LVY = self.parameters.SCALING_COEFFICIENTS.LVY\n        load_factor = self.Fz * (PVY1 + PVY2 * self.dfz)\n        return load_factor * LVY * self.lmuy_prime + self.SVyc\n\n    @property  # (4.E30)\n    def Kyc0(self) -&gt; float:  # noqa: S100\n        PKY6 = self.parameters.LATERAL_COEFFICIENTS.PKY6\n        PKY7 = self.parameters.LATERAL_COEFFICIENTS.PKY7\n        PPY5 = self.parameters.LATERAL_COEFFICIENTS.PKY5\n        LKYC = self.parameters.SCALING_COEFFICIENTS.LKYC\n        return self.Fz * (PKY6 + PKY7 * self.dfz) * (1 + PPY5 * self.dpi) * LKYC\n\n    @property  # (4.E31)\n    def Mz0(self) -&gt; float:  # noqa: S100\n        return self.Mz0_prime + self.Mzr0\n\n    @property  # (4.E32)\n    def Mz0_prime(self) -&gt; float:  # noqa: S100\n        return -self.t0 * self.Fy0\n\n    @property  # (4.E33)\n    def t0(self) -&gt; float:\n        magic_factor = self.magic_formula(\n            self.Bt, self.Ct, self.Dt, self.Et, self.a_t, 0\n        )\n        return magic_factor * self.cos_a\n\n    @property  # (4.E34)\n    def a_t(self) -&gt; float:\n        return self.alpha + self.SHt\n\n    @property  # (4.E35)\n    def SHt(self) -&gt; float:  # noqa: S100\n        QHZ1 = self.parameters.ALIGNING_COEFFICIENTS.QHZ1\n        QHZ2 = self.parameters.ALIGNING_COEFFICIENTS.QHZ2\n        QHZ3 = self.parameters.ALIGNING_COEFFICIENTS.QHZ3\n        QHZ4 = self.parameters.ALIGNING_COEFFICIENTS.QHZ4\n        return QHZ1 + QHZ2 * self.dfz + (QHZ3 + QHZ4 * self.dfz) * self.gamma\n\n    @property  # (4.E36)\n    def Mzr0(self) -&gt; float:  # noqa: S100\n        magic_factor = self.magic_formula_cosine(\n            self.Br, self.Cr, self.Dr, 0, self.a_r\n        )\n        return magic_factor * self.cos_a\n\n    @property  # (4.E37)\n    def a_r(self) -&gt; float:\n        return self.alpha + self.SHf\n\n    @property  # (4.E38)\n    def SHf(self) -&gt; float:  # noqa: S100\n        return self.SHy + self.SVy / (self.Kya + EPSILON)\n\n    @property  # (4.E40)\n    def Bt(self) -&gt; float:  # noqa: S100\n        QBZ1 = self.parameters.ALIGNING_COEFFICIENTS.QBZ1\n        QBZ2 = self.parameters.ALIGNING_COEFFICIENTS.QBZ2\n        QBZ3 = self.parameters.ALIGNING_COEFFICIENTS.QBZ3\n        QBZ5 = self.parameters.ALIGNING_COEFFICIENTS.QBZ5\n        QBZ6 = self.parameters.ALIGNING_COEFFICIENTS.QBZ6\n        LKY = self.parameters.SCALING_COEFFICIENTS.LKY\n        load_factor = QBZ1 + QBZ2 * self.dfz + QBZ3 * self.dfz**2\n        camber_factor = 1 + QBZ5 * abs(self.gamma) * QBZ6 * self.gamma**2\n        return load_factor * camber_factor * LKY / self.lmuy_prime\n\n    @property  # (4.E41)\n    def Ct(self) -&gt; float:  # noqa: S100\n        return self.parameters.ALIGNING_COEFFICIENTS.QCZ1\n\n    @property  # (4.E42)\n    def Dt0(self) -&gt; float:  # noqa: S100\n        QDZ1 = self.parameters.ALIGNING_COEFFICIENTS.QDZ1\n        QDZ2 = self.parameters.ALIGNING_COEFFICIENTS.QDZ2\n        PPZ1 = self.parameters.ALIGNING_COEFFICIENTS.PPZ1\n        LTR = self.parameters.SCALING_COEFFICIENTS.LTR\n        load_factor = (self.R0 / self.Fz0_prime) * (QDZ1 + QDZ2 * self.dfz)\n        pressure_factor = 1 - PPZ1 * self.dpi\n        return self.Fz * load_factor * pressure_factor * LTR\n\n    @property  # (4.E43)\n    def Dt(self) -&gt; float:  # noqa: S100\n        QDZ3 = self.parameters.ALIGNING_COEFFICIENTS.QDZ3\n        QDZ4 = self.parameters.ALIGNING_COEFFICIENTS.QDZ4\n        return self.Dt0 * (1 + QDZ3 * abs(self.gamma) + QDZ4 * self.gamma**2)\n\n    @property  # (4.E44)\n    def Et(self) -&gt; float:  # noqa: S100\n        QEZ1 = self.parameters.ALIGNING_COEFFICIENTS.QEZ1\n        QEZ2 = self.parameters.ALIGNING_COEFFICIENTS.QEZ2\n        QEZ3 = self.parameters.ALIGNING_COEFFICIENTS.QEZ3\n        QEZ4 = self.parameters.ALIGNING_COEFFICIENTS.QEZ4\n        QEZ5 = self.parameters.ALIGNING_COEFFICIENTS.QEZ5\n        load_factor = QEZ1 + QEZ2 * self.dfz + QEZ3 * self.dfz**2\n        camber_factor = QEZ4 + QEZ5 * self.gamma\n        shape_factor = (2 / pi) * atan(self.Bt * self.Ct * self.a_t)\n        return load_factor * (1 + camber_factor * shape_factor)\n\n    @property  # (4.E45)\n    def Br(self) -&gt; float:  # noqa: S100\n        QBZ9 = self.parameters.ALIGNING_COEFFICIENTS.QBZ9\n        QBZ10 = self.parameters.ALIGNING_COEFFICIENTS.QBZ10\n        LKY = self.parameters.SCALING_COEFFICIENTS.LKY\n        return QBZ9 * LKY / self.lmuy_star + QBZ10 * self.By * self.Cy\n\n    @property  # (4.E46)\n    def Cr(self) -&gt; float:  # noqa: S100\n        return 1\n\n    @property  # (4.E47)\n    def Dr(self) -&gt; float:  # noqa: S100\n        align = self.parameters.ALIGNING_COEFFICIENTS\n        LRES = self.parameters.SCALING_COEFFICIENTS.LRES\n        LKZC = self.parameters.SCALING_COEFFICIENTS.LKZC\n        load_factor = (align.QDZ6 + align.QDZ7 * self.dfz) * LRES\n        pressure_load_factor = align.QDZ8 + align.QDZ9 * self.dfz\n        pressure_factor = pressure_load_factor * (1 + align.PPZ2 * self.dpi)\n        camber_load_sensivitity = align.QDZ10 + align.QDZ11 * self.dfz\n        camber_sensitivity = camber_load_sensivitity * abs(self.gamma)\n        camber_factor = load_factor + (pressure_factor + camber_sensitivity)\n        camber_influence = camber_factor * self.gamma * LKZC * self.lmuy_star\n        direction = sign(self.tyre.Vc.x)\n        return self.Fz * self.R0 * camber_influence * direction * self.cos_a\n\n    @property  # (4.E50)\n    def Fx(self) -&gt; float:  # noqa: S100\n        return self.Gxa * self.Fx0\n\n    @property  # (4.E51)\n    def Gxa(self) -&gt; float:  # noqa: S100\n        magic_factor = self.magic_formula_cosine(\n            self.Bxa, self.Cxa, 1, self.Exa, self.alpha_s\n        )\n        return magic_factor / self.Gxa0\n\n    @property  # (4.E52)\n    def Gxa0(self) -&gt; float:  # noqa: S100\n        return self.magic_formula_cosine(\n            self.Bxa, self.Cxa, 1, self.Exa, self.SHxa\n        )\n\n    @property  # (4.E53)\n    def alpha_s(self) -&gt; float:\n        return self.alpha + self.SHxa\n\n    @property  # (4.E54)\n    def Bxa(self) -&gt; float:  # noqa: S100\n        RBX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.RBX1\n        RBX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.RBX2\n        RBX3 = self.parameters.LONGITUDINAL_COEFFICIENTS.RBX3\n        LXAL = self.parameters.SCALING_COEFFICIENTS.LXAL\n        camber_factor = RBX1 + RBX3 * self.gamma**2\n        slip_factor = cos(atan(RBX2 * self.kappa))\n        return camber_factor * slip_factor * LXAL\n\n    @property  # (4.E55)\n    def Cxa(self) -&gt; float:  # noqa: S100\n        return self.parameters.LONGITUDINAL_COEFFICIENTS.RCX1\n\n    @property  # (4.E56)\n    def Exa(self) -&gt; float:  # noqa: S100\n        REX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.REX1\n        REX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.REX2\n        return REX1 + REX2 * self.dfz\n\n    @property  # (4.E57)\n    def SHxa(self) -&gt; float:  # noqa: S100\n        return self.parameters.LONGITUDINAL_COEFFICIENTS.RHX1\n\n    @property  # (4.E58)\n    def Fy(self) -&gt; float:  # noqa: S100\n        return self.Gyk * self.Fy0 + self.SVyk\n\n    @property  # (4.E59)\n    def Gyk(self) -&gt; float:  # noqa: S100\n        magic_factor = self.magic_formula_cosine(\n            self.Byk, self.Cyk, 1, self.Eyk, self.k_s\n        )\n        return magic_factor / self.Gyk0\n\n    @property  # (4.E60)\n    def Gyk0(self) -&gt; float:  # noqa: S100\n        return self.magic_formula_cosine(\n            self.Byk, self.Cyk, 1, self.Eyk, self.SHyk\n        )\n\n    @property  # (4.E61)\n    def k_s(self) -&gt; float:\n        return self.kappa + self.SHyk\n\n    @property  # (4.E62)\n    def Byk(self) -&gt; float:  # noqa: S100\n        RBY1 = self.parameters.LATERAL_COEFFICIENTS.RBY1\n        RBY2 = self.parameters.LATERAL_COEFFICIENTS.RBY2\n        RBY3 = self.parameters.LATERAL_COEFFICIENTS.RBY3\n        RBY4 = self.parameters.LATERAL_COEFFICIENTS.RBY4\n        LYKA = self.parameters.SCALING_COEFFICIENTS.LYKA\n        camber_factor = RBY1 + RBY4 * self.gamma**2\n        slip_factor = cos(atan(RBY2 * (self.alpha - RBY3)))\n        return camber_factor * slip_factor * LYKA\n\n    @property  # (4.E63)\n    def Cyk(self) -&gt; float:  # noqa: S100\n        return self.parameters.LATERAL_COEFFICIENTS.RCY1\n\n    @property  # (4.E64)\n    def Eyk(self) -&gt; float:  # noqa: S100\n        REY1 = self.parameters.LATERAL_COEFFICIENTS.REY1\n        REY2 = self.parameters.LATERAL_COEFFICIENTS.REY2\n        return REY1 + REY2 * self.dfz\n\n    @property  # (4.E65)\n    def SHyk(self) -&gt; float:  # noqa: S100\n        RHY1 = self.parameters.LATERAL_COEFFICIENTS.RHY1\n        RHY2 = self.parameters.LATERAL_COEFFICIENTS.RHY2\n        return RHY1 + RHY2 * self.dfz\n\n    @property  # (4.E66)\n    def SVyk(self) -&gt; float:  # noqa: S100\n        RVY5 = self.parameters.LATERAL_COEFFICIENTS.RVY5\n        RVY6 = self.parameters.LATERAL_COEFFICIENTS.RVY6\n        LVYKA = self.parameters.SCALING_COEFFICIENTS.LVYKA\n        return self.DVyk * sin(RVY5 * atan(RVY6 * self.kappa)) * LVYKA\n\n    @property  # (4.E67)\n    def DVyk(self) -&gt; float:  # noqa: S100\n        RVY1 = self.parameters.LATERAL_COEFFICIENTS.RVY1\n        RVY2 = self.parameters.LATERAL_COEFFICIENTS.RVY2\n        RVY3 = self.parameters.LATERAL_COEFFICIENTS.RVY3\n        RVY4 = self.parameters.LATERAL_COEFFICIENTS.RVY4\n        load_factor = RVY1 + RVY2 * self.dfz + RVY3 * self.gamma\n        slip_factor = cos(atan(RVY4 * self.alpha))\n        return self.muy * self.Fz * load_factor * slip_factor\n\n    @property  # (4.E69)\n    def Mx(self) -&gt; float:  # noqa: S100\n        q = self.parameters.OVERTURNING_COEFFICIENTS\n        LVMX = self.parameters.SCALING_COEFFICIENTS.LVMX\n        LMX = self.parameters.SCALING_COEFFICIENTS.LMX\n        load_ratio = self.Fz / self.parameters.VERTICAL.FNOMIN\n\n        offset = q.QSX1 * LVMX\n        pressure_term = q.QSX2 * self.gamma * (1 + q.PPMX1 * self.dpi)\n        load_term = q.QSX3 * load_ratio\n        cosine_factor = cos(q.QSX5 * atan(q.QSX6 * load_ratio) ** 2)\n        arctan_factor = atan(q.QSX9 * load_ratio)\n        sine_factor = sin(q.QSX7 * self.gamma + q.QSX8 * arctan_factor)\n        trig_term = q.QSX4 * cosine_factor * sine_factor\n        camber_term = q.QSX10 * atan(q.QSX11 * load_ratio) * self.gamma\n        terms = offset - pressure_term + load_term + trig_term + camber_term\n        return self.Fz * self.R0 * terms * LMX\n\n    @property  # (4.E70)\n    def My(self) -&gt; float:  # noqa: S100\n        q = self.parameters.ROLLING_COEFFICIENTS\n        nominal_load = self.parameters.VERTICAL.FNOMIN\n        v_ratio = self.tyre.Vx / self.parameters.MODEL.LONGVL\n        force_ratio = self.Fz / nominal_load\n        LMY = self.parameters.SCALING_COEFFICIENTS.LMY\n\n        longitudinal_term = q.QSY2 * self.Fx / nominal_load\n        velocity_term = q.QSY3 * abs(v_ratio) + q.QSY4 * v_ratio**4\n        camber_term = (q.QSY5 + q.QSY6 * force_ratio) * (self.tyre.gamma**2)\n        factor_a = q.QSY1 + longitudinal_term + velocity_term + camber_term\n        factor_b = pow(force_ratio, q.QSY7) * pow(self.pressure_ratio, q.QSY8)\n        return self.Fz * self.R0 * factor_a * factor_b * LMY\n\n    @property  # (4.E71)\n    def Mz(self) -&gt; float:  # noqa: S100\n        return self.Mz_prime + self.Mzr + self.s * self.Fx\n\n    @property  # (4.E72)\n    def Mz_prime(self) -&gt; float:  # noqa: S100\n        return -self.t * self.Fy_prime\n\n    @property  # (4.E73)\n    def t(self) -&gt; float:\n        magic_factor = self.magic_formula_cosine(\n            self.Bt, self.Ct, self.Dt, self.Et, self.a_teq\n        )\n        return magic_factor * self.cos_a\n\n    @property  # (4.E74)\n    def Fy_prime(self) -&gt; float:  # noqa: S100\n        return self.Gyk * self.Fy0\n\n    @property  # (4.E75)\n    def Mzr(self) -&gt; float:  # noqa: S100\n        magic_factor = self.magic_formula_cosine(\n            self.Br, self.Cr, self.Dr, 0, self.a_req\n        )\n        return magic_factor * self.cos_a\n\n    @property  # (4.E76)\n    def s(self) -&gt; float:\n        SSZ1 = self.parameters.ALIGNING_COEFFICIENTS.SSZ1\n        SSZ2 = self.parameters.ALIGNING_COEFFICIENTS.SSZ2\n        SSZ3 = self.parameters.ALIGNING_COEFFICIENTS.SSZ3\n        SSZ4 = self.parameters.ALIGNING_COEFFICIENTS.SSZ4\n        LS = self.parameters.SCALING_COEFFICIENTS.LS\n        load_factor = SSZ2 * self.Fy / self.Fz0_prime\n        camber_factor = (SSZ3 + SSZ4 * self.dfz) * self.gamma\n        return self.R0 * (SSZ1 + load_factor + camber_factor) * LS\n\n    @property  # Helper function for (4.E77) and (4.E78)\n    def _stiffness_factor(self) -&gt; float:\n        return self.kappa * self.Kxk / (self.Kya + EPSILON)\n\n    @property  # (4.E77)\n    def a_teq(self) -&gt; float:\n        return sqrt(self.a_t**2 + self._stiffness_factor**2) * sign(self.a_t)\n\n    @property  # (4.E78)\n    def a_req(self) -&gt; float:\n        return sqrt(self.a_r**2 + self._stiffness_factor**2) * sign(self.a_r)\n\n    @staticmethod\n    def magic_formula(\n        B: float, C: float, D: float, E: float, x: float, SV: float\n    ) -&gt; float:\n        \"\"\"\n        Implements the Pacejka Magic Formula.\n\n        Calculates longitudinal force Fx,\n        lateral force Fy, or aligning moment Mz.\n\n        Args:\n            B (float): Stiffness factor.\n            C (float): Shape factor.\n            D (float): Peak value.\n            E (float): Curvature factor.\n            x (float): Input variable (kappa, alpha, or gamma),\n                plus horizontal shift.\n            SV (float): Vertical shift.\n\n        Returns:\n            Y (float): Output variable (either Fx, Fy, or Mz).\n        \"\"\"\n        Bx = B * x\n        return D * sin(C * atan(Bx - E * (Bx - atan(Bx)))) + SV\n\n    @staticmethod\n    def magic_formula_cosine(\n        B: float, C: float, D: float, E: float, x: float\n    ) -&gt; float:\n        \"\"\"\n        Implements the cosine version of the Pacejka Magic Formula.\n\n        Args:\n            B (float): Stiffness factor.\n            C (float): Shape factor.\n            D (float): Peak value.\n            E (float): Curvature factor.\n            x (float): Input variable (kappa, alpha, or gamma),\n                plus horizontal shift.\n\n        Returns:\n            Y (float): Output variable.\n        \"\"\"\n        Bx = B * x\n        return D * cos(C * atan(Bx - E * (Bx - atan(Bx))))\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/magic_formula/#usmlap.vehicle.tyre.magic_formula.MagicFormula.magic_formula","title":"<code>magic_formula(B, C, D, E, x, SV)</code>  <code>staticmethod</code>","text":"<p>Implements the Pacejka Magic Formula.</p> <p>Calculates longitudinal force Fx, lateral force Fy, or aligning moment Mz.</p> <p>Parameters:</p> Name Type Description Default <code>B</code> <code>float</code> <p>Stiffness factor.</p> required <code>C</code> <code>float</code> <p>Shape factor.</p> required <code>D</code> <code>float</code> <p>Peak value.</p> required <code>E</code> <code>float</code> <p>Curvature factor.</p> required <code>x</code> <code>float</code> <p>Input variable (kappa, alpha, or gamma), plus horizontal shift.</p> required <code>SV</code> <code>float</code> <p>Vertical shift.</p> required <p>Returns:</p> Name Type Description <code>Y</code> <code>float</code> <p>Output variable (either Fx, Fy, or Mz).</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\magic_formula.py</code> <pre><code>@staticmethod\ndef magic_formula(\n    B: float, C: float, D: float, E: float, x: float, SV: float\n) -&gt; float:\n    \"\"\"\n    Implements the Pacejka Magic Formula.\n\n    Calculates longitudinal force Fx,\n    lateral force Fy, or aligning moment Mz.\n\n    Args:\n        B (float): Stiffness factor.\n        C (float): Shape factor.\n        D (float): Peak value.\n        E (float): Curvature factor.\n        x (float): Input variable (kappa, alpha, or gamma),\n            plus horizontal shift.\n        SV (float): Vertical shift.\n\n    Returns:\n        Y (float): Output variable (either Fx, Fy, or Mz).\n    \"\"\"\n    Bx = B * x\n    return D * sin(C * atan(Bx - E * (Bx - atan(Bx)))) + SV\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/magic_formula/#usmlap.vehicle.tyre.magic_formula.MagicFormula.magic_formula_cosine","title":"<code>magic_formula_cosine(B, C, D, E, x)</code>  <code>staticmethod</code>","text":"<p>Implements the cosine version of the Pacejka Magic Formula.</p> <p>Parameters:</p> Name Type Description Default <code>B</code> <code>float</code> <p>Stiffness factor.</p> required <code>C</code> <code>float</code> <p>Shape factor.</p> required <code>D</code> <code>float</code> <p>Peak value.</p> required <code>E</code> <code>float</code> <p>Curvature factor.</p> required <code>x</code> <code>float</code> <p>Input variable (kappa, alpha, or gamma), plus horizontal shift.</p> required <p>Returns:</p> Name Type Description <code>Y</code> <code>float</code> <p>Output variable.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\magic_formula.py</code> <pre><code>@staticmethod\ndef magic_formula_cosine(\n    B: float, C: float, D: float, E: float, x: float\n) -&gt; float:\n    \"\"\"\n    Implements the cosine version of the Pacejka Magic Formula.\n\n    Args:\n        B (float): Stiffness factor.\n        C (float): Shape factor.\n        D (float): Peak value.\n        E (float): Curvature factor.\n        x (float): Input variable (kappa, alpha, or gamma),\n            plus horizontal shift.\n\n    Returns:\n        Y (float): Output variable.\n    \"\"\"\n    Bx = B * x\n    return D * cos(C * atan(Bx - E * (Bx - atan(Bx))))\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/magic_formula/#usmlap.vehicle.tyre.magic_formula.TyreAttitude","title":"<code>TyreAttitude</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters describing the attitude of a tyre.</p> <p>Attributes:</p> Name Type Description <code>Vx</code> <code>float</code> <p>Longitudinal velocity of wheel centre.</p> <code>Vc</code> <code>Coordinate</code> <p>Velocity of the wheel contact patch.</p> <code>Vs</code> <code>Coordinate</code> <p>Slip velocity.</p> <code>fz</code> <code>float</code> <p>Normal load on the tyre.</p> <code>omega</code> <code>float</code> <p>Wheel speed of revolution.</p> <code>kappa</code> <code>float</code> <p>Longitudinal slip.</p> <code>alpha</code> <code>float</code> <p>Side slip angle.</p> <code>gamma</code> <code>float</code> <p>Camber angle.</p> <code>pressure</code> <code>float</code> <p>Inflation pressure.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\magic_formula.py</code> <pre><code>class TyreAttitude(BaseModel):\n    \"\"\"\n    Parameters describing the attitude of a tyre.\n\n    Attributes:\n        Vx:\n            Longitudinal velocity of wheel centre.\n        Vc:\n            Velocity of the wheel contact patch.\n        Vs:\n            Slip velocity.\n        fz:\n            Normal load on the tyre.\n        omega:\n            Wheel speed of revolution.\n        kappa:\n            Longitudinal slip.\n        alpha:\n            Side slip angle.\n        gamma:\n            Camber angle.\n        pressure:\n            Inflation pressure.\n    \"\"\"\n\n    Vx: float\n    Vc: Coordinate\n    Vs: Coordinate\n    fz: float\n    omega: float\n    kappa: float\n    alpha: float\n    gamma: float\n    pressure: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/","title":"tir","text":"<p>This module provides support for reading tyre data from .TIR files.</p> <p>The .TIR file format specifies a wide range of tyre parameters which can be used in the Pacejka Magic Formula.</p> <p>Documentation for the .TIR file format is available at https://functionbay.com/documentation/onlinehelp/Documents/Tire/MFTyre-MFSwift_Help.pdf, in section 5.3.</p>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.AligningCoefficients","title":"<code>AligningCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for evaluating self-aligning moment, Mz.</p> <p>Attributes:</p> Name Type Description <code>QBZ1</code> <code>float</code> <p>Trail slope factor for trail Bpt at Fznom.</p> <code>QBZ2</code> <code>float</code> <p>Variation of slope Bpt with load.</p> <code>QBZ3</code> <code>float</code> <p>Variation of slope Bpt with load squared.</p> <code>QBZ4</code> <code>float</code> <p>Variation of slope Bpt with camber.</p> <code>QBZ5</code> <code>float</code> <p>Variation of slope Bpt with absolute camber.</p> <code>QBZ6</code> <code>float</code> <p>Variation of slope Bpt with camber squared.</p> <code>QBZ9</code> <code>float</code> <p>Slope factor Br of residual torque Mzr.</p> <code>QBZ10</code> <code>float</code> <p>Slope factor Br of residual torque Mzr.</p> <code>QCZ1</code> <code>float</code> <p>Shape factor Cpt for pneumatic trail.</p> <code>QDZ1</code> <code>float</code> <p>Peak trail Dpt = Dpt(Fz/FznomR0).</p> <code>QDZ2</code> <code>float</code> <p>Variation of peak Dpt with load.</p> <code>QDZ3</code> <code>float</code> <p>Variation of peak Dpt with camber.</p> <code>QDZ4</code> <code>float</code> <p>Variation of peak Dpt with camber squared.</p> <code>QDZ6</code> <code>float</code> <p>Peak residual torque Dmr = Dmr/(Fz*R0).</p> <code>QDZ7</code> <code>float</code> <p>Variation of peak factor Dmr with load.</p> <code>QDZ8</code> <code>float</code> <p>Variation of peak factor Dmr with camber.</p> <code>QDZ9</code> <code>float</code> <p>Variation of peak factor Dmr with camber and load.</p> <code>QDZ10</code> <code>float</code> <p>Variation of peak factor Dmr with camber squared.</p> <code>QDZ11</code> <code>float</code> <p>Variation of Dmr with camber squared and load.</p> <code>QEZ1</code> <code>float</code> <p>Trail curvature Ept at Fznom.</p> <code>QEZ2</code> <code>float</code> <p>Variation of curvature Ept with load.</p> <code>QEZ3</code> <code>float</code> <p>Variation of curvature Ept with load squared.</p> <code>QEZ4</code> <code>float</code> <p>Variation of curvature Ept with sign of Alpha-t.</p> <code>QEZ5</code> <code>float</code> <p>Variation of Ept with camber and sign Alpha-t.</p> <code>QHZ1</code> <code>float</code> <p>Trail horizontal shift Sht at Fznom.</p> <code>QHZ2</code> <code>float</code> <p>Variation of shift Sht with load.</p> <code>QHZ3</code> <code>float</code> <p>Variation of shift Sht with camber.</p> <code>QHZ4</code> <code>float</code> <p>Variation of shift Sht with camber and load.</p> <code>SSZ1</code> <code>float</code> <p>Nominal value of s/R0:  of Fx on Mz.</p> <code>SSZ2</code> <code>float</code> <p>Variation of distance s/R0 with Fy/Fznom.</p> <code>SSZ3</code> <code>float</code> <p>Variation of distance s/R0 with camber.</p> <code>SSZ4</code> <code>float</code> <p>Variation of distance s/R0 with load and camber.</p> <code>PPZ1</code> <code>float</code> <p>Linear pressure effect on pneumatic trail.</p> <code>PPZ2</code> <code>float</code> <p>Influence of inflation pressure on residual aligning torque.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class AligningCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for evaluating self-aligning moment, Mz.\n\n    Attributes:\n        QBZ1 (float): Trail slope factor for trail Bpt at Fznom.\n        QBZ2 (float): Variation of slope Bpt with load.\n        QBZ3 (float): Variation of slope Bpt with load squared.\n        QBZ4 (float): Variation of slope Bpt with camber.\n        QBZ5 (float): Variation of slope Bpt with absolute camber.\n        QBZ6 (float): Variation of slope Bpt with camber squared.\n        QBZ9 (float): Slope factor Br of residual torque Mzr.\n        QBZ10 (float): Slope factor Br of residual torque Mzr.\n        QCZ1 (float): Shape factor Cpt for pneumatic trail.\n        QDZ1 (float): Peak trail Dpt = Dpt*(Fz/Fznom*R0).\n        QDZ2 (float): Variation of peak Dpt with load.\n        QDZ3 (float): Variation of peak Dpt with camber.\n        QDZ4 (float): Variation of peak Dpt with camber squared.\n        QDZ6 (float): Peak residual torque Dmr = Dmr/(Fz*R0).\n        QDZ7 (float): Variation of peak factor Dmr with load.\n        QDZ8 (float): Variation of peak factor Dmr with camber.\n        QDZ9 (float): Variation of peak factor Dmr with camber and load.\n        QDZ10 (float): Variation of peak factor Dmr with camber squared.\n        QDZ11 (float): Variation of Dmr with camber squared and load.\n        QEZ1 (float): Trail curvature Ept at Fznom.\n        QEZ2 (float): Variation of curvature Ept with load.\n        QEZ3 (float): Variation of curvature Ept with load squared.\n        QEZ4 (float): Variation of curvature Ept with sign of Alpha-t.\n        QEZ5 (float): Variation of Ept with camber and sign Alpha-t.\n        QHZ1 (float): Trail horizontal shift Sht at Fznom.\n        QHZ2 (float): Variation of shift Sht with load.\n        QHZ3 (float): Variation of shift Sht with camber.\n        QHZ4 (float): Variation of shift Sht with camber and load.\n        SSZ1 (float): Nominal value of s/R0:  of Fx on Mz.\n        SSZ2 (float): Variation of distance s/R0 with Fy/Fznom.\n        SSZ3 (float): Variation of distance s/R0 with camber.\n        SSZ4 (float): Variation of distance s/R0 with load and camber.\n        PPZ1 (float): Linear pressure effect on pneumatic trail.\n        PPZ2 (float): Influence of inflation pressure on residual aligning torque.\n    \"\"\"\n\n    QBZ1: float\n    QBZ2: float\n    QBZ3: float\n    QBZ4: float\n    QBZ5: float\n    QBZ6: float\n    QBZ9: float\n    QBZ10: float\n    QCZ1: float\n    QDZ1: float\n    QDZ2: float\n    QDZ3: float\n    QDZ4: float\n    QDZ6: float\n    QDZ7: float\n    QDZ8: float\n    QDZ9: float\n    QDZ10: float\n    QDZ11: float\n    QEZ1: float\n    QEZ2: float\n    QEZ3: float\n    QEZ4: float\n    QEZ5: float\n    QHZ1: float\n    QHZ2: float\n    QHZ3: float\n    QHZ4: float\n    SSZ1: float\n    SSZ2: float\n    SSZ3: float\n    SSZ4: float\n    PPZ1: float\n    PPZ2: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.ContactPatch","title":"<code>ContactPatch</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Contact length and obstacle enveloping parameters.</p> <p>Attributes:</p> Name Type Description <code>Q_RA1</code> <code>Optional[float]</code> <p>Square root term in contact length equation.</p> <code>Q_RA2</code> <code>Optional[float]</code> <p>Linear term in contact length equation.</p> <code>Q_RB1</code> <code>Optional[float]</code> <p>Root term in contact width equation.</p> <code>Q_RB2</code> <code>Optional[float]</code> <p>Linear term in contact width equation.</p> <code>ELLIPS_SHIFT</code> <code>Optional[float]</code> <p>Scaling of distance between front and rear ellipsoid.</p> <code>ELLIPS_LENGTH</code> <code>Optional[float]</code> <p>Semimajor axis of ellipsoid.</p> <code>ELLIPS_HEIGHT</code> <code>Optional[float]</code> <p>Semiminor axis of ellipsoid.</p> <code>ELLIPS_ORDER</code> <code>Optional[float]</code> <p>Order of ellipsoid.</p> <code>ELLIPS_MAX_STEP</code> <code>Optional[float]</code> <p>Maximum height of road step.</p> <code>ELLIPS_NWIDTH</code> <code>Optional[float]</code> <p>Number of parallel ellipsoids.</p> <code>ELLIPS_NLENGTH</code> <code>Optional[float]</code> <p>Number of ellipsoids at sides of contact patch.</p> <code>ENV_C1</code> <code>Optional[float]</code> <p>Effective height attenuation.</p> <code>ENV_C2</code> <code>Optional[float]</code> <p>Effective plane angle attenuation.</p> <code>Q_A2</code> <code>Optional[float]</code> <p>Linear load term in contact length.</p> <code>Q_A1</code> <code>Optional[float]</code> <p>Square root load term in contact length.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class ContactPatch(_ParameterGroup):\n    \"\"\"\n    Contact length and obstacle enveloping parameters.\n\n    Attributes:\n        Q_RA1 (Optional[float]): Square root term in contact length equation.\n        Q_RA2 (Optional[float]): Linear term in contact length equation.\n        Q_RB1 (Optional[float]): Root term in contact width equation.\n        Q_RB2 (Optional[float]): Linear term in contact width equation.\n        ELLIPS_SHIFT (Optional[float]):\n            Scaling of distance between front and rear ellipsoid.\n        ELLIPS_LENGTH (Optional[float]): Semimajor axis of ellipsoid.\n        ELLIPS_HEIGHT (Optional[float]): Semiminor axis of ellipsoid.\n        ELLIPS_ORDER (Optional[float]): Order of ellipsoid.\n        ELLIPS_MAX_STEP (Optional[float]): Maximum height of road step.\n        ELLIPS_NWIDTH (Optional[float]): Number of parallel ellipsoids.\n        ELLIPS_NLENGTH (Optional[float]):\n            Number of ellipsoids at sides of contact patch.\n        ENV_C1 (Optional[float]): Effective height attenuation.\n        ENV_C2 (Optional[float]): Effective plane angle attenuation.\n        Q_A2 (Optional[float]): Linear load term in contact length.\n        Q_A1 (Optional[float]): Square root load term in contact length.\n    \"\"\"\n\n    Q_RA1: Optional[float] = None\n    Q_RA2: Optional[float] = None\n    Q_RB1: Optional[float] = None\n    Q_RB2: Optional[float] = None\n    ELLIPS_SHIFT: Optional[float] = None\n    ELLIPS_LENGTH: Optional[float] = None\n    ELLIPS_HEIGHT: Optional[float] = None\n    ELLIPS_ORDER: Optional[float] = None\n    ELLIPS_MAX_STEP: Optional[float] = None\n    ELLIPS_NWIDTH: Optional[float] = None\n    ELLIPS_NLENGTH: Optional[float] = None\n    ENV_C1: Optional[float] = None\n    ENV_C2: Optional[float] = None\n    Q_A2: Optional[float] = None\n    Q_A1: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Dimension","title":"<code>Dimension</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Tyre dimensions.</p> <p>Attributes:</p> Name Type Description <code>UNLOADED_RADIUS</code> <code>float</code> <p>Free tyre radius.</p> <code>WIDTH</code> <code>Optional[float]</code> <p>Nominal section width of the tyre.</p> <code>RIM_RADIUS</code> <code>Optional[float]</code> <p>Nominal rim radius.</p> <code>RIM_WIDTH</code> <code>Optional[float]</code> <p>Rim width.</p> <code>ASPECT_RATIO</code> <code>Optional[float]</code> <p>Nominal aspect ratio.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Dimension(_ParameterGroup):\n    \"\"\"\n    Tyre dimensions.\n\n    Attributes:\n        UNLOADED_RADIUS (float): Free tyre radius.\n        WIDTH (Optional[float]): Nominal section width of the tyre.\n        RIM_RADIUS (Optional[float]): Nominal rim radius.\n        RIM_WIDTH (Optional[float]): Rim width.\n        ASPECT_RATIO (Optional[float]): Nominal aspect ratio.\n    \"\"\"\n\n    UNLOADED_RADIUS: float\n    WIDTH: Optional[float] = None\n    RIM_RADIUS: Optional[float] = None\n    RIM_WIDTH: Optional[float] = None\n    ASPECT_RATIO: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.InclinationAngleRange","title":"<code>InclinationAngleRange</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Minimum and maximum valid inclination angles.</p> <p>Attributes:</p> Name Type Description <code>CAMMIN</code> <code>Optional[float]</code> <p>Minimum valid camber angle.</p> <code>CAMMAX</code> <code>Optional[float]</code> <p>Maximum valid camber angle.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class InclinationAngleRange(_ParameterGroup):\n    \"\"\"\n    Minimum and maximum valid inclination angles.\n\n    Attributes:\n        CAMMIN (Optional[float]): Minimum valid camber angle.\n        CAMMAX (Optional[float]): Maximum valid camber angle.\n    \"\"\"\n\n    CAMMIN: Optional[float] = None\n    CAMMAX: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Inertia","title":"<code>Inertia</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Mass and inertia properties of the tyre and tyre belt.</p> <p>Attributes:</p> Name Type Description <code>MASS</code> <code>Optional[float]</code> <p>Tyre mass.</p> <code>IXX</code> <code>Optional[float]</code> <p>Tyre diametral moment of inertia.</p> <code>IYY</code> <code>Optional[float]</code> <p>Tyre polar moment of inertia.</p> <code>BELT_MASS</code> <code>Optional[float]</code> <p>Belt mass.</p> <code>BELT_IXX</code> <code>Optional[float]</code> <p>Belt diametral moment of inertia.</p> <code>BELT_IYY</code> <code>Optional[float]</code> <p>Belt polar moment of inertia.</p> <code>GRAVITY</code> <code>Optional[float]</code> <p>Gravity acting on belt in Z direction.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Inertia(_ParameterGroup):\n    \"\"\"\n    Mass and inertia properties of the tyre and tyre belt.\n\n    Attributes:\n        MASS (Optional[float]): Tyre mass.\n        IXX (Optional[float]): Tyre diametral moment of inertia.\n        IYY (Optional[float]): Tyre polar moment of inertia.\n        BELT_MASS (Optional[float]): Belt mass.\n        BELT_IXX (Optional[float]): Belt diametral moment of inertia.\n        BELT_IYY (Optional[float]): Belt polar moment of inertia.\n        GRAVITY (Optional[float]): Gravity acting on belt in Z direction.\n    \"\"\"\n\n    MASS: Optional[float] = None\n    IXX: Optional[float] = None\n    IYY: Optional[float] = None\n    BELT_MASS: Optional[float] = None\n    BELT_IXX: Optional[float] = None\n    BELT_IYY: Optional[float] = None\n    GRAVITY: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.InflationPressureRange","title":"<code>InflationPressureRange</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Minimum and maximum allowed inflation pressures.</p> <p>Attributes:</p> Name Type Description <code>PRESMIN</code> <code>Optional[float]</code> <p>Minimum allowed inflation pressure.</p> <code>PRESMAX</code> <code>Optional[float]</code> <p>Maximum allowed inflation pressure.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class InflationPressureRange(_ParameterGroup):\n    \"\"\"\n    Minimum and maximum allowed inflation pressures.\n\n    Attributes:\n        PRESMIN (Optional[float]): Minimum allowed inflation pressure.\n        PRESMAX (Optional[float]): Maximum allowed inflation pressure.\n    \"\"\"\n\n    PRESMIN: Optional[float] = None\n    PRESMAX: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.LateralCoefficients","title":"<code>LateralCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for evaluating lateral force, Fy.</p> <p>Attributes:</p> Name Type Description <code>PCY1</code> <code>float</code> <p>Shape factor Cfy for lateral forces.</p> <code>PDY1</code> <code>float</code> <p>Lateral friction Muy.</p> <code>PDY2</code> <code>float</code> <p>Variation of friction Muy with load.</p> <code>PDY3</code> <code>float</code> <p>Variation of friction Muy with squared camber.</p> <code>PEY1</code> <code>float</code> <p>Lateral curvature Efy at Fznom.</p> <code>PEY2</code> <code>float</code> <p>Variation of curvature Efy with load.</p> <code>PEY3</code> <code>float</code> <p>Zero order camber dependency of curvature Efy.</p> <code>PEY4</code> <code>float</code> <p>Variation of curvature Efy with camber.</p> <code>PEY5</code> <code>float</code> <p>Camber curvature Efc.</p> <code>PKY1</code> <code>float</code> <p>Maximum value of stiffness Kfy/Fznom.</p> <code>PKY2</code> <code>float</code> <p>Load at which Kfy reaches maximum value.</p> <code>PKY3</code> <code>float</code> <p>Variation of Kfy/Fznom with camber.</p> <code>PKY4</code> <code>float</code> <p>Curvature of stiffness Kfy.</p> <code>PKY5</code> <code>float</code> <p>Peak stiffness variation with camber squared.</p> <code>PKY6</code> <code>float</code> <p>Camber stiffness factor.</p> <code>PKY7</code> <code>float</code> <p>Load dependency of camber stiffness factor.</p> <code>PHY1</code> <code>float</code> <p>Horizontal shift Shy at Fznom.</p> <code>PHY2</code> <code>float</code> <p>Variation of shift Shy with load.</p> <code>PVY1</code> <code>float</code> <p>Vertical shift in Svy/Fz at Fznom.</p> <code>PVY2</code> <code>float</code> <p>Variation of shift Svy/Fz with load.</p> <code>PVY3</code> <code>float</code> <p>Variation of shift Svy/Fz with camber.</p> <code>PVY4</code> <code>float</code> <p>Variation of shift Svy/Fz with camber and load.</p> <code>RBY1</code> <code>float</code> <p>Slope factor for combined Fy reduction.</p> <code>RBY2</code> <code>float</code> <p>Variation of slope Fy reduction with alpha.</p> <code>RBY3</code> <code>float</code> <p>Shift term for alpha in slope Fy reduction.</p> <code>RBY4</code> <code>float</code> <p>Influence of camber on stiffness of Fy combined.</p> <code>RCY1</code> <code>float</code> <p>Shape factor for combined Fy reduction.</p> <code>REY1</code> <code>float</code> <p>Curvature factor of combined Fy.</p> <code>REY2</code> <code>float</code> <p>Curvature factor of combined Fy with load.</p> <code>RHY1</code> <code>float</code> <p>Shift factor for combined Fy reduction.</p> <code>RHY2</code> <code>float</code> <p>Shift factor for combined Fy reduction with load.</p> <code>RVY1</code> <code>float</code> <p>Kappa induced side force Svyk/Muy*Fz at Fznom.</p> <code>RVY2</code> <code>float</code> <p>Variation of Svyk/Muy*Fz with load.</p> <code>RVY3</code> <code>float</code> <p>Variation of Svyk/Muy*Fz with camber.</p> <code>RVY4</code> <code>float</code> <p>Variation of Svyk/Muy*Fz with alpha.</p> <code>RVY5</code> <code>float</code> <p>Variation of Svyk/Muy*Fz with kappa.</p> <code>RVY6</code> <code>float</code> <p>Variation of Svyk/Muy*Fz with atan(kappa).</p> <code>PPY1</code> <code>float</code> <p>Pressure effect on cornering stiffness magnitude.</p> <code>PPY2</code> <code>float</code> <p>Pressure effect on location of cornering stiffness peak.</p> <code>PPY3</code> <code>float</code> <p>Linear pressure effect on lateral friction.</p> <code>PPY4</code> <code>float</code> <p>Quadratic pressure effect on lateral friction.</p> <code>PPY5</code> <code>float</code> <p>Influence of inflation pressure on camber stiffness.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class LateralCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for evaluating lateral force, Fy.\n\n    Attributes:\n        PCY1 (float): Shape factor Cfy for lateral forces.\n        PDY1 (float): Lateral friction Muy.\n        PDY2 (float): Variation of friction Muy with load.\n        PDY3 (float): Variation of friction Muy with squared camber.\n        PEY1 (float): Lateral curvature Efy at Fznom.\n        PEY2 (float): Variation of curvature Efy with load.\n        PEY3 (float): Zero order camber dependency of curvature Efy.\n        PEY4 (float): Variation of curvature Efy with camber.\n        PEY5 (float): Camber curvature Efc.\n        PKY1 (float): Maximum value of stiffness Kfy/Fznom.\n        PKY2 (float): Load at which Kfy reaches maximum value.\n        PKY3 (float): Variation of Kfy/Fznom with camber.\n        PKY4 (float): Curvature of stiffness Kfy.\n        PKY5 (float): Peak stiffness variation with camber squared.\n        PKY6 (float): Camber stiffness factor.\n        PKY7 (float): Load dependency of camber stiffness factor.\n        PHY1 (float): Horizontal shift Shy at Fznom.\n        PHY2 (float): Variation of shift Shy with load.\n        PVY1 (float): Vertical shift in Svy/Fz at Fznom.\n        PVY2 (float): Variation of shift Svy/Fz with load.\n        PVY3 (float): Variation of shift Svy/Fz with camber.\n        PVY4 (float): Variation of shift Svy/Fz with camber and load.\n        RBY1 (float): Slope factor for combined Fy reduction.\n        RBY2 (float): Variation of slope Fy reduction with alpha.\n        RBY3 (float): Shift term for alpha in slope Fy reduction.\n        RBY4 (float): Influence of camber on stiffness of Fy combined.\n        RCY1 (float): Shape factor for combined Fy reduction.\n        REY1 (float): Curvature factor of combined Fy.\n        REY2 (float): Curvature factor of combined Fy with load.\n        RHY1 (float): Shift factor for combined Fy reduction.\n        RHY2 (float): Shift factor for combined Fy reduction with load.\n        RVY1 (float): Kappa induced side force Svyk/Muy*Fz at Fznom.\n        RVY2 (float): Variation of Svyk/Muy*Fz with load.\n        RVY3 (float): Variation of Svyk/Muy*Fz with camber.\n        RVY4 (float): Variation of Svyk/Muy*Fz with alpha.\n        RVY5 (float): Variation of Svyk/Muy*Fz with kappa.\n        RVY6 (float): Variation of Svyk/Muy*Fz with atan(kappa).\n        PPY1 (float): Pressure effect on cornering stiffness magnitude.\n        PPY2 (float): Pressure effect on location of cornering stiffness peak.\n        PPY3 (float): Linear pressure effect on lateral friction.\n        PPY4 (float): Quadratic pressure effect on lateral friction.\n        PPY5 (float): Influence of inflation pressure on camber stiffness.\n    \"\"\"\n\n    PCY1: float\n    PDY1: float\n    PDY2: float\n    PDY3: float\n    PEY1: float\n    PEY2: float\n    PEY3: float\n    PEY4: float\n    PEY5: float\n    PKY1: float\n    PKY2: float\n    PKY3: float\n    PKY4: float\n    PKY5: float\n    PKY6: float\n    PKY7: float\n    PHY1: float\n    PHY2: float\n    PVY1: float\n    PVY2: float\n    PVY3: float\n    PVY4: float\n    RBY1: float\n    RBY2: float\n    RBY3: float\n    RBY4: float\n    RCY1: float\n    REY1: float\n    REY2: float\n    RHY1: float\n    RHY2: float\n    RVY1: float\n    RVY2: float\n    RVY3: float\n    RVY4: float\n    RVY5: float\n    RVY6: float\n    PPY1: float\n    PPY2: float\n    PPY3: float\n    PPY4: float\n    PPY5: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.LongSlipRange","title":"<code>LongSlipRange</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Minimum and maximum valid longitudinal slips.</p> <p>Attributes:</p> Name Type Description <code>KPUMIN</code> <code>Optional[float]</code> <p>Minimum valid wheel slip.</p> <code>KPUMAX</code> <code>Optional[float]</code> <p>Maximum valid wheel slip.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class LongSlipRange(_ParameterGroup):\n    \"\"\"\n    Minimum and maximum valid longitudinal slips.\n\n    Attributes:\n        KPUMIN (Optional[float]): Minimum valid wheel slip.\n        KPUMAX (Optional[float]): Maximum valid wheel slip.\n    \"\"\"\n\n    KPUMIN: Optional[float] = None\n    KPUMAX: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.LongitudinalCoefficients","title":"<code>LongitudinalCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for evaluating longitudinal force, Fx.</p> <p>Attributes:</p> Name Type Description <code>PCX1</code> <code>float</code> <p>Shape factor Cf for longitudinal force.</p> <code>PDX1</code> <code>float</code> <p>Longitudinal friction Mux at Fznom.</p> <code>PDX2</code> <code>float</code> <p>Variation of friction Mux with load.</p> <code>PDX3</code> <code>float</code> <p>Variation of friction Mux with camber.</p> <code>PEX1</code> <code>float</code> <p>Longitudinal curvature Ef at Fznom.</p> <code>PEX2</code> <code>float</code> <p>Variation of curvature Ef with load.</p> <code>PEX3</code> <code>float</code> <p>Variation of curvature Ef with load squared.</p> <code>PEX4</code> <code>float</code> <p>Factor in curvature Ef while driving.</p> <code>PKX1</code> <code>float</code> <p>Longitudinal slip stiffness Kf/Fz at Fznom.</p> <code>PKX2</code> <code>float</code> <p>Variation of slip stiffness Kf/Fz with load.</p> <code>PKX3</code> <code>float</code> <p>Exponent in slip stiffness Kf/Fz with load.</p> <code>PHX1</code> <code>float</code> <p>Horizontal shift Shx at Fznom.</p> <code>PHX2</code> <code>float</code> <p>Variation of shift Shx with load.</p> <code>PVX1</code> <code>float</code> <p>Vertical shift Sv/Fz at Fznom.</p> <code>PVX2</code> <code>float</code> <p>Variation of shift Sv/Fz with load.</p> <code>RBX1</code> <code>float</code> <p>Slope factor for combined slip Fx reduction.</p> <code>RBX2</code> <code>float</code> <p>Variation of slope Fx reduction with kappa.</p> <code>RBX3</code> <code>float</code> <p>Influence of camber on stiffness for Fx combined.</p> <code>RCX1</code> <code>float</code> <p>Shape factor for combined slip Fx reduction.</p> <code>REX1</code> <code>float</code> <p>Curvature factor of combined Fx.</p> <code>REX2</code> <code>float</code> <p>Curvature factor of combined Fx with load.</p> <code>RHX1</code> <code>float</code> <p>Shift factor for combined slip Fx reduction.</p> <code>PPX1</code> <code>float</code> <p>Linear pressure effect on slip stiffness.</p> <code>PPX2</code> <code>float</code> <p>Quadratic pressure effect on slip stiffness.</p> <code>PPX3</code> <code>float</code> <p>Linear pressure effect on longitudinal friction.</p> <code>PPX4</code> <code>float</code> <p>Quadratic pressure effect on longitudinal friction.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class LongitudinalCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for evaluating longitudinal force, Fx.\n\n    Attributes:\n        PCX1 (float): Shape factor Cf for longitudinal force.\n        PDX1 (float): Longitudinal friction Mux at Fznom.\n        PDX2 (float): Variation of friction Mux with load.\n        PDX3 (float): Variation of friction Mux with camber.\n        PEX1 (float): Longitudinal curvature Ef at Fznom.\n        PEX2 (float): Variation of curvature Ef with load.\n        PEX3 (float): Variation of curvature Ef with load squared.\n        PEX4 (float): Factor in curvature Ef while driving.\n        PKX1 (float): Longitudinal slip stiffness Kf/Fz at Fznom.\n        PKX2 (float): Variation of slip stiffness Kf/Fz with load.\n        PKX3 (float): Exponent in slip stiffness Kf/Fz with load.\n        PHX1 (float): Horizontal shift Shx at Fznom.\n        PHX2 (float): Variation of shift Shx with load.\n        PVX1 (float): Vertical shift Sv/Fz at Fznom.\n        PVX2 (float): Variation of shift Sv/Fz with load.\n        RBX1 (float): Slope factor for combined slip Fx reduction.\n        RBX2 (float): Variation of slope Fx reduction with kappa.\n        RBX3 (float): Influence of camber on stiffness for Fx combined.\n        RCX1 (float): Shape factor for combined slip Fx reduction.\n        REX1 (float): Curvature factor of combined Fx.\n        REX2 (float): Curvature factor of combined Fx with load.\n        RHX1 (float): Shift factor for combined slip Fx reduction.\n        PPX1 (float): Linear pressure effect on slip stiffness.\n        PPX2 (float): Quadratic pressure effect on slip stiffness.\n        PPX3 (float): Linear pressure effect on longitudinal friction.\n        PPX4 (float): Quadratic pressure effect on longitudinal friction.\n    \"\"\"\n\n    PCX1: float\n    PDX1: float\n    PDX2: float\n    PDX3: float\n    PEX1: float\n    PEX2: float\n    PEX3: float\n    PEX4: float\n    PKX1: float\n    PKX2: float\n    PKX3: float\n    PHX1: float\n    PHX2: float\n    PVX1: float\n    PVX2: float\n    RBX1: float\n    RBX2: float\n    RBX3: float\n    RCX1: float\n    REX1: float\n    REX2: float\n    RHX1: float\n    PPX1: float\n    PPX2: float\n    PPX3: float\n    PPX4: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Parameters on the usage of the tyre model.</p> <p>Attributes:</p> Name Type Description <code>FITTYP</code> <code>int</code> <p>Magic Formula version number.</p> <code>TYRESIDE</code> <code>str</code> <p>Position of tyre during measurements. \"LEFT\" or \"RIGHT\" (default = \"LEFT\").</p> <code>LONGVL</code> <code>float</code> <p>Reference speed.</p> <code>VXLOW</code> <code>float</code> <p>Lower boundary velocity in slip calculation.</p> <code>ROAD_INCREMENT</code> <code>Optional[float]</code> <p>Increment in road sampling.</p> <code>ROAD_DIRECTION</code> <code>Optional[float]</code> <p>Direction of travelled distance. 1 = default, -1 = reverse (default = 1)</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Model(_ParameterGroup):\n    \"\"\"\n    Parameters on the usage of the tyre model.\n\n    Attributes:\n        FITTYP (int): Magic Formula version number.\n        TYRESIDE (str): Position of tyre during measurements.\n            \"LEFT\" or \"RIGHT\" (default = \"LEFT\").\n        LONGVL (float): Reference speed.\n        VXLOW (float): Lower boundary velocity in slip calculation.\n        ROAD_INCREMENT (Optional[float]): Increment in road sampling.\n        ROAD_DIRECTION (Optional[float]): Direction of travelled distance.\n            1 = default, -1 = reverse (default = 1)\n    \"\"\"\n\n    FITTYP: int\n    TYRESIDE: str = \"LEFT\"\n    LONGVL: float\n    VXLOW: float\n    ROAD_INCREMENT: Optional[float] = None\n    ROAD_DIRECTION: Optional[float] = 1\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.OperatingConditions","title":"<code>OperatingConditions</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Operating conditions of the tyre.</p> <p>Attributes:</p> Name Type Description <code>INFLPRES</code> <code>float</code> <p>Tyre inflation pressure.</p> <code>NOMPRES</code> <code>float</code> <p>Nominal pressure used in Magic Formula equations.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class OperatingConditions(_ParameterGroup):\n    \"\"\"\n    Operating conditions of the tyre.\n\n    Attributes:\n        INFLPRES (float): Tyre inflation pressure.\n        NOMPRES (float): Nominal pressure used in Magic Formula equations.\n    \"\"\"\n\n    INFLPRES: float\n    NOMPRES: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.OverturningCoefficients","title":"<code>OverturningCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for evaluating overturning moment, Mx.</p> <p>Attributes:</p> Name Type Description <code>QSX1</code> <code>float</code> <p>Overturning moment offset.</p> <code>QSX2</code> <code>float</code> <p>Camber induced overturning couple.</p> <code>QSX3</code> <code>float</code> <p>Fy induced overturning couple.</p> <code>QSX4</code> <code>float</code> <p>Mixed load, lateral force and camber on Mx.</p> <code>QSX5</code> <code>float</code> <p>Load effect on Mx with lateral force and camber.</p> <code>QSX6</code> <code>float</code> <p>B-factor of load with Mx.</p> <code>QSX7</code> <code>float</code> <p>Camber with load on Mx.</p> <code>QSX8</code> <code>float</code> <p>Lateral force with load on Mx.</p> <code>QSX9</code> <code>float</code> <p>B-factor of lateral force with load on Mx.</p> <code>QSX10</code> <code>float</code> <p>Vertical force with camber on Mx.</p> <code>QSX11</code> <code>float</code> <p>B-factor of vertical force with camber on Mx.</p> <code>QSX12</code> <code>Optional[float]</code> <p>Camber squared induced overturning moment.</p> <code>QSX13</code> <code>Optional[float]</code> <p>Lateral force induced overturning moment.</p> <code>QSX14</code> <code>Optional[float]</code> <p>Lateral force induced overturning moment with camber.</p> <code>PPMX1</code> <code>float</code> <p>Influence of inflation pressure on overturning moment.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class OverturningCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for evaluating overturning moment, Mx.\n\n    Attributes:\n        QSX1 (float): Overturning moment offset.\n        QSX2 (float): Camber induced overturning couple.\n        QSX3 (float): Fy induced overturning couple.\n        QSX4 (float): Mixed load, lateral force and camber on Mx.\n        QSX5 (float): Load effect on Mx with lateral force and camber.\n        QSX6 (float): B-factor of load with Mx.\n        QSX7 (float): Camber with load on Mx.\n        QSX8 (float): Lateral force with load on Mx.\n        QSX9 (float): B-factor of lateral force with load on Mx.\n        QSX10 (float): Vertical force with camber on Mx.\n        QSX11 (float): B-factor of vertical force with camber on Mx.\n        QSX12 (Optional[float]): Camber squared induced overturning moment.\n        QSX13 (Optional[float]): Lateral force induced overturning moment.\n        QSX14 (Optional[float]): Lateral force induced overturning moment with camber.\n        PPMX1 (float): Influence of inflation pressure on overturning moment.\n    \"\"\"\n\n    QSX1: float\n    QSX2: float\n    QSX3: float\n    QSX4: float\n    QSX5: float\n    QSX6: float\n    QSX7: float\n    QSX8: float\n    QSX9: float\n    QSX10: float\n    QSX11: float\n    QSX12: Optional[float] = None\n    QSX13: Optional[float] = None\n    QSX14: Optional[float] = None\n    PPMX1: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.RollingCoefficients","title":"<code>RollingCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for evaluating rolling resistance moment, My.</p> <p>Attributes:</p> Name Type Description <code>QSY1</code> <code>float</code> <p>Rolling resistance torque coefficient.</p> <code>QSY2</code> <code>float</code> <p>Rolling resistance torque depending on Fx.</p> <code>QSY3</code> <code>float</code> <p>Rolling resistance torque depending on speed.</p> <code>QSY4</code> <code>float</code> <p>Rolling resistance torque depending on the fourth power of speed.</p> <code>QSY5</code> <code>float</code> <p>Rolling resistance torque depending on camber squared.</p> <code>QSY6</code> <code>float</code> <p>Rolling resistance torque depending on load and camber squared.</p> <code>QSY7</code> <code>float</code> <p>Rolling resistance torque coefficient load dependency.</p> <code>QSY8</code> <code>float</code> <p>Rolling resistance torque coefficient pressure dependency.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class RollingCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for evaluating rolling resistance moment, My.\n\n    Attributes:\n        QSY1 (float): Rolling resistance torque coefficient.\n        QSY2 (float): Rolling resistance torque depending on Fx.\n        QSY3 (float): Rolling resistance torque depending on speed.\n        QSY4 (float): Rolling resistance torque depending on the fourth power of speed.\n        QSY5 (float): Rolling resistance torque depending on camber squared.\n        QSY6 (float): Rolling resistance torque depending on load and camber squared.\n        QSY7 (float): Rolling resistance torque coefficient load dependency.\n        QSY8 (float): Rolling resistance torque coefficient pressure dependency.\n    \"\"\"\n\n    QSY1: float\n    QSY2: float\n    QSY3: float\n    QSY4: float\n    QSY5: float\n    QSY6: float\n    QSY7: float\n    QSY8: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.ScalingCoefficients","title":"<code>ScalingCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Magic Formula scaling factors.</p> <p>Attributes:</p> Name Type Description <code>LFZO</code> <code>float</code> <p>Scale factor of nominal (rated) load.</p> <code>LCX</code> <code>float</code> <p>Scale factor of Fx shape factor.</p> <code>LMUX</code> <code>float</code> <p>Scale factor of Fx peak friction coefficient.</p> <code>LEX</code> <code>float</code> <p>Scale factor of Fx curvature factor.</p> <code>LKX</code> <code>float</code> <p>Scale factor of slip stiffness.</p> <code>LHX</code> <code>float</code> <p>Scale factor of Fx horizontal shift.</p> <code>LVX</code> <code>float</code> <p>Scale factor of Fx vertical shift.</p> <code>LCY</code> <code>float</code> <p>Scale factor of Fy shape factor.</p> <code>LMUY</code> <code>float</code> <p>Scale factor of Fy peak friction coefficient.</p> <code>LEY</code> <code>float</code> <p>Scale factor of Fy curvature factor.</p> <code>LKY</code> <code>float</code> <p>Scale factor of cornering stiffness.</p> <code>LKYC</code> <code>float</code> <p>Scale factor of camber stiffness.</p> <code>LKZC</code> <code>float</code> <p>Scale factor of camber moment stiffness.</p> <code>LHY</code> <code>float</code> <p>Scale factor of Fy horizontal shift.</p> <code>LVY</code> <code>float</code> <p>Scale factor of Fy vertical shift.</p> <code>LTR</code> <code>float</code> <p>Scale factor of peak of pneumatic trail.</p> <code>LRES</code> <code>float</code> <p>Scale factor for offset of residual torque.</p> <code>LXAL</code> <code>float</code> <p>Scale factor of alpha influence on Fx.</p> <code>LYKA</code> <code>float</code> <p>Scale factor of kappa influence on Fy.</p> <code>LVYKA</code> <code>float</code> <p>Scale factor of kappa induced 'ply-steer' Fy.</p> <code>LS</code> <code>float</code> <p>Scale factor of moment arm of Fx.</p> <code>LMX</code> <code>float</code> <p>Scale factor of overturning moment.</p> <code>LVMX</code> <code>float</code> <p>Scale factor of Mx vertical shift.</p> <code>LMY</code> <code>float</code> <p>Scale factor of rolling resistance torque.</p> <code>LMP</code> <code>Optional[float]</code> <p>Scale factor of parking moment.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class ScalingCoefficients(_ParameterGroup):\n    \"\"\"\n    Magic Formula scaling factors.\n\n    Attributes:\n        LFZO (float): Scale factor of nominal (rated) load.\n        LCX (float): Scale factor of Fx shape factor.\n        LMUX (float): Scale factor of Fx peak friction coefficient.\n        LEX (float): Scale factor of Fx curvature factor.\n        LKX (float): Scale factor of slip stiffness.\n        LHX (float): Scale factor of Fx horizontal shift.\n        LVX (float): Scale factor of Fx vertical shift.\n        LCY (float): Scale factor of Fy shape factor.\n        LMUY (float): Scale factor of Fy peak friction coefficient.\n        LEY (float): Scale factor of Fy curvature factor.\n        LKY (float): Scale factor of cornering stiffness.\n        LKYC (float): Scale factor of camber stiffness.\n        LKZC (float): Scale factor of camber moment stiffness.\n        LHY (float): Scale factor of Fy horizontal shift.\n        LVY (float): Scale factor of Fy vertical shift.\n        LTR (float): Scale factor of peak of pneumatic trail.\n        LRES (float): Scale factor for offset of residual torque.\n        LXAL (float): Scale factor of alpha influence on Fx.\n        LYKA (float): Scale factor of kappa influence on Fy.\n        LVYKA (float): Scale factor of kappa induced 'ply-steer' Fy.\n        LS (float): Scale factor of moment arm of Fx.\n        LMX (float): Scale factor of overturning moment.\n        LVMX (float): Scale factor of Mx vertical shift.\n        LMY (float): Scale factor of rolling resistance torque.\n        LMP (Optional[float]): Scale factor of parking moment.\n    \"\"\"\n\n    LFZO: float = 1\n    LCX: float = 1\n    LMUX: float = 1\n    LEX: float = 1\n    LKX: float = 1\n    LHX: float = 1\n    LVX: float = 1\n    LCY: float = 1\n    LMUY: float = 1\n    LEY: float = 1\n    LKY: float = 1\n    LKYC: float = 1\n    LKZC: float = 1\n    LHY: float = 1\n    LVY: float = 1\n    LTR: float = 1\n    LRES: float = 1\n    LXAL: float = 1\n    LYKA: float = 1\n    LVYKA: float = 1\n    LS: float = 1\n    LMX: float = 1\n    LVMX: float = 1\n    LMY: float = 1\n    LMP: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.SlipAngleRange","title":"<code>SlipAngleRange</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Minimum and maximum valid sideslip angles.</p> <p>Attributes:</p> Name Type Description <code>ALPMIN</code> <code>Optional[float]</code> <p>Minimum valid slip angle.</p> <code>ALPMAX</code> <code>Optional[float]</code> <p>Maximum valid slip angle.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class SlipAngleRange(_ParameterGroup):\n    \"\"\"\n    Minimum and maximum valid sideslip angles.\n\n    Attributes:\n        ALPMIN (Optional[float]): Minimum valid slip angle.\n        ALPMAX (Optional[float]): Maximum valid slip angle.\n    \"\"\"\n\n    ALPMIN: Optional[float] = None\n    ALPMAX: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Structural","title":"<code>Structural</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Tyre stiffness, damping, and eigenfrequencies.</p> <p>Attributes:</p> Name Type Description <code>LONGITUDINAL_STIFFNESS</code> <code>Optional[float]</code> <p>Tyre overall longitudinal stiffness.</p> <code>LATERAL_STIFFNESS</code> <code>Optional[float]</code> <p>Tyre overall lateral stiffness.</p> <code>YAW_STIFFNESS</code> <code>Optional[float]</code> <p>Tyre overall yaw stiffness.</p> <code>FREQ_LONG</code> <code>Optional[float]</code> <p>Undamped frequency fore/aft and vertical mode.</p> <code>FREQ_LAT</code> <code>Optional[float]</code> <p>Undamped frequency lateral mode.</p> <code>FREQ_YAW</code> <code>Optional[float]</code> <p>Undamped frequency yaw and camber mode.</p> <code>FREQ_WINDUP</code> <code>Optional[float]</code> <p>Undamped frequency wind-up mode.</p> <code>DAMP_LONG</code> <code>Optional[float]</code> <p>Dimensionless damping fore/aft and vertical mode.</p> <code>DAMP_LAT</code> <code>Optional[float]</code> <p>Dimensionless damping lateral mode.</p> <code>DAMP_YAW</code> <code>Optional[float]</code> <p>Dimensionless damping yaw and camber mode.</p> <code>DAMP_WINDUP</code> <code>Optional[float]</code> <p>Dimensionless damping wind-up mode.</p> <code>DAMP_RESIDUAL</code> <code>Optional[float]</code> <p>Residual damping (proportional to stiffness).</p> <code>DAMP_VLOW</code> <code>Optional[float]</code> <p>Additional low speed damping (proportional to stiffness).</p> <code>Q_BVX</code> <code>Optional[float]</code> <p>Load and speed influence on in-plane translation stiffness.</p> <code>Q_BVT</code> <code>Optional[float]</code> <p>Load and speed influence on in-plane rotation stiffness.</p> <code>PCFX1</code> <code>Optional[float]</code> <p>Tyre overall longitudinal stiffness vertical deflection dependency linear term.</p> <code>PCFX2</code> <code>Optional[float]</code> <p>Tyre overall longitudinal stiffness vertical deflection dependency quadratic term.</p> <code>PCFX3</code> <code>Optional[float]</code> <p>Tyre overall longitudinal stiffness pressure dependency.</p> <code>PCFY1</code> <code>Optional[float]</code> <p>Tyre overall lateral stiffness vertical deflection dependency linear term.</p> <code>PCFY2</code> <code>Optional[float]</code> <p>Tyre overall lateral stiffness vertical deflection dependency quadratic term.</p> <code>PCFY3</code> <code>Optional[float]</code> <p>Tyre overall lateral stiffness pressure dependency.</p> <code>PCMZ1</code> <code>Optional[float]</code> <p>Tyre overall yaw stiffness pressure dependency.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Structural(_ParameterGroup):\n    \"\"\"\n    Tyre stiffness, damping, and eigenfrequencies.\n\n    Attributes:\n        LONGITUDINAL_STIFFNESS (Optional[float]):\n            Tyre overall longitudinal stiffness.\n        LATERAL_STIFFNESS (Optional[float]): Tyre overall lateral stiffness.\n        YAW_STIFFNESS (Optional[float]): Tyre overall yaw stiffness.\n        FREQ_LONG (Optional[float]):\n            Undamped frequency fore/aft and vertical mode.\n        FREQ_LAT (Optional[float]): Undamped frequency lateral mode.\n        FREQ_YAW (Optional[float]): Undamped frequency yaw and camber mode.\n        FREQ_WINDUP (Optional[float]): Undamped frequency wind-up mode.\n        DAMP_LONG (Optional[float]):\n            Dimensionless damping fore/aft and vertical mode.\n        DAMP_LAT (Optional[float]): Dimensionless damping lateral mode.\n        DAMP_YAW (Optional[float]): Dimensionless damping yaw and camber mode.\n        DAMP_WINDUP (Optional[float]): Dimensionless damping wind-up mode.\n        DAMP_RESIDUAL (Optional[float]):\n            Residual damping (proportional to stiffness).\n        DAMP_VLOW (Optional[float]):\n            Additional low speed damping (proportional to stiffness).\n        Q_BVX (Optional[float]):\n            Load and speed influence on in-plane translation stiffness.\n        Q_BVT (Optional[float]):\n            Load and speed influence on in-plane rotation stiffness.\n        PCFX1 (Optional[float]): Tyre overall longitudinal stiffness\n            vertical deflection dependency linear term.\n        PCFX2 (Optional[float]): Tyre overall longitudinal stiffness\n            vertical deflection dependency quadratic term.\n        PCFX3 (Optional[float]):\n            Tyre overall longitudinal stiffness pressure dependency.\n        PCFY1 (Optional[float]): Tyre overall lateral stiffness\n            vertical deflection dependency linear term.\n        PCFY2 (Optional[float]): Tyre overall lateral stiffness\n            vertical deflection dependency quadratic term.\n        PCFY3 (Optional[float]):\n            Tyre overall lateral stiffness pressure dependency.\n        PCMZ1 (Optional[float]): Tyre overall yaw stiffness pressure dependency.\n    \"\"\"\n\n    LONGITUDINAL_STIFFNESS: Optional[float] = None\n    LATERAL_STIFFNESS: Optional[float] = None\n    YAW_STIFFNESS: Optional[float] = None\n    FREQ_LONG: Optional[float] = None\n    FREQ_LAT: Optional[float] = None\n    FREQ_YAW: Optional[float] = None\n    FREQ_WINDUP: Optional[float] = None\n    DAMP_LONG: Optional[float] = None\n    DAMP_LAT: Optional[float] = None\n    DAMP_YAW: Optional[float] = None\n    DAMP_WINDUP: Optional[float] = None\n    DAMP_RESIDUAL: Optional[float] = None\n    DAMP_VLOW: Optional[float] = None\n    Q_BVX: Optional[float] = None\n    Q_BVT: Optional[float] = None\n    PCFX1: Optional[float] = None\n    PCFX2: Optional[float] = None\n    PCFX3: Optional[float] = None\n    PCFY1: Optional[float] = None\n    PCFY2: Optional[float] = None\n    PCFY3: Optional[float] = None\n    PCMZ1: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.TIRParameters","title":"<code>TIRParameters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Tyre parameters specified in a .TIR file.</p> <p>For ease of use, parameters are split into groups.</p> <p>Values can be accessed using dot notation:</p> <p>Attributes:</p> Name Type Description <code>UNITS</code> <code>Units</code> <p>Units used in the .TIR file.</p> <code>MODEL</code> <code>Model</code> <p>Parameters on the usage of the tyre model.</p> <code>DIMENSION</code> <code>Dimension</code> <p>Tyre dimensions.</p> <code>OPERATING_CONDITIONS</code> <code>OperatingConditions</code> <p>Operating conditions of the tyre.</p> <code>INERTIA</code> <code>Inertia</code> <p>Mass and inertia properties of the tyre and tyre belt.</p> <code>VERTICAL</code> <code>Vertical</code> <p>Vertical stiffness, loaded and effective rolling radius.</p> <code>STRUCTURAL</code> <code>Structural</code> <p>Tyre stiffness, damping, and eigenfrequencies.</p> <code>CONTACT_PATCH</code> <code>ContactPatch</code> <p>Contact length and obstacle enveloping parameters.</p> <code>INFLATION_PRESSURE_RANGE</code> <code>InflationPressureRange</code> <p>Minimum and maximum allowed inflation pressures.</p> <code>VERTICAL_FORCE_RANGE</code> <code>VerticalForceRange</code> <p>Minimum and maximum allowed wheel loads.</p> <code>LONG_SLIP_RANGE</code> <code>LongSlipRange</code> <p>Minimum and maximum valid longitudinal slips.</p> <code>SLIP_ANGLE_RANGE</code> <code>SlipAngleRange</code> <p>Minimum and maximum valid sideslip angles.</p> <code>INCLINATION_ANGLE_RANGE</code> <code>InclinationAngleRange</code> <p>Minimum and maximum valid inclination angles.</p> <code>SCALING_COEFFICIENTS</code> <code>ScalingCoefficients</code> <p>Magic Formula scaling factors.</p> <code>LONGITUDINAL_COEFFICIENTS</code> <code>LongitudinalCoefficients</code> <p>Coefficients for evaluating longitudinal force, Fx.</p> <code>OVERTURNING_COEFFICIENTS</code> <code>OverturningCoefficients</code> <p>Coefficients for evaluating overturning moment, Mx.</p> <code>LATERAL_COEFFICIENTS</code> <code>LateralCoefficients</code> <p>Coefficients for evaluating lateral force, Fy.</p> <code>ROLLING_COEFFICIENTS</code> <code>RollingCoefficients</code> <p>Coefficients for evaluating rolling resistance moment, My.</p> <code>ALIGNING_COEFFICIENTS</code> <code>AligningCoefficients</code> <p>Coefficients for evaluating self-aligning moment, Mz.</p> <code>TURNSLIP_COEFFICIENTS</code> <code>TurnslipCoefficients</code> <p>Coefficients for turn slip, affecting all forces and moments.</p> <p>Examples:</p> <p>Load tyre parameters from a .TIR file <code>Example Tyre.tir</code>, and get the inflation pressure of the tyre (<code>INFLPRES</code>).</p> <pre><code>&gt;&gt;&gt; tir_parameters = TIRParameters.from_file(\"Example Tyre.tir\")\n&gt;&gt;&gt; inflation_pressure = tir_parameters.OPERATING_CONDITIONS.INFLPRES\n</code></pre> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class TIRParameters(BaseModel):\n    \"\"\"\n    Tyre parameters specified in a .TIR file.\n\n    For ease of use, parameters are split into groups.\n\n    Values can be accessed using dot notation:\n\n    Attributes:\n        UNITS (Units):\n            Units used in the .TIR file.\n        MODEL (Model):\n            Parameters on the usage of the tyre model.\n        DIMENSION (Dimension):\n            Tyre dimensions.\n        OPERATING_CONDITIONS (OperatingConditions):\n            Operating conditions of the tyre.\n        INERTIA (Inertia):\n            Mass and inertia properties of the tyre and tyre belt.\n        VERTICAL (Vertical):\n            Vertical stiffness, loaded and effective rolling radius.\n        STRUCTURAL (Structural):\n            Tyre stiffness, damping, and eigenfrequencies.\n        CONTACT_PATCH (ContactPatch):\n            Contact length and obstacle enveloping parameters.\n        INFLATION_PRESSURE_RANGE (InflationPressureRange):\n            Minimum and maximum allowed inflation pressures.\n        VERTICAL_FORCE_RANGE (VerticalForceRange):\n            Minimum and maximum allowed wheel loads.\n        LONG_SLIP_RANGE (LongSlipRange):\n            Minimum and maximum valid longitudinal slips.\n        SLIP_ANGLE_RANGE (SlipAngleRange):\n            Minimum and maximum valid sideslip angles.\n        INCLINATION_ANGLE_RANGE (InclinationAngleRange):\n            Minimum and maximum valid inclination angles.\n        SCALING_COEFFICIENTS (ScalingCoefficients):\n            Magic Formula scaling factors.\n        LONGITUDINAL_COEFFICIENTS (LongitudinalCoefficients):\n            Coefficients for evaluating longitudinal force, Fx.\n        OVERTURNING_COEFFICIENTS (OverturningCoefficients):\n            Coefficients for evaluating overturning moment, Mx.\n        LATERAL_COEFFICIENTS (LateralCoefficients):\n            Coefficients for evaluating lateral force, Fy.\n        ROLLING_COEFFICIENTS (RollingCoefficients):\n            Coefficients for evaluating rolling resistance moment, My.\n        ALIGNING_COEFFICIENTS (AligningCoefficients):\n            Coefficients for evaluating self-aligning moment, Mz.\n        TURNSLIP_COEFFICIENTS (TurnslipCoefficients):\n            Coefficients for turn slip, affecting all forces and moments.\n\n    Examples:\n        Load tyre parameters from a .TIR file `Example Tyre.tir`,\n        and get the inflation pressure of the tyre (`INFLPRES`).\n\n        &gt;&gt;&gt; tir_parameters = TIRParameters.from_file(\"Example Tyre.tir\")\n        &gt;&gt;&gt; inflation_pressure = tir_parameters.OPERATING_CONDITIONS.INFLPRES\n    \"\"\"\n\n    UNITS: Units\n    MODEL: Model\n    DIMENSION: Dimension\n    OPERATING_CONDITIONS: OperatingConditions\n    INERTIA: Inertia\n    VERTICAL: Vertical\n    STRUCTURAL: Structural\n    CONTACT_PATCH: ContactPatch\n    INFLATION_PRESSURE_RANGE: InflationPressureRange\n    VERTICAL_FORCE_RANGE: VerticalForceRange\n    LONG_SLIP_RANGE: LongSlipRange\n    SLIP_ANGLE_RANGE: SlipAngleRange\n    INCLINATION_ANGLE_RANGE: InclinationAngleRange\n    SCALING_COEFFICIENTS: ScalingCoefficients\n    LONGITUDINAL_COEFFICIENTS: LongitudinalCoefficients\n    OVERTURNING_COEFFICIENTS: OverturningCoefficients\n    LATERAL_COEFFICIENTS: LateralCoefficients\n    ROLLING_COEFFICIENTS: RollingCoefficients\n    ALIGNING_COEFFICIENTS: AligningCoefficients\n    TURNSLIP_COEFFICIENTS: TurnslipCoefficients\n\n    def __str__(self) -&gt; str:\n        return self.model_dump_json(indent=4)\n\n    @classmethod\n    def from_file(cls, filepath: str) -&gt; Self:\n        \"\"\"\n        Generate a TIRParameters object from a .TIR file.\n\n        Uses _TIRReader to parse the .TIR file into a dictionary,\n        then converts it to a TIRParameters object.\n\n        Args:\n            filepath (str):\n                Filepath to the .TIR file.\n\n        Returns:\n            self (TIRParameters):\n                A TIRParameters object.\n\n        Raises:\n            FileNotFoundError:\n                If the file is not found.\n            ValueError:\n                If an error occurs while parsing the .TIR file.\n            ValidationError:\n                If the data cannot be converted\n                into a valid `TIRParameters` object.\n        \"\"\"\n        tir_data = _TIRReader().read(filepath)\n        return cls.model_validate(tir_data)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.TIRParameters.from_file","title":"<code>from_file(filepath)</code>  <code>classmethod</code>","text":"<p>Generate a TIRParameters object from a .TIR file.</p> <p>Uses _TIRReader to parse the .TIR file into a dictionary, then converts it to a TIRParameters object.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Filepath to the .TIR file.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>TIRParameters</code> <p>A TIRParameters object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file is not found.</p> <code>ValueError</code> <p>If an error occurs while parsing the .TIR file.</p> <code>ValidationError</code> <p>If the data cannot be converted into a valid <code>TIRParameters</code> object.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>@classmethod\ndef from_file(cls, filepath: str) -&gt; Self:\n    \"\"\"\n    Generate a TIRParameters object from a .TIR file.\n\n    Uses _TIRReader to parse the .TIR file into a dictionary,\n    then converts it to a TIRParameters object.\n\n    Args:\n        filepath (str):\n            Filepath to the .TIR file.\n\n    Returns:\n        self (TIRParameters):\n            A TIRParameters object.\n\n    Raises:\n        FileNotFoundError:\n            If the file is not found.\n        ValueError:\n            If an error occurs while parsing the .TIR file.\n        ValidationError:\n            If the data cannot be converted\n            into a valid `TIRParameters` object.\n    \"\"\"\n    tir_data = _TIRReader().read(filepath)\n    return cls.model_validate(tir_data)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.TurnslipCoefficients","title":"<code>TurnslipCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for turn slip, affecting all forces and moments.</p> <p>Attributes:</p> Name Type Description <code>PDXP1</code> <code>Optional[float]</code> <p>Peak Fx reduction due to spin parameter.</p> <code>PDXP2</code> <code>Optional[float]</code> <p>Peak Fx reduction due to spin with varying load parameter.</p> <code>PDXP3</code> <code>Optional[float]</code> <p>Peak Fx reduction due to spin with kappa parameter.</p> <code>PKYP1</code> <code>Optional[float]</code> <p>Cornering stiffness reduction due to spin.</p> <code>PDYP1</code> <code>Optional[float]</code> <p>Peak Fy reduction due to spin parameter.</p> <code>PDYP2</code> <code>Optional[float]</code> <p>Peak Fy reduction due to spin with varying load parameter.</p> <code>PDYP3</code> <code>Optional[float]</code> <p>Peak Fy reduction due to spin with alpha parameter.</p> <code>PDYP4</code> <code>Optional[float]</code> <p>Peak Fy reduction due to square root of spin parameter.</p> <code>PHYP1</code> <code>Optional[float]</code> <p>Fy-alpha curve lateral shift limitation.</p> <code>PHYP2</code> <code>Optional[float]</code> <p>Fy-alpha curve maximum lateral shift parameter.</p> <code>PHYP3</code> <code>Optional[float]</code> <p>Fy-alpha curve maximum lateral shift varying with load parameter.</p> <code>PHYP4</code> <code>Optional[float]</code> <p>Fy-alpha curve maximum lateral shift parameter.</p> <code>PECP1</code> <code>Optional[float]</code> <p>Camber w.r.t. spin reduction factor parameter in camber stiffness.</p> <code>PECP2</code> <code>Optional[float]</code> <p>Camber w.r.t. spin reduction factor varying with load parameter in camber stiffness.</p> <code>QDTP1</code> <code>Optional[float]</code> <p>Pneumatic trail reduction factor due to turn slip parameter.</p> <code>QCRP1</code> <code>Optional[float]</code> <p>Turning moment at constant turning and zero forward speed parameter.</p> <code>QCRP2</code> <code>Optional[float]</code> <p>Turn slip moment (at alpha=90deg) parameter for increase with spin.</p> <code>QBRP1</code> <code>Optional[float]</code> <p>Residual (spin) torque reduction factor parameter due to side slip.</p> <code>QDRP1</code> <code>Optional[float]</code> <p>Turn slip moment peak magnitude parameter.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class TurnslipCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for turn slip, affecting all forces and moments.\n\n    Attributes:\n        PDXP1 (Optional[float]): Peak Fx reduction due to spin parameter.\n        PDXP2 (Optional[float]): Peak Fx reduction due to spin with varying load parameter.\n        PDXP3 (Optional[float]): Peak Fx reduction due to spin with kappa parameter.\n        PKYP1 (Optional[float]): Cornering stiffness reduction due to spin.\n        PDYP1 (Optional[float]): Peak Fy reduction due to spin parameter.\n        PDYP2 (Optional[float]): Peak Fy reduction due to spin with varying load parameter.\n        PDYP3 (Optional[float]): Peak Fy reduction due to spin with alpha parameter.\n        PDYP4 (Optional[float]): Peak Fy reduction due to square root of spin parameter.\n        PHYP1 (Optional[float]): Fy-alpha curve lateral shift limitation.\n        PHYP2 (Optional[float]): Fy-alpha curve maximum lateral shift parameter.\n        PHYP3 (Optional[float]): Fy-alpha curve maximum lateral shift varying with load parameter.\n        PHYP4 (Optional[float]): Fy-alpha curve maximum lateral shift parameter.\n        PECP1 (Optional[float]): Camber w.r.t. spin reduction factor parameter in camber stiffness.\n        PECP2 (Optional[float]): Camber w.r.t. spin reduction factor\n            varying with load parameter in camber stiffness.\n        QDTP1 (Optional[float]): Pneumatic trail reduction factor due to turn slip parameter.\n        QCRP1 (Optional[float]): Turning moment at constant turning and zero forward speed parameter.\n        QCRP2 (Optional[float]): Turn slip moment (at alpha=90deg) parameter for increase with spin.\n        QBRP1 (Optional[float]): Residual (spin) torque reduction factor parameter due to side slip.\n        QDRP1 (Optional[float]): Turn slip moment peak magnitude parameter.\n    \"\"\"\n\n    PDXP1: Optional[float] = None\n    PDXP2: Optional[float] = None\n    PDXP3: Optional[float] = None\n    PKYP1: Optional[float] = None\n    PDYP1: Optional[float] = None\n    PDYP2: Optional[float] = None\n    PDYP3: Optional[float] = None\n    PDYP4: Optional[float] = None\n    PHYP1: Optional[float] = None\n    PHYP2: Optional[float] = None\n    PHYP3: Optional[float] = None\n    PHYP4: Optional[float] = None\n    PECP1: Optional[float] = None\n    PECP2: Optional[float] = None\n    QDTP1: Optional[float] = None\n    QCRP1: Optional[float] = None\n    QCRP2: Optional[float] = None\n    QBRP1: Optional[float] = None\n    QDRP1: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Units","title":"<code>Units</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Units used in the .TIR file.</p> <p>Attributes:</p> Name Type Description <code>LENGTH</code> <code>str</code> <p>Length units (default: \"meter\").</p> <code>FORCE</code> <code>str</code> <p>Force units (default: \"newton\").</p> <code>ANGLE</code> <code>str</code> <p>Angle units (default: \"radians\").</p> <code>MASS</code> <code>str</code> <p>Mass units (default: \"kg\").</p> <code>TIME</code> <code>str</code> <p>Time units (default: \"second\").</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Units(_ParameterGroup):\n    \"\"\"\n    Units used in the .TIR file.\n\n    Attributes:\n        LENGTH: Length units (default: \"meter\").\n        FORCE: Force units (default: \"newton\").\n        ANGLE: Angle units (default: \"radians\").\n        MASS: Mass units (default: \"kg\").\n        TIME: Time units (default: \"second\").\n    \"\"\"\n\n    LENGTH: str\n    FORCE: str\n    ANGLE: str\n    MASS: str\n    TIME: str\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Vertical","title":"<code>Vertical</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Vertical stiffness, loaded and effective rolling radius.</p> <p>Attributes:</p> Name Type Description <code>FNOMIN</code> <code>float</code> <p>Nominal wheel load.</p> <code>VERTICAL_STIFFNESS</code> <code>Optional[float]</code> <p>tyre vertical stiffness.</p> <code>VERTICAL_DAMPING</code> <code>Optional[float]</code> <p>tyre vertical damping.</p> <code>MC_CONTOUR_A</code> <code>Optional[float]</code> <p>Motorcycle contour ellipse A.</p> <code>MC_CONTOUR_B</code> <code>Optional[float]</code> <p>Motorcycle contour ellipse B.</p> <code>BREFF</code> <code>Optional[float]</code> <p>Low load stiffness of effective rolling radius.</p> <code>DREFF</code> <code>Optional[float]</code> <p>Peak value of effective rolling radius.</p> <code>FREFF</code> <code>Optional[float]</code> <p>High load stiffness of effective rolling radius.</p> <code>Q_RE0</code> <code>Optional[float]</code> <p>Ratio of free tyre radius with nominal tyre radius.</p> <code>Q_V1</code> <code>Optional[float]</code> <p>tyre radius increase with speed.</p> <code>Q_V2</code> <code>Optional[float]</code> <p>Vertical stiffness increase with speed.</p> <code>Q_FZ2</code> <code>Optional[float]</code> <p>Quadratic term in load vs. deflection.</p> <code>Q_FCX</code> <code>Optional[float]</code> <p>Longitudinal force influence on vertical stiffness.</p> <code>Q_FCY</code> <code>Optional[float]</code> <p>Lateral force influence on vertical stiffness.</p> <code>Q_FCY2</code> <code>Optional[float]</code> <p>Explicit load dependency for including the lateral force influence on vertical stiffness.</p> <code>Q_CAM</code> <code>Optional[float]</code> <p>Stiffness reduction due to camber.</p> <code>Q_CAM1</code> <code>Optional[float]</code> <p>Linear load dependent camber angle influence on vertical stiffness.</p> <code>Q_CAM2</code> <code>Optional[float]</code> <p>Quadratic load dependent camber angle influence on vertical stiffness.</p> <code>Q_CAM3</code> <code>Optional[float]</code> <p>Linear load and camber angle dependent reduction on vertical stiffness.</p> <code>Q_FYS1</code> <code>Optional[float]</code> <p>Combined camber angle and side slip angle effect on vertical stiffness (constant).</p> <code>Q_FYS2</code> <code>Optional[float]</code> <p>Combined camber angle and side slip angle linear effect on vertical stiffness.</p> <code>Q_FYS3</code> <code>Optional[float]</code> <p>Combined camber angle and side slip angle quadratic effect on vertical stiffness.</p> <code>PFZ1</code> <code>Optional[float]</code> <p>Pressure effect on vertical stiffness.</p> <code>BOTTOM_OFFST</code> <code>Optional[float]</code> <p>Distance to rim when bottoming starts to occur.</p> <code>BOTTOM_STIFF</code> <code>Optional[float]</code> <p>Vertical stiffness of bottomed tyre.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Vertical(_ParameterGroup):\n    \"\"\"\n    Vertical stiffness, loaded and effective rolling radius.\n\n    Attributes:\n        FNOMIN (float): Nominal wheel load.\n        VERTICAL_STIFFNESS (Optional[float]): tyre vertical stiffness.\n        VERTICAL_DAMPING (Optional[float]): tyre vertical damping.\n        MC_CONTOUR_A (Optional[float]): Motorcycle contour ellipse A.\n        MC_CONTOUR_B (Optional[float]): Motorcycle contour ellipse B.\n        BREFF (Optional[float]): Low load stiffness of effective rolling radius.\n        DREFF (Optional[float]): Peak value of effective rolling radius.\n        FREFF (Optional[float]):\n            High load stiffness of effective rolling radius.\n        Q_RE0 (Optional[float]):\n            Ratio of free tyre radius with nominal tyre radius.\n        Q_V1 (Optional[float]): tyre radius increase with speed.\n        Q_V2 (Optional[float]): Vertical stiffness increase with speed.\n        Q_FZ2 (Optional[float]): Quadratic term in load vs. deflection.\n        Q_FCX (Optional[float]):\n            Longitudinal force influence on vertical stiffness.\n        Q_FCY (Optional[float]): Lateral force influence on vertical stiffness.\n        Q_FCY2 (Optional[float]): Explicit load dependency for including\n            the lateral force influence on vertical stiffness.\n        Q_CAM (Optional[float]): Stiffness reduction due to camber.\n        Q_CAM1 (Optional[float]): Linear load dependent camber angle\n            influence on vertical stiffness.\n        Q_CAM2 (Optional[float]): Quadratic load dependent camber angle\n            influence on vertical stiffness.\n        Q_CAM3 (Optional[float]): Linear load and camber angle dependent\n            reduction on vertical stiffness.\n        Q_FYS1 (Optional[float]): Combined camber angle and side slip angle\n            effect on vertical stiffness (constant).\n        Q_FYS2 (Optional[float]): Combined camber angle and side slip angle\n            linear effect on vertical stiffness.\n        Q_FYS3 (Optional[float]): Combined camber angle and side slip angle\n            quadratic effect on vertical stiffness.\n        PFZ1 (Optional[float]): Pressure effect on vertical stiffness.\n        BOTTOM_OFFST (Optional[float]):\n            Distance to rim when bottoming starts to occur.\n        BOTTOM_STIFF (Optional[float]): Vertical stiffness of bottomed tyre.\n    \"\"\"\n\n    FNOMIN: float\n    VERTICAL_STIFFNESS: Optional[float] = None\n    VERTICAL_DAMPING: Optional[float] = None\n    MC_CONTOUR_A: Optional[float] = None\n    MC_CONTOUR_B: Optional[float] = None\n    BREFF: Optional[float] = None\n    DREFF: Optional[float] = None\n    FREFF: Optional[float] = None\n    Q_RE0: Optional[float] = None\n    Q_V1: Optional[float] = None\n    Q_V2: Optional[float] = None\n    Q_FZ2: Optional[float] = None\n    Q_FCX: Optional[float] = None\n    Q_FCY: Optional[float] = None\n    Q_FCY2: Optional[float] = None\n    Q_CAM: Optional[float] = None\n    Q_CAM1: Optional[float] = None\n    Q_CAM2: Optional[float] = None\n    Q_CAM3: Optional[float] = None\n    Q_FYS1: Optional[float] = None\n    Q_FYS2: Optional[float] = None\n    Q_FYS3: Optional[float] = None\n    PFZ1: Optional[float] = None\n    BOTTOM_OFFST: Optional[float] = None\n    BOTTOM_STIFF: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.VerticalForceRange","title":"<code>VerticalForceRange</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Minimum and maximum allowed wheel loads.</p> <p>Attributes:</p> Name Type Description <code>FZMIN</code> <code>Optional[float]</code> <p>Minimum allowed wheel load.</p> <code>FZMAX</code> <code>Optional[float]</code> <p>Maximum allowed wheel load.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class VerticalForceRange(_ParameterGroup):\n    \"\"\"\n    Minimum and maximum allowed wheel loads.\n\n    Attributes:\n        FZMIN (Optional[float]): Minimum allowed wheel load.\n        FZMAX (Optional[float]): Maximum allowed wheel load.\n    \"\"\"\n\n    FZMIN: Optional[float] = None\n    FZMAX: Optional[float] = None\n</code></pre>"}]}