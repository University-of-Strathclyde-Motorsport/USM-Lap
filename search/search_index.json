{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"USM Lap","text":"<p>Laptime simulator built by the University of Strathclyde Motorsport team.</p>"},{"location":"autoapi/summary/","title":"Summary","text":"<ul> <li>usmlap<ul> <li>__main__</li> <li>analysis<ul> <li>coupling</li> <li>sweep_1d</li> </ul> </li> <li>filepath</li> <li>plot<ul> <li>apex</li> <li>channels</li> <li>common</li> <li>ggv</li> </ul> </li> <li>simulation<ul> <li>channels<ul> <li>channel</li> <li>functions</li> <li>library</li> </ul> </li> <li>competition</li> <li>environment</li> <li>model<ul> <li>point_mass</li> <li>vehicle_model</li> </ul> </li> <li>points<ul> <li>competition_data</li> <li>points</li> <li>points_functions</li> </ul> </li> <li>sensitivity</li> <li>simulation</li> <li>solution</li> <li>solver<ul> <li>quasi_steady_state</li> <li>quasi_transient</li> <li>solver_interface</li> </ul> </li> <li>vehicle_state</li> </ul> </li> <li>track<ul> <li>mesh</li> <li>track_data</li> </ul> </li> <li>utils<ul> <li>array</li> <li>datatypes</li> <li>geometry</li> <li>proportion</li> <li>units</li> </ul> </li> <li>vehicle<ul> <li>aero</li> <li>brakes</li> <li>common</li> <li>driver</li> <li>inertia</li> <li>parameters</li> <li>powertrain<ul> <li>accumulator</li> <li>motor</li> <li>motor_controller</li> <li>powertrain</li> </ul> </li> <li>steering</li> <li>suspension</li> <li>transmission</li> <li>tyre<ul> <li>magic_formula</li> <li>tir</li> <li>tyre_model</li> </ul> </li> <li>vehicle</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/usmlap/","title":"usmlap","text":""},{"location":"autoapi/usmlap/__main__/","title":"__main__","text":""},{"location":"autoapi/usmlap/filepath/","title":"filepath","text":"<p>This module contains code for working with filepaths.</p>"},{"location":"autoapi/usmlap/analysis/","title":"analysis","text":""},{"location":"autoapi/usmlap/analysis/coupling/","title":"coupling","text":"<p>This module contains code for analysing the coupling between two parameters.</p>"},{"location":"autoapi/usmlap/analysis/coupling/#usmlap.analysis.coupling.CouplingResults","title":"<code>CouplingResults</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>The results of a coupling analysis.</p> <p>Attributes:</p> Name Type Description <code>sweep_parameter</code> <code>Parameter</code> <p>The parameter being swept.</p> <code>coupled_parameter</code> <code>Parameter</code> <p>The parameter being evaluated.</p> <code>data</code> <code>dict[float, float]</code> <p>A dictionary containing swept parameter values and the corresponding sensitivities of the coupled parameter.</p> Source code in <code>src\\usmlap\\analysis\\coupling.py</code> <pre><code>@dataclass\nclass CouplingResults(object):\n    \"\"\"\n    The results of a coupling analysis.\n\n    Attributes:\n        sweep_parameter (Parameter):\n            The parameter being swept.\n        coupled_parameter (Parameter):\n            The parameter being evaluated.\n        data (dict[float, float]):\n            A dictionary containing swept parameter values\n            and the corresponding sensitivities of the coupled parameter.\n    \"\"\"\n\n    sweep_parameter: Parameter\n    coupled_parameter: Parameter\n    data: dict[float, float] = field(default_factory=lambda: {})\n\n    def plot(self) -&gt; None:\n        plt.plot(list(self.data.keys()), list(self.data.values()))\n        plt.title(\n            f\"Coupling - {self.sweep_parameter.name} and {self.coupled_parameter.name}\"\n        )\n        plt.xlabel(self.sweep_parameter.get_name_with_unit())\n        plt.ylabel(f\"{self.coupled_parameter.name} Sensitivity\")\n        plt.grid()\n        plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/analysis/coupling/#usmlap.analysis.coupling.coupling","title":"<code>coupling(baseline_vehicle, sweep_settings, coupled_parameter, competition_settings)</code>","text":"<p>Carry out a coupling analysis between two parameters.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_vehicle</code> <code>Vehicle</code> <p>The vehicle to simulate.</p> required <code>sweep_settings</code> <code>SweepSettings</code> <p>Settings for sweeping the first parameter.</p> required <code>coupled_parameter</code> <code>Parameter</code> <p>The parameter to evaluate the sensitivity of.</p> required <p>Returns:</p> Name Type Description <code>coupling_results</code> <code>CouplingResults</code> <p>The results of the coupling analysis.</p> Source code in <code>src\\usmlap\\analysis\\coupling.py</code> <pre><code>def coupling(\n    baseline_vehicle: Vehicle,\n    sweep_settings: SweepSettings,\n    coupled_parameter: Parameter,\n    competition_settings: CompetitionSettings,\n) -&gt; CouplingResults:\n    \"\"\"\n    Carry out a coupling analysis between two parameters.\n\n    Args:\n        baseline_vehicle (Vehicle):\n            The vehicle to simulate.\n        sweep_settings (SweepSettings):\n            Settings for sweeping the first parameter.\n        coupled_parameter (Parameter):\n            The parameter to evaluate the sensitivity of.\n\n    Returns:\n        coupling_results (CouplingResults):\n            The results of the coupling analysis.\n    \"\"\"\n    coupling_results = CouplingResults(\n        sweep_parameter=sweep_settings.parameter,\n        coupled_parameter=coupled_parameter,\n    )\n    for value, vehicle in sweep_settings.get_vehicles(baseline_vehicle):\n        analysis = SensitivityAnalysis(\n            baseline_vehicle=vehicle,\n            parameter=coupled_parameter,\n            competition_settings=competition_settings,\n        )\n        coupling_results.data[value] = analysis.get_sensitivity()\n    return coupling_results\n</code></pre>"},{"location":"autoapi/usmlap/analysis/sweep_1d/","title":"sweep_1d","text":"<p>This module contains code for carrying out a 1D sweep of a parameter.</p>"},{"location":"autoapi/usmlap/analysis/sweep_1d/#usmlap.analysis.sweep_1d.SweepResults","title":"<code>SweepResults</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>The results of a 1D sweep of a parameter.</p> <p>Attributes:</p> Name Type Description <code>parameter</code> <code>Parameter</code> <p>The parameter being swept.</p> <code>data</code> <code>dict[float, float]</code> <p>A dictionary containing parameter values and the corresponding points scored.</p> Source code in <code>src\\usmlap\\analysis\\sweep_1d.py</code> <pre><code>@dataclass\nclass SweepResults(object):\n    \"\"\"\n    The results of a 1D sweep of a parameter.\n\n    Attributes:\n        parameter (Parameter): The parameter being swept.\n        data (dict[float, float]):\n            A dictionary containing parameter values\n            and the corresponding points scored.\n    \"\"\"\n\n    parameter: Parameter\n    data: dict[float, float] = field(default_factory=lambda: {})\n\n    def plot(self) -&gt; None:\n        plt.plot(list(self.data.keys()), list(self.data.values()))\n        plt.title(f\"Points Sensitivity - {self.parameter.name}\")\n        plt.xlabel(self.parameter.get_name_with_unit())\n        plt.ylabel(\"Points\")\n        plt.grid()\n        plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/analysis/sweep_1d/#usmlap.analysis.sweep_1d.SweepSettings","title":"<code>SweepSettings</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Settings for a 1D sweep of a parameter.</p> <p>Attributes:</p> Name Type Description <code>parameter</code> <code>Parameter</code> <p>The parameter to sweep.</p> <code>start_value</code> <code>float</code> <p>The start value of the sweep.</p> <code>end_value</code> <code>float</code> <p>The end value of the sweep.</p> <code>number_of_steps</code> <code>int</code> <p>The number of steps in the sweep.</p> Source code in <code>src\\usmlap\\analysis\\sweep_1d.py</code> <pre><code>@dataclass\nclass SweepSettings(object):\n    \"\"\"\n    Settings for a 1D sweep of a parameter.\n\n    Attributes:\n        parameter (Parameter): The parameter to sweep.\n        start_value (float): The start value of the sweep.\n        end_value (float): The end value of the sweep.\n        number_of_steps (int): The number of steps in the sweep.\n    \"\"\"\n\n    parameter: Parameter\n    start_value: float\n    end_value: float\n    number_of_steps: int\n\n    @property\n    def values(self) -&gt; list[float]:\n        return np.linspace(\n            self.start_value, self.end_value, self.number_of_steps\n        ).tolist()\n\n    def get_vehicles(\n        self, baseline_vehicle: Vehicle\n    ) -&gt; Generator[tuple[float, Vehicle]]:\n        \"\"\"\n        Generate a list of vehicles for a sweep.\n\n        Args:\n            baseline_vehicle (Vehicle): The baseline vehicle to use.\n\n        Yields:\n            result (tuple[float, Vehicle]):\n                A tuple containing the modified parameter value\n                and the corresponding vehicle.\n        \"\"\"\n        for value in self.values:\n            vehicle = get_new_vehicle(baseline_vehicle, self.parameter, value)\n            yield (value, vehicle)\n</code></pre>"},{"location":"autoapi/usmlap/analysis/sweep_1d/#usmlap.analysis.sweep_1d.SweepSettings.get_vehicles","title":"<code>get_vehicles(baseline_vehicle)</code>","text":"<p>Generate a list of vehicles for a sweep.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_vehicle</code> <code>Vehicle</code> <p>The baseline vehicle to use.</p> required <p>Yields:</p> Name Type Description <code>result</code> <code>tuple[float, Vehicle]</code> <p>A tuple containing the modified parameter value and the corresponding vehicle.</p> Source code in <code>src\\usmlap\\analysis\\sweep_1d.py</code> <pre><code>def get_vehicles(\n    self, baseline_vehicle: Vehicle\n) -&gt; Generator[tuple[float, Vehicle]]:\n    \"\"\"\n    Generate a list of vehicles for a sweep.\n\n    Args:\n        baseline_vehicle (Vehicle): The baseline vehicle to use.\n\n    Yields:\n        result (tuple[float, Vehicle]):\n            A tuple containing the modified parameter value\n            and the corresponding vehicle.\n    \"\"\"\n    for value in self.values:\n        vehicle = get_new_vehicle(baseline_vehicle, self.parameter, value)\n        yield (value, vehicle)\n</code></pre>"},{"location":"autoapi/usmlap/analysis/sweep_1d/#usmlap.analysis.sweep_1d.sweep_1d","title":"<code>sweep_1d(baseline_vehicle, sweep_settings, competition_settings)</code>","text":"<p>Carry out a 1D sweep of a parameter.</p> <p>Parameters:</p> Name Type Description Default <code>baseline_vehicle</code> <code>Vehicle</code> <p>The vehicle to simulate.</p> required <code>sweep_settings</code> <code>SweepSettings</code> <p>Settings for the sweep.</p> required <code>competition_settings</code> <code>CompetitionSettings</code> <p>Settings for the competition.</p> required <p>Returns:</p> Name Type Description <code>sweep_results</code> <code>SweepResults</code> <p>The results of the sweep.</p> Source code in <code>src\\usmlap\\analysis\\sweep_1d.py</code> <pre><code>def sweep_1d(\n    baseline_vehicle: Vehicle,\n    sweep_settings: SweepSettings,\n    competition_settings: CompetitionSettings,\n) -&gt; SweepResults:\n    \"\"\"\n    Carry out a 1D sweep of a parameter.\n\n    Args:\n        baseline_vehicle (Vehicle): The vehicle to simulate.\n        sweep_settings (SweepSettings): Settings for the sweep.\n        competition_settings (CompetitionSettings):\n            Settings for the competition.\n\n    Returns:\n        sweep_results (SweepResults): The results of the sweep.\n    \"\"\"\n    sweep_results = SweepResults(parameter=sweep_settings.parameter)\n\n    for value, vehicle in sweep_settings.get_vehicles(baseline_vehicle):\n        logging.info(\n            f\"Simulating vehicle with {sweep_settings.parameter.name} = {value}\"\n        )\n        results = simulate_competition(vehicle, competition_settings)\n        points = calculate_points(results)\n        sweep_results.data[value] = points.total\n\n    return sweep_results\n</code></pre>"},{"location":"autoapi/usmlap/plot/","title":"plot","text":"<p>This package contains functions for plotting graphs of results.</p>"},{"location":"autoapi/usmlap/plot/apex/","title":"apex","text":"<p>This module contains functions for plotting velocity profiles and apexes.</p>"},{"location":"autoapi/usmlap/plot/apex/#usmlap.plot.apex.plot_apexes","title":"<code>plot_apexes(solution)</code>","text":"<p>Plot a velocity profile, with apexes highlighted.</p> Source code in <code>src\\usmlap\\plot\\apex.py</code> <pre><code>def plot_apexes(solution: Solution) -&gt; None:\n    \"\"\"\n    Plot a velocity profile, with apexes highlighted.\n    \"\"\"\n\n    position = Position.get_values(solution)\n    velocity = Velocity.get_values(solution)\n    maximum_velocity = MaximumVelocity.get_values(solution)\n\n    apex_indices = solution.get_sorted_apex_indices()\n    apex_solution = solution.get_subset(apex_indices)\n\n    apex_velocity = Velocity.get_values(apex_solution)\n    apex_position = Position.get_values(apex_solution)\n\n    fig, ax = plt.subplots()\n    fig.suptitle(\"Solution\")\n\n    ax.plot(position, maximum_velocity, color=\"lightblue\")\n    ax.plot(position, velocity, color=\"blue\")\n    ax.scatter(apex_position, apex_velocity, color=\"red\")\n\n    for i in range(len(apex_position)):\n        plt.text(apex_position[i] + 5, apex_velocity[i], str(i + 1))\n\n    ax.set_xlabel(Position.get_label())\n    ax.set_ylabel(Velocity.get_label())\n    ax.set_title(\"Maximum Velocity\")\n    ax.grid()\n\n    plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/plot/channels/","title":"channels","text":"<p>This module contains functions for plotting traces of channels.</p>"},{"location":"autoapi/usmlap/plot/channels/#usmlap.plot.channels.plot_channels","title":"<code>plot_channels(solutions, channels, x_axis='Position')</code>","text":"<p>Plot traces of the specified data channels.</p> <p>Parameters:</p> Name Type Description Default <code>solutions</code> <code>list[Solution]</code> <p>The solution to plot.</p> required <code>channels</code> <code>list[str]</code> <p>The names of the data channels to plot.</p> required <code>x_axis</code> <code>Literal['Position', 'Time']</code> <p>The function to plot on the x-axis</p> <code>'Position'</code> Source code in <code>src\\usmlap\\plot\\channels.py</code> <pre><code>@show_after_plotting\ndef plot_channels(\n    solutions: list[Solution],\n    channels: list[str],\n    x_axis: X_AXIS_OPTIONS = \"Position\",\n) -&gt; None:\n    \"\"\"\n    Plot traces of the specified data channels.\n\n    Args:\n        solutions (list[Solution]): The solution to plot.\n        channels (list[str]): The names of the data channels to plot.\n        x_axis (Literal[\"Position\", \"Time\"]): The function to plot on the x-axis\n    \"\"\"\n\n    fig, axs = plt.subplots(nrows=len(channels), sharex=True)\n    fig.suptitle(\"Solution\")\n\n    x_channel = X_AXIS_CHANNELS[x_axis]\n    axs[-1].set_xlabel(x_channel.get_label())\n\n    y_channels = [get_channel(channel_name) for channel_name in channels]\n    for i, channel in enumerate(y_channels):\n        axs[i].set_ylabel(channel.get_label())\n        axs[i].grid()\n\n    for solution in solutions:\n        x_data = x_channel.get_values(solution)\n        for i, channel in enumerate(y_channels):\n            y_data = channel.get_values(solution)\n            axs[i].plot(x_data, y_data)\n            axs[i].set_ylabel(channel.get_label())\n            axs[i].grid()\n</code></pre>"},{"location":"autoapi/usmlap/plot/common/","title":"common","text":"<p>This submodule contains functions shared throughout the graph module.</p>"},{"location":"autoapi/usmlap/plot/common/#usmlap.plot.common.show_after_plotting","title":"<code>show_after_plotting(plot_function)</code>","text":"<p>Decorator which calls plt.show() after the wrapped function.</p> <p>Use to automatically display graphs after plotting.</p> Source code in <code>src\\usmlap\\plot\\common.py</code> <pre><code>def show_after_plotting(plot_function: PlotFunction) -&gt; PlotFunction:\n    \"\"\"\n    Decorator which calls plt.show() after the wrapped function.\n\n    Use to automatically display graphs after plotting.\n    \"\"\"\n\n    @wraps(plot_function)\n    def wrapper(*args: tuple[Any, ...], **kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"Wrapper function.\"\"\"\n        plot_function(*args, **kwargs)\n        plt.show()\n\n    return wrapper\n</code></pre>"},{"location":"autoapi/usmlap/plot/ggv/","title":"ggv","text":"<p>This module contains functions for plotting GG and GGV scatter plots.</p>"},{"location":"autoapi/usmlap/plot/ggv/#usmlap.plot.ggv.plot_gg","title":"<code>plot_gg(solution)</code>","text":"<p>Create a scatter plot of lateral and longitudinal acceleration.</p> Source code in <code>src\\usmlap\\plot\\ggv.py</code> <pre><code>def plot_gg(solution: Solution) -&gt; None:\n    \"\"\"\n    Create a scatter plot of lateral and longitudinal acceleration.\n    \"\"\"\n\n    _, ax = plt.subplots()\n\n    lateral = LateralAcceleration.get_values(solution)\n    longitudinal = LongitudinalAcceleration.get_values(solution)\n\n    ax.scatter(lateral, longitudinal)\n\n    ax.set_xlabel(LateralAcceleration.get_label())\n    ax.set_ylabel(LongitudinalAcceleration.get_label())\n    ax.set_title(\"GG Plot\")\n    ax.grid()\n\n    plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/plot/ggv/#usmlap.plot.ggv.plot_ggv","title":"<code>plot_ggv(solution)</code>","text":"<p>Create a 3D scatter plot of velocity, lateral and longitudinal acceleration.</p> Source code in <code>src\\usmlap\\plot\\ggv.py</code> <pre><code>def plot_ggv(solution: Solution) -&gt; None:\n    \"\"\"\n    Create a 3D scatter plot of velocity, lateral and longitudinal acceleration.\n    \"\"\"\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection=\"3d\")  # type: ignore\n\n    lateral = LateralAcceleration.get_values(solution)\n    longitudinal = LongitudinalAcceleration.get_values(solution)\n    velocity = Velocity.get_values(solution)\n\n    ax.scatter(lateral, longitudinal, velocity)\n\n    ax.set_xlabel(LateralAcceleration.get_label())\n    ax.set_ylabel(LongitudinalAcceleration.get_label())\n    ax.set_zlabel(Velocity.get_label())\n    ax.set_title(\"GG Plot\")\n    ax.grid()\n\n    plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/plot/ggv/#usmlap.plot.ggv.plot_velocity_acceleration","title":"<code>plot_velocity_acceleration(solution)</code>","text":"<p>Create a scatter plot of velocity and longitudinal acceleration.</p> Source code in <code>src\\usmlap\\plot\\ggv.py</code> <pre><code>def plot_velocity_acceleration(solution: Solution) -&gt; None:\n    \"\"\"\n    Create a scatter plot of velocity and longitudinal acceleration.\n    \"\"\"\n\n    _, ax = plt.subplots()\n\n    velocity = Velocity.get_values(solution)\n    longitudinal = LongitudinalAcceleration.get_values(solution)\n\n    ax.scatter(velocity, longitudinal)\n\n    ax.set_xlabel(Velocity.get_label())\n    ax.set_ylabel(LongitudinalAcceleration.get_label())\n    ax.set_title(\"Velocity - Acceleration\")\n    ax.grid()\n\n    plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/simulation/","title":"simulation","text":""},{"location":"autoapi/usmlap/simulation/competition/","title":"competition","text":"<p>This module contains code for simulating a complete Formula Student competition.</p>"},{"location":"autoapi/usmlap/simulation/competition/#usmlap.simulation.competition.CompetitionResults","title":"<code>CompetitionResults</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>The results of a competition simulation</p> <p>Attributes:</p> Name Type Description <code>acceleration</code> <code>Solution</code> <p>The solution to the acceleration event.</p> <code>skidpad</code> <code>Solution</code> <p>The solution to the skidpad event.</p> <code>autocross</code> <code>Solution</code> <p>The solution to the autocross event.</p> <code>endurance</code> <code>Solution</code> <p>The solution to the endurance event.</p> Source code in <code>src\\usmlap\\simulation\\competition.py</code> <pre><code>@dataclass\nclass CompetitionResults(object):\n    \"\"\"\n    The results of a competition simulation\n\n    Attributes:\n        acceleration (Solution): The solution to the acceleration event.\n        skidpad (Solution): The solution to the skidpad event.\n        autocross (Solution): The solution to the autocross event.\n        endurance (Solution): The solution to the endurance event.\n    \"\"\"\n\n    acceleration: Solution\n    skidpad: Solution\n    autocross: Solution\n    endurance: Solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/competition/#usmlap.simulation.competition.CompetitionSettings","title":"<code>CompetitionSettings</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Settings for a complete competition simulation.</p> <p>Attributes:</p> Name Type Description <code>autocross_track</code> <code>TrackData</code> <p>The track to use for the autocross event.</p> <code>simulation_settings</code> <code>SimulationSettings</code> <p>Settings for each simulation.</p> Source code in <code>src\\usmlap\\simulation\\competition.py</code> <pre><code>@dataclass\nclass CompetitionSettings(object):\n    \"\"\"\n    Settings for a complete competition simulation.\n\n    Attributes:\n        autocross_track (TrackData): The track to use for the autocross event.\n        simulation_settings (SimulationSettings): Settings for each simulation.\n    \"\"\"\n\n    autocross_track: TrackData\n    simulation_settings: SimulationSettings\n</code></pre>"},{"location":"autoapi/usmlap/simulation/competition/#usmlap.simulation.competition.simulate_acceleration","title":"<code>simulate_acceleration(vehicle, settings)</code>","text":"<p>Simulate the acceleration event.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>Vehicle</code> <p>The vehicle to simulate.</p> required <code>settings</code> <code>CompetitionSettings</code> <p>Settings for the simulation.</p> required <p>Returns:</p> Name Type Description <code>solution</code> <code>Solution</code> <p>The results of the simulation.</p> Source code in <code>src\\usmlap\\simulation\\competition.py</code> <pre><code>def simulate_acceleration(\n    vehicle: Vehicle, settings: CompetitionSettings\n) -&gt; Solution:\n    \"\"\"\n    Simulate the acceleration event.\n\n    Args:\n        vehicle (Vehicle): The vehicle to simulate.\n        settings (CompetitionSettings): Settings for the simulation.\n\n    Returns:\n        solution (Solution): The results of the simulation.\n    \"\"\"\n    logging.info(\"Simulating acceleration event...\")\n    track_data = load_track_from_spreadsheet(ACCELERATION_TRACK)\n    mesh = MeshGenerator(resolution=1).generate_mesh(track_data)\n    solution = simulate(\n        vehicle=vehicle, track_mesh=mesh, settings=settings.simulation_settings\n    )\n    return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/competition/#usmlap.simulation.competition.simulate_autocross","title":"<code>simulate_autocross(vehicle, settings)</code>","text":"<p>Simulate the autocross event.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>Vehicle</code> <p>The vehicle to simulate.</p> required <code>settings</code> <code>CompetitionSettings</code> <p>Settings for the simulation.</p> required <p>Returns:</p> Name Type Description <code>solution</code> <code>Solution</code> <p>The results of the simulation.</p> Source code in <code>src\\usmlap\\simulation\\competition.py</code> <pre><code>def simulate_autocross(\n    vehicle: Vehicle, settings: CompetitionSettings\n) -&gt; Solution:\n    \"\"\"\n    Simulate the autocross event.\n\n    Args:\n        vehicle (Vehicle): The vehicle to simulate.\n        settings (CompetitionSettings): Settings for the simulation.\n\n    Returns:\n        solution (Solution): The results of the simulation.\n    \"\"\"\n    logging.info(\"Simulating autocross event...\")\n    track_data = settings.autocross_track\n    mesh = MeshGenerator(resolution=1).generate_mesh(track_data)\n    solution = simulate(\n        vehicle=vehicle, track_mesh=mesh, settings=settings.simulation_settings\n    )\n    return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/competition/#usmlap.simulation.competition.simulate_competition","title":"<code>simulate_competition(vehicle, settings)</code>","text":"<p>Simulates all four Formula Student events: acceleration, skidpad, autocross, and endurance.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>Vehicle</code> <p>The vehicle to simulate.</p> required <code>settings</code> <code>CompetitionSettings</code> <p>Settings for the simulation.</p> required <p>Returns:</p> Name Type Description <code>results</code> <code>CompetitionResults</code> <p>The results of all four simulations.</p> Source code in <code>src\\usmlap\\simulation\\competition.py</code> <pre><code>def simulate_competition(\n    vehicle: Vehicle, settings: CompetitionSettings\n) -&gt; CompetitionResults:\n    \"\"\"\n    Simulates all four Formula Student events:\n    acceleration, skidpad, autocross, and endurance.\n\n    Args:\n        vehicle (Vehicle): The vehicle to simulate.\n        settings (CompetitionSettings): Settings for the simulation.\n\n    Returns:\n        results (CompetitionResults): The results of all four simulations.\n    \"\"\"\n    return CompetitionResults(\n        acceleration=simulate_acceleration(vehicle, settings),\n        skidpad=simulate_skidpad(vehicle, settings),\n        autocross=simulate_autocross(vehicle, settings),\n        endurance=simulate_endurance(vehicle, settings),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/simulation/competition/#usmlap.simulation.competition.simulate_endurance","title":"<code>simulate_endurance(vehicle, settings)</code>","text":"<p>Simulate the endurance event.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>Vehicle</code> <p>The vehicle to simulate.</p> required <code>settings</code> <code>CompetitionSettings</code> <p>Settings for the simulation.</p> required <p>Returns:</p> Name Type Description <code>solution</code> <code>Solution</code> <p>The results of the simulation.</p> Source code in <code>src\\usmlap\\simulation\\competition.py</code> <pre><code>def simulate_endurance(\n    vehicle: Vehicle, settings: CompetitionSettings\n) -&gt; Solution:\n    \"\"\"\n    Simulate the endurance event.\n\n    Args:\n        vehicle (Vehicle): The vehicle to simulate.\n        settings (CompetitionSettings): Settings for the simulation.\n\n    Returns:\n        solution (Solution): The results of the simulation.\n    \"\"\"\n    logging.info(\"Simulating endurance event...\")\n    track_data = settings.autocross_track\n    mesh = (\n        MeshGenerator(resolution=1)\n        .generate_mesh(track_data)\n        .generate_endurance_mesh()\n    )\n    solution = simulate(\n        vehicle=vehicle, track_mesh=mesh, settings=settings.simulation_settings\n    )\n    return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/competition/#usmlap.simulation.competition.simulate_skidpad","title":"<code>simulate_skidpad(vehicle, settings)</code>","text":"<p>Simulate the skidpad event.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>Vehicle</code> <p>The vehicle to simulate.</p> required <code>settings</code> <code>CompetitionSettings</code> <p>Settings for the simulation.</p> required <p>Returns:</p> Name Type Description <code>solution</code> <code>Solution</code> <p>The results of the simulation.</p> Source code in <code>src\\usmlap\\simulation\\competition.py</code> <pre><code>def simulate_skidpad(\n    vehicle: Vehicle, settings: CompetitionSettings\n) -&gt; Solution:\n    \"\"\"\n    Simulate the skidpad event.\n\n    Args:\n        vehicle (Vehicle): The vehicle to simulate.\n        settings (CompetitionSettings): Settings for the simulation.\n\n    Returns:\n        solution (Solution): The results of the simulation.\n    \"\"\"\n    logging.info(\"Simulating skidpad event...\")\n    track_data = load_track_from_spreadsheet(SKIDPAD_TRACK)\n    mesh = MeshGenerator(resolution=1).generate_mesh(track_data)\n    solution = simulate(\n        vehicle=vehicle, track_mesh=mesh, settings=settings.simulation_settings\n    )\n    return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/environment/","title":"environment","text":"<p>This module models the environment in which the vehicle is simulated.</p>"},{"location":"autoapi/usmlap/simulation/environment/#usmlap.simulation.environment.Environment","title":"<code>Environment</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Environmental variables for the simulation.</p> <p>Attributes:</p> Name Type Description <code>gravity</code> <code>float</code> <p>Acceleration due to gravity (default = 9.81).</p> <code>air_density</code> <code>float</code> <p>The density of the air (default = 1.225).</p> Source code in <code>src\\usmlap\\simulation\\environment.py</code> <pre><code>class Environment(BaseModel):\n    \"\"\"\n    Environmental variables for the simulation.\n\n    Attributes:\n        gravity (float): Acceleration due to gravity (default = 9.81).\n        air_density (float): The density of the air (default = 1.225).\n    \"\"\"\n\n    gravity: float = GRAVITY\n    air_density: float = AIR_DENSITY\n</code></pre>"},{"location":"autoapi/usmlap/simulation/sensitivity/","title":"sensitivity","text":"<p>This module contains code for points sensitivity analysis.</p>"},{"location":"autoapi/usmlap/simulation/sensitivity/#usmlap.simulation.sensitivity.SensitivityAnalysis","title":"<code>SensitivityAnalysis</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for carrying out sensitivity analysis.</p> Source code in <code>src\\usmlap\\simulation\\sensitivity.py</code> <pre><code>@dataclass\nclass SensitivityAnalysis(object):\n    \"\"\"\n    Class for carrying out sensitivity analysis.\n    \"\"\"\n\n    baseline_vehicle: Vehicle\n    parameter: Parameter\n    competition_settings: CompetitionSettings\n\n    @property\n    def baseline_value(self) -&gt; float:\n        return self.parameter.get_value(self.baseline_vehicle)\n\n    @property\n    def parameter_delta(self) -&gt; float:\n        return self.baseline_value * PARAMETER_DELTA_SCALAR\n\n    @property\n    def increased_value_vehicle(self) -&gt; Vehicle:\n        new_value = self.baseline_value + self.parameter_delta\n        return get_new_vehicle(self.baseline_vehicle, self.parameter, new_value)\n\n    @property\n    def decreased_value_vehicle(self) -&gt; Vehicle:\n        new_value = self.baseline_value - self.parameter_delta\n        return get_new_vehicle(self.baseline_vehicle, self.parameter, new_value)\n\n    def get_sensitivity(self) -&gt; float:\n        vehicles = {\n            \"increased\": self.increased_value_vehicle,\n            \"decreased\": self.decreased_value_vehicle,\n        }\n        total_points: dict[str, float] = {}\n\n        for direction, vehicle in vehicles.items():\n            results = simulate_competition(\n                vehicle=vehicle, settings=self.competition_settings\n            )\n            points = calculate_points(results=results)\n            total_points[direction] = points.total\n\n        points_delta = total_points[\"increased\"] - total_points[\"decreased\"]\n        sensitivity = points_delta / (2 * self.parameter_delta)\n        return sensitivity\n</code></pre>"},{"location":"autoapi/usmlap/simulation/simulation/","title":"simulation","text":"<p>This module contains code for running a simulation.</p>"},{"location":"autoapi/usmlap/simulation/simulation/#usmlap.simulation.simulation.SimulationSettings","title":"<code>SimulationSettings</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Settings for a simulation.</p> <p>Attributes:</p> Name Type Description <code>track</code> <code>Mesh</code> <p>The track to simulate.</p> <code>environment</code> <code>Environment</code> <p>Environmental variables for the simulation.</p> <code>vehicle_model</code> <code>VehicleModelInterface</code> <p>The vehicle model to use.</p> <code>solver</code> <code>SolverInterface</code> <p>The solver to use.</p> Source code in <code>src\\usmlap\\simulation\\simulation.py</code> <pre><code>class SimulationSettings(BaseModel):\n    \"\"\"\n    Settings for a simulation.\n\n    Attributes:\n        track (Mesh): The track to simulate.\n        environment (Environment): Environmental variables for the simulation.\n        vehicle_model (VehicleModelInterface): The vehicle model to use.\n        solver (SolverInterface): The solver to use.\n    \"\"\"\n\n    environment: Environment = Environment()\n    vehicle_model: type[VehicleModelInterface] = PointMassVehicleModel\n    solver: type[SolverInterface] = QuasiSteadyStateSolver\n</code></pre>"},{"location":"autoapi/usmlap/simulation/simulation/#usmlap.simulation.simulation.simulate","title":"<code>simulate(vehicle, track_mesh, settings)</code>","text":"<p>Simulate a vehicle driving around a track.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>Vehicle</code> <p>The vehicle to simulate.</p> required <code>settings</code> <code>SimulationSettings</code> <p>Settings for the simulation.</p> required Source code in <code>src\\usmlap\\simulation\\simulation.py</code> <pre><code>def simulate(\n    vehicle: Vehicle, track_mesh: Mesh, settings: SimulationSettings\n) -&gt; Solution:\n    \"\"\"\n    Simulate a vehicle driving around a track.\n\n    Args:\n        vehicle (Vehicle): The vehicle to simulate.\n        settings (SimulationSettings): Settings for the simulation.\n    \"\"\"\n    vehicle_model = settings.vehicle_model(\n        vehicle=vehicle, environment=settings.environment\n    )\n    solver = settings.solver()\n    solution = create_new_solution(track_mesh, vehicle_model)\n    return solver.solve(solution)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/","title":"solution","text":"<p>This module contains code for representing the solution to a simulation.</p>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.Solution","title":"<code>Solution</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>The solution to a simulation.</p> Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>@dataclass\nclass Solution(object):\n    \"\"\"\n    The solution to a simulation.\n    \"\"\"\n\n    nodes: list[SolutionNode]\n    vehicle_model: VehicleModelInterface\n\n    def __post_init__(self) -&gt; None:\n        for i in range(len(self.nodes) - 1):\n            self.nodes[i].next = self.nodes[i + 1]\n            self.nodes[i + 1].previous = self.nodes[i]\n\n    @property\n    def total_time(self) -&gt; float:\n        return sum(node.time for node in self.nodes)\n\n    @property\n    def total_length(self) -&gt; float:\n        return sum(node.length for node in self.nodes)\n\n    @property\n    def average_velocity(self) -&gt; float:\n        return self.total_length / self.total_time\n\n    def evaluate_full_vehicle_state(\n        self, vehicle_model: VehicleModelInterface\n    ) -&gt; None:\n        for node in self.nodes:\n            node.evaluate_vehicle_state(vehicle_model)\n\n    def get_apex_indices(self) -&gt; list[int]:\n        \"\"\"\n        Get a list of apex indices.\n\n        Returns:\n            apex_indices (list[int]): Indices of apexes.\n        \"\"\"\n        return [i for i, node in enumerate(self.nodes) if node.is_apex()]\n\n    def get_sorted_apex_indices(self) -&gt; list[int]:\n        \"\"\"\n        Get a list of apex indices, sorted by maximum velocity from low to high.\n\n        Returns:\n            sorted_apex_indices (list[int]): Indices of apexes.\n        \"\"\"\n        indices = self.get_apex_indices()\n        velocities = [self.nodes[i].maximum_velocity for i in indices]\n        _, sorted_indices = zip(*sorted(zip(velocities, indices)))\n        return list(sorted_indices)\n\n    def get_apexes(self) -&gt; list[SolutionNode]:\n        \"\"\"\n        Get a list of apex nodes.\n\n        Returns:\n            apexes (list[SolutionNode]): Solution nodes which are apexes.\n        \"\"\"\n        return [node for node in self.nodes if node.is_apex()]\n\n    def set_apexes(self, apexes: list[int]) -&gt; None:\n        for i in apexes:\n            self.nodes[i].add_apex()\n\n    def get_subset(self, indices: list[int]) -&gt; Solution:\n        \"\"\"\n        Return a new solution containing only the nodes at the given indices.\n\n        Args:\n            indices (list[int]):\n                The indices of the nodes to include in the new solution.\n\n        Returns:\n            new_solution (Solution): The new solution.\n        \"\"\"\n        new_solution = copy(self)\n        new_solution.nodes = [self.nodes[i] for i in indices]\n        return new_solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.Solution.get_apex_indices","title":"<code>get_apex_indices()</code>","text":"<p>Get a list of apex indices.</p> <p>Returns:</p> Name Type Description <code>apex_indices</code> <code>list[int]</code> <p>Indices of apexes.</p> Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def get_apex_indices(self) -&gt; list[int]:\n    \"\"\"\n    Get a list of apex indices.\n\n    Returns:\n        apex_indices (list[int]): Indices of apexes.\n    \"\"\"\n    return [i for i, node in enumerate(self.nodes) if node.is_apex()]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.Solution.get_apexes","title":"<code>get_apexes()</code>","text":"<p>Get a list of apex nodes.</p> <p>Returns:</p> Name Type Description <code>apexes</code> <code>list[SolutionNode]</code> <p>Solution nodes which are apexes.</p> Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def get_apexes(self) -&gt; list[SolutionNode]:\n    \"\"\"\n    Get a list of apex nodes.\n\n    Returns:\n        apexes (list[SolutionNode]): Solution nodes which are apexes.\n    \"\"\"\n    return [node for node in self.nodes if node.is_apex()]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.Solution.get_sorted_apex_indices","title":"<code>get_sorted_apex_indices()</code>","text":"<p>Get a list of apex indices, sorted by maximum velocity from low to high.</p> <p>Returns:</p> Name Type Description <code>sorted_apex_indices</code> <code>list[int]</code> <p>Indices of apexes.</p> Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def get_sorted_apex_indices(self) -&gt; list[int]:\n    \"\"\"\n    Get a list of apex indices, sorted by maximum velocity from low to high.\n\n    Returns:\n        sorted_apex_indices (list[int]): Indices of apexes.\n    \"\"\"\n    indices = self.get_apex_indices()\n    velocities = [self.nodes[i].maximum_velocity for i in indices]\n    _, sorted_indices = zip(*sorted(zip(velocities, indices)))\n    return list(sorted_indices)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.Solution.get_subset","title":"<code>get_subset(indices)</code>","text":"<p>Return a new solution containing only the nodes at the given indices.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>list[int]</code> <p>The indices of the nodes to include in the new solution.</p> required <p>Returns:</p> Name Type Description <code>new_solution</code> <code>Solution</code> <p>The new solution.</p> Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def get_subset(self, indices: list[int]) -&gt; Solution:\n    \"\"\"\n    Return a new solution containing only the nodes at the given indices.\n\n    Args:\n        indices (list[int]):\n            The indices of the nodes to include in the new solution.\n\n    Returns:\n        new_solution (Solution): The new solution.\n    \"\"\"\n    new_solution = copy(self)\n    new_solution.nodes = [self.nodes[i] for i in indices]\n    return new_solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.SolutionNode","title":"<code>SolutionNode</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>The solution at a single node.</p> <p>Attributes:</p> Name Type Description <code>track_node</code> <code>TrackNode</code> <p>The corresponding track node.</p> <code>maximum_velocity</code> <code>float</code> <p>The maximum possible velocity at the node, obtained from the lateral vehicle model.</p> <code>acceleration</code> <code>float</code> <p>The longitudinal acceleration at the node.</p> <code>state_variables</code> <code>StateVariables</code> <p>The state variables at the node.</p> <code>vehicle_state</code> <code>FullVehicleState</code> <p>The state of the vehicle at the node.</p> <code>next</code> <code>Optional[SolutionNode]</code> <p>The next node in the solution (<code>None</code> if this is the final node).</p> <code>previous</code> <code>Optional[SolutionNode]</code> <p>The previous node in the solution (<code>None</code> if this is the first node).</p> <code>length</code> <code>float</code> <p>The length of the track segment.</p> <code>initial_velocity</code> <code>float</code> <p>The velocity at the start of the node.</p> <code>final_velocity</code> <code>float</code> <p>The velocity at the end of the node.</p> <code>average_velocity</code> <code>float</code> <p>The average velocity for the node.</p> <code>longitudinal_acceleration</code> <code>float</code> <p>The longitudinal acceleration for the node.</p> <code>lateral_acceleration</code> <code>float</code> <p>The lateral acceleration for the node.</p> <code>time</code> <code>float</code> <p>The time taken to drive this node.</p> <code>energy_used</code> <code>float</code> <p>The energy used to drive this node.</p> Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>@dataclass\nclass SolutionNode(object):\n    \"\"\"\n    The solution at a single node.\n\n    Attributes:\n        track_node (TrackNode): The corresponding track node.\n        maximum_velocity (float): The maximum possible velocity at the node,\n            obtained from the lateral vehicle model.\n        acceleration (float): The longitudinal acceleration at the node.\n        state_variables (StateVariables): The state variables at the node.\n        vehicle_state (FullVehicleState): The state of the vehicle at the node.\n        next (Optional[SolutionNode]): The next node in the solution\n            (`None` if this is the final node).\n        previous (Optional[SolutionNode]): The previous node in the solution\n            (`None` if this is the first node).\n        length (float): The length of the track segment.\n        initial_velocity (float): The velocity at the start of the node.\n        final_velocity (float): The velocity at the end of the node.\n        average_velocity (float): The average velocity for the node.\n        longitudinal_acceleration (float):\n            The longitudinal acceleration for the node.\n        lateral_acceleration (float): The lateral acceleration for the node.\n        time (float): The time taken to drive this node.\n        energy_used (float): The energy used to drive this node.\n    \"\"\"\n\n    track_node: TrackNode\n    maximum_velocity: float = 0\n    _apex: bool = False\n    _initial_velocity: float = 0\n    _final_velocity: float = 0\n    _initial_velocity_anchored: bool = False\n    _final_velocity_anchored: bool = False\n    acceleration: float = 0\n    state_variables: StateVariables = field(\n        default_factory=StateVariables.get_default\n    )\n    vehicle_state: FullVehicleState = field(\n        default_factory=FullVehicleState.get_empty\n    )\n    next: Optional[SolutionNode] = None\n    previous: Optional[SolutionNode] = None\n\n    @property\n    def length(self) -&gt; float:\n        return self.track_node.length\n\n    @property\n    def initial_velocity(self) -&gt; float:\n        return self._initial_velocity\n\n    @property\n    def final_velocity(self) -&gt; float:\n        return self._final_velocity\n\n    @property\n    def average_velocity(self) -&gt; float:\n        return (self.initial_velocity + self.final_velocity) / 2\n\n    @property\n    def longitudinal_acceleration(self) -&gt; float:\n        return (self.final_velocity**2 - self.initial_velocity**2) / (\n            2 * self.length\n        )\n\n    @property\n    def lateral_acceleration(self) -&gt; float:\n        return self.average_velocity**2 * self.track_node.curvature\n\n    @property\n    def time(self) -&gt; float:\n        return self.length / self.average_velocity\n\n    @property\n    def energy_used(self) -&gt; float:\n        return self.vehicle_state.accumulator_power * self.time\n\n    def is_apex(self) -&gt; bool:\n        \"\"\"\n        Check if the node is an apex.\n\n        Returns:\n            is_apex (bool): `True` is the node is an apex, otherwise `False`.\n        \"\"\"\n        return self._apex\n\n    def add_apex(self) -&gt; None:\n        \"\"\"\n        Add the node as an apex.\n        \"\"\"\n        self._apex = True\n\n    def remove_apex(self) -&gt; None:\n        \"\"\"\n        Remove the node as an apex.\n        \"\"\"\n        logging.debug(\"Removing apex\")\n        self._apex = False\n\n    def evaluate_vehicle_state(\n        self, vehicle_model: VehicleModelInterface\n    ) -&gt; None:\n        \"\"\"\n        Evaluate the full state of the vehicle at this node.\n\n        Args:\n            vehicle_model (VehicleModelInterface): The vehicle model to use.\n        \"\"\"\n        self.vehicle_state = vehicle_model.resolve_vehicle_state(\n            self.state_variables, self.track_node, self.average_velocity\n        )\n\n    def set_initial_velocity(self, velocity: float) -&gt; None:\n        \"\"\"\n        Set the velocity at the start of the node.\n        If the initial velocity has been anchored, it will not be modified.\n\n        Args:\n            velocity (float): The initial velocity to be set.\n        \"\"\"\n        if not self._initial_velocity_anchored:\n            self._initial_velocity = velocity\n\n    def set_final_velocity(self, velocity: float) -&gt; None:\n        \"\"\"\n        Set the velocity at the end of the node.\n        If the final velocity has been anchored, it will not be modified.\n\n        Args:\n            velocity (float): The final velocity to be set.\n        \"\"\"\n        if not self._final_velocity_anchored:\n            self._final_velocity = velocity\n\n    def anchor_initial_velocity(self, velocity: float) -&gt; None:\n        \"\"\"\n        Anchor the initial velocity of this node.\n        It can no longer be modified.\n\n        Args:\n            velocity (float): The initial velocity to be set.\n        \"\"\"\n        self.set_initial_velocity(velocity)\n        self._initial_velocity_anchored = True\n\n    def anchor_final_velocity(self, velocity: float) -&gt; None:\n        \"\"\"\n        Anchor the final velocity of this node.\n        It can no longer be modified.\n\n        Args:\n            velocity (float): The final velocity to be set.\n        \"\"\"\n        self.set_final_velocity(velocity)\n        self._final_velocity_anchored = True\n\n    def update_state_variables(self, state_variables: StateVariables) -&gt; None:\n        self.state_variables = state_variables\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.SolutionNode.add_apex","title":"<code>add_apex()</code>","text":"<p>Add the node as an apex.</p> Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def add_apex(self) -&gt; None:\n    \"\"\"\n    Add the node as an apex.\n    \"\"\"\n    self._apex = True\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.SolutionNode.anchor_final_velocity","title":"<code>anchor_final_velocity(velocity)</code>","text":"<p>Anchor the final velocity of this node. It can no longer be modified.</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>float</code> <p>The final velocity to be set.</p> required Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def anchor_final_velocity(self, velocity: float) -&gt; None:\n    \"\"\"\n    Anchor the final velocity of this node.\n    It can no longer be modified.\n\n    Args:\n        velocity (float): The final velocity to be set.\n    \"\"\"\n    self.set_final_velocity(velocity)\n    self._final_velocity_anchored = True\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.SolutionNode.anchor_initial_velocity","title":"<code>anchor_initial_velocity(velocity)</code>","text":"<p>Anchor the initial velocity of this node. It can no longer be modified.</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>float</code> <p>The initial velocity to be set.</p> required Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def anchor_initial_velocity(self, velocity: float) -&gt; None:\n    \"\"\"\n    Anchor the initial velocity of this node.\n    It can no longer be modified.\n\n    Args:\n        velocity (float): The initial velocity to be set.\n    \"\"\"\n    self.set_initial_velocity(velocity)\n    self._initial_velocity_anchored = True\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.SolutionNode.evaluate_vehicle_state","title":"<code>evaluate_vehicle_state(vehicle_model)</code>","text":"<p>Evaluate the full state of the vehicle at this node.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle_model</code> <code>VehicleModelInterface</code> <p>The vehicle model to use.</p> required Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def evaluate_vehicle_state(\n    self, vehicle_model: VehicleModelInterface\n) -&gt; None:\n    \"\"\"\n    Evaluate the full state of the vehicle at this node.\n\n    Args:\n        vehicle_model (VehicleModelInterface): The vehicle model to use.\n    \"\"\"\n    self.vehicle_state = vehicle_model.resolve_vehicle_state(\n        self.state_variables, self.track_node, self.average_velocity\n    )\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.SolutionNode.is_apex","title":"<code>is_apex()</code>","text":"<p>Check if the node is an apex.</p> <p>Returns:</p> Name Type Description <code>is_apex</code> <code>bool</code> <p><code>True</code> is the node is an apex, otherwise <code>False</code>.</p> Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def is_apex(self) -&gt; bool:\n    \"\"\"\n    Check if the node is an apex.\n\n    Returns:\n        is_apex (bool): `True` is the node is an apex, otherwise `False`.\n    \"\"\"\n    return self._apex\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.SolutionNode.remove_apex","title":"<code>remove_apex()</code>","text":"<p>Remove the node as an apex.</p> Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def remove_apex(self) -&gt; None:\n    \"\"\"\n    Remove the node as an apex.\n    \"\"\"\n    logging.debug(\"Removing apex\")\n    self._apex = False\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.SolutionNode.set_final_velocity","title":"<code>set_final_velocity(velocity)</code>","text":"<p>Set the velocity at the end of the node. If the final velocity has been anchored, it will not be modified.</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>float</code> <p>The final velocity to be set.</p> required Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def set_final_velocity(self, velocity: float) -&gt; None:\n    \"\"\"\n    Set the velocity at the end of the node.\n    If the final velocity has been anchored, it will not be modified.\n\n    Args:\n        velocity (float): The final velocity to be set.\n    \"\"\"\n    if not self._final_velocity_anchored:\n        self._final_velocity = velocity\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.SolutionNode.set_initial_velocity","title":"<code>set_initial_velocity(velocity)</code>","text":"<p>Set the velocity at the start of the node. If the initial velocity has been anchored, it will not be modified.</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>float</code> <p>The initial velocity to be set.</p> required Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def set_initial_velocity(self, velocity: float) -&gt; None:\n    \"\"\"\n    Set the velocity at the start of the node.\n    If the initial velocity has been anchored, it will not be modified.\n\n    Args:\n        velocity (float): The initial velocity to be set.\n    \"\"\"\n    if not self._initial_velocity_anchored:\n        self._initial_velocity = velocity\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solution/#usmlap.simulation.solution.create_new_solution","title":"<code>create_new_solution(track_mesh, vehicle_model)</code>","text":"<p>Create a new solution from a track mesh and vehicle model.</p> <p>Parameters:</p> Name Type Description Default <code>track_mesh</code> <code>Mesh</code> <p>The track mesh.</p> required <code>vehicle_model</code> <code>VehicleModelInterface</code> <p>The vehicle model.</p> required <p>Returns:</p> Name Type Description <code>solution</code> <code>Solution</code> <p>A blank solution.</p> Source code in <code>src\\usmlap\\simulation\\solution.py</code> <pre><code>def create_new_solution(\n    track_mesh: Mesh, vehicle_model: VehicleModelInterface\n) -&gt; Solution:\n    \"\"\"\n    Create a new solution from a track mesh and vehicle model.\n\n    Args:\n        track_mesh (Mesh): The track mesh.\n        vehicle_model (VehicleModelInterface): The vehicle model.\n\n    Returns:\n        solution (Solution): A blank solution.\n    \"\"\"\n    solution_nodes = [\n        SolutionNode(track_node=track_node) for track_node in track_mesh.nodes\n    ]\n    solution = Solution(nodes=solution_nodes, vehicle_model=vehicle_model)\n    return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/vehicle_state/","title":"vehicle_state","text":"<p>This module defines the variables associated with a vehicle's state.</p>"},{"location":"autoapi/usmlap/simulation/vehicle_state/#usmlap.simulation.vehicle_state.FullVehicleState","title":"<code>FullVehicleState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>The full state of the vehicle at a point.</p> Source code in <code>src\\usmlap\\simulation\\vehicle_state.py</code> <pre><code>@dataclass\nclass FullVehicleState(object):\n    \"\"\"\n    The full state of the vehicle at a point.\n    \"\"\"\n\n    weight: float\n    centripetal_force: float\n    downforce: float\n    drag: float\n    resistive_fx: float\n    required_fy: float\n    normal_force: float\n    normal_loads: FourCorner[float]\n    tyre_attitudes: FourCorner[TyreAttitude]\n    lateral_traction: FourCorner[float]\n    longitudinal_traction: FourCorner[float]\n    motor_speed: float\n    motor_torque: float\n    motor_power: float\n    accumulator_power: float\n    motor_force: float\n\n    @property\n    def total_lateral_traction(self) -&gt; float:\n        return sum(self.lateral_traction)\n\n    @staticmethod\n    def get_empty() -&gt; FullVehicleState:\n        return FullVehicleState(\n            weight=0,\n            centripetal_force=0,\n            downforce=0,\n            drag=0,\n            resistive_fx=0,\n            required_fy=0,\n            normal_force=0,\n            normal_loads=FourCorner([0, 0, 0, 0]),\n            tyre_attitudes=FourCorner(\n                [\n                    TyreAttitude(normal_load=0),\n                    TyreAttitude(normal_load=0),\n                    TyreAttitude(normal_load=0),\n                    TyreAttitude(normal_load=0),\n                ]\n            ),\n            lateral_traction=FourCorner([0, 0, 0, 0]),\n            longitudinal_traction=FourCorner([0, 0, 0, 0]),\n            motor_speed=0,\n            motor_torque=0,\n            motor_power=0,\n            accumulator_power=0,\n            motor_force=0,\n        )\n</code></pre>"},{"location":"autoapi/usmlap/simulation/vehicle_state/#usmlap.simulation.vehicle_state.StateVariables","title":"<code>StateVariables</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>The state of the vehicle at a point.</p> <p>Attributes:</p> Name Type Description <code>state_of_charge</code> <code>float</code> <p>The state of charge of the accumulator. 1 = fully charged, 0 = fully discharged (default = 1).</p> Source code in <code>src\\usmlap\\simulation\\vehicle_state.py</code> <pre><code>@dataclass\nclass StateVariables(object):\n    \"\"\"\n    The state of the vehicle at a point.\n\n    Attributes:\n        state_of_charge (float): The state of charge of the accumulator.\n            1 = fully charged, 0 = fully discharged\n            (default = 1).\n    \"\"\"\n\n    state_of_charge: float = 1\n\n    @staticmethod\n    def get_default() -&gt; StateVariables:\n        \"\"\"\n        Get a state variable object with default values.\n        \"\"\"\n        return StateVariables()\n</code></pre>"},{"location":"autoapi/usmlap/simulation/vehicle_state/#usmlap.simulation.vehicle_state.StateVariables.get_default","title":"<code>get_default()</code>  <code>staticmethod</code>","text":"<p>Get a state variable object with default values.</p> Source code in <code>src\\usmlap\\simulation\\vehicle_state.py</code> <pre><code>@staticmethod\ndef get_default() -&gt; StateVariables:\n    \"\"\"\n    Get a state variable object with default values.\n    \"\"\"\n    return StateVariables()\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/","title":"channels","text":"<p>This package contains modules implementing data channels.</p>"},{"location":"autoapi/usmlap/simulation/channels/#usmlap.simulation.channels.get_channel","title":"<code>get_channel(channel_name)</code>","text":"<p>Get a data channel from its name.</p> <p>Parameters:</p> Name Type Description Default <code>channel_name</code> <code>str</code> <p>The name of the data channel.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If no data channel with the given name exists.</p> <p>Returns:</p> Name Type Description <code>channel</code> <code>type[Channel]</code> <p>A data channel object.</p> Source code in <code>src\\usmlap\\simulation\\channels\\__init__.py</code> <pre><code>def get_channel(channel_name: str) -&gt; type[Channel]:\n    \"\"\"\n    Get a data channel from its name.\n\n    Args:\n        channel_name (str): The name of the data channel.\n\n    Raises:\n        KeyError: If no data channel with the given name exists.\n\n    Returns:\n        channel (type[Channel]): A data channel object.\n    \"\"\"\n    return Channel.get_channel(channel_name)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/channel/","title":"channel","text":"<p>This module defines the interface for data channels.</p>"},{"location":"autoapi/usmlap/simulation/channels/channel/#usmlap.simulation.channels.channel.Channel","title":"<code>Channel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract class representing a data channel.</p> <p>Channels must define the _channel_fcn class method, which returns a ChannelFcn callable. This callable accepts a Solution object, and returns a list of floats corresponding to the values of the channel.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the channel, used to access it from the channel registry.</p> <code>unit</code> <code>Unit</code> <p>The default unit to use when displaying the channel.</p> Source code in <code>src\\usmlap\\simulation\\channels\\channel.py</code> <pre><code>class Channel(ABC):\n    \"\"\"\n    An abstract class representing a data channel.\n\n    Channels must define the _channel_fcn class method,\n    which returns a ChannelFcn callable.\n    This callable accepts a Solution object,\n    and returns a list of floats corresponding to the values of the channel.\n\n    Attributes:\n        name (str): The name of the channel,\n            used to access it from the channel registry.\n        unit (Unit): The default unit to use when displaying the channel.\n    \"\"\"\n\n    _REGISTRY: dict[str, type[Channel]] = {}\n    name: str\n    unit: Unit\n\n    def __init_subclass__(\n        cls: type[Channel], name: str, unit: Unit = Unit.UNITLESS\n    ) -&gt; None:\n        super().__init_subclass__()\n        cls._REGISTRY[name] = cls\n        cls.name = name\n        cls.unit = unit\n\n    def __new__(cls, solution: Solution) -&gt; list[float]:\n        \"\"\"Overwrite the __new__ method to allow for static calls.\"\"\"\n        return cls._channel_fcn()(solution)\n\n    @classmethod\n    def get_values(\n        cls,\n        solution: Solution,\n        unit: Optional[Unit] = None,\n        indices: Optional[list[int]] = None,\n    ) -&gt; list[float]:\n        \"\"\"\n        Extract a list of values from a solution.\n\n        The values are converted to the channel's units.\n\n        Args:\n            solution (Solution): A solution object.\n            unit (Unit): The unit to convert the values to.\n                If not specified, the channel's default unit is used.\n                (default = None)\n\n        Returns:\n            values (list[float]): The values of the corresponding data channel.\n        \"\"\"\n\n        if unit is None:\n            unit = cls.unit\n        else:\n            error_message = (\n                f\"Unit '{unit}' of quantity '{unit.quantity}' does not match \"\n                f\"the quantity '{cls.unit.quantity}' for channel '{cls.name}'.\"\n            )\n            assert unit.quantity == cls.unit.quantity, error_message\n\n        if indices is not None:\n            solution = solution.get_subset(indices)\n\n        si_values = cls._channel_fcn()(solution)\n        return [unit.convert(value) for value in si_values]\n\n    @classmethod\n    def get_channel(cls, channel_name: str) -&gt; type[Channel]:\n        \"\"\"\n        Get a data channel from its name.\n\n        Args:\n            channel_name (str): The name of the data channel.\n\n        Raises:\n            KeyError: If no data channel with the given name exists.\n\n        Returns:\n            channel (type[Channel]): A data channel object.\n        \"\"\"\n        try:\n            return cls._REGISTRY[channel_name]\n        except KeyError:\n            error_message = (\n                f\"Data channel '{channel_name}' not found. \"\n                f\"Available channels: {list(cls._REGISTRY.keys())}\"\n            )\n            raise KeyError(error_message)\n\n    @classmethod\n    def list_channels(cls) -&gt; list[str]:\n        \"\"\"\n        Get a list of available data channels.\n\n        Returns:\n            channels (list[str]): Available data channel names.\n        \"\"\"\n        return list(cls._REGISTRY.keys())\n\n    @classmethod\n    def get_label(cls) -&gt; str:\n        \"\"\"\n        Get a label for a graph.\n\n        The label is in the format *\"{name} ({unit})\"*.\n        If the unit is None, the label is in the format *\"{name} (-)\"*.\n\n        Returns:\n            label (str): A label with the name and unit of the channel.\n        \"\"\"\n        if cls.unit:\n            return f\"{cls.name} ({cls.unit})\"\n        else:\n            return f\"{cls.name} (-)\"\n\n    @classmethod\n    @abstractmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        \"\"\"\n        Function that returns the channel values from a solution.\n\n        Returns:\n            channel_fcn (ChannelFcn):\n                A function which takes a solution and returns a list of floats.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/channel/#usmlap.simulation.channels.channel.Channel.__new__","title":"<code>__new__(solution)</code>","text":"<p>Overwrite the new method to allow for static calls.</p> Source code in <code>src\\usmlap\\simulation\\channels\\channel.py</code> <pre><code>def __new__(cls, solution: Solution) -&gt; list[float]:\n    \"\"\"Overwrite the __new__ method to allow for static calls.\"\"\"\n    return cls._channel_fcn()(solution)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/channel/#usmlap.simulation.channels.channel.Channel.get_channel","title":"<code>get_channel(channel_name)</code>  <code>classmethod</code>","text":"<p>Get a data channel from its name.</p> <p>Parameters:</p> Name Type Description Default <code>channel_name</code> <code>str</code> <p>The name of the data channel.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If no data channel with the given name exists.</p> <p>Returns:</p> Name Type Description <code>channel</code> <code>type[Channel]</code> <p>A data channel object.</p> Source code in <code>src\\usmlap\\simulation\\channels\\channel.py</code> <pre><code>@classmethod\ndef get_channel(cls, channel_name: str) -&gt; type[Channel]:\n    \"\"\"\n    Get a data channel from its name.\n\n    Args:\n        channel_name (str): The name of the data channel.\n\n    Raises:\n        KeyError: If no data channel with the given name exists.\n\n    Returns:\n        channel (type[Channel]): A data channel object.\n    \"\"\"\n    try:\n        return cls._REGISTRY[channel_name]\n    except KeyError:\n        error_message = (\n            f\"Data channel '{channel_name}' not found. \"\n            f\"Available channels: {list(cls._REGISTRY.keys())}\"\n        )\n        raise KeyError(error_message)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/channel/#usmlap.simulation.channels.channel.Channel.get_label","title":"<code>get_label()</code>  <code>classmethod</code>","text":"<p>Get a label for a graph.</p> <p>The label is in the format \"{name} ({unit})\". If the unit is None, the label is in the format \"{name} (-)\".</p> <p>Returns:</p> Name Type Description <code>label</code> <code>str</code> <p>A label with the name and unit of the channel.</p> Source code in <code>src\\usmlap\\simulation\\channels\\channel.py</code> <pre><code>@classmethod\ndef get_label(cls) -&gt; str:\n    \"\"\"\n    Get a label for a graph.\n\n    The label is in the format *\"{name} ({unit})\"*.\n    If the unit is None, the label is in the format *\"{name} (-)\"*.\n\n    Returns:\n        label (str): A label with the name and unit of the channel.\n    \"\"\"\n    if cls.unit:\n        return f\"{cls.name} ({cls.unit})\"\n    else:\n        return f\"{cls.name} (-)\"\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/channel/#usmlap.simulation.channels.channel.Channel.get_values","title":"<code>get_values(solution, unit=None, indices=None)</code>  <code>classmethod</code>","text":"<p>Extract a list of values from a solution.</p> <p>The values are converted to the channel's units.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Solution</code> <p>A solution object.</p> required <code>unit</code> <code>Unit</code> <p>The unit to convert the values to. If not specified, the channel's default unit is used. (default = None)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>values</code> <code>list[float]</code> <p>The values of the corresponding data channel.</p> Source code in <code>src\\usmlap\\simulation\\channels\\channel.py</code> <pre><code>@classmethod\ndef get_values(\n    cls,\n    solution: Solution,\n    unit: Optional[Unit] = None,\n    indices: Optional[list[int]] = None,\n) -&gt; list[float]:\n    \"\"\"\n    Extract a list of values from a solution.\n\n    The values are converted to the channel's units.\n\n    Args:\n        solution (Solution): A solution object.\n        unit (Unit): The unit to convert the values to.\n            If not specified, the channel's default unit is used.\n            (default = None)\n\n    Returns:\n        values (list[float]): The values of the corresponding data channel.\n    \"\"\"\n\n    if unit is None:\n        unit = cls.unit\n    else:\n        error_message = (\n            f\"Unit '{unit}' of quantity '{unit.quantity}' does not match \"\n            f\"the quantity '{cls.unit.quantity}' for channel '{cls.name}'.\"\n        )\n        assert unit.quantity == cls.unit.quantity, error_message\n\n    if indices is not None:\n        solution = solution.get_subset(indices)\n\n    si_values = cls._channel_fcn()(solution)\n    return [unit.convert(value) for value in si_values]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/channel/#usmlap.simulation.channels.channel.Channel.list_channels","title":"<code>list_channels()</code>  <code>classmethod</code>","text":"<p>Get a list of available data channels.</p> <p>Returns:</p> Name Type Description <code>channels</code> <code>list[str]</code> <p>Available data channel names.</p> Source code in <code>src\\usmlap\\simulation\\channels\\channel.py</code> <pre><code>@classmethod\ndef list_channels(cls) -&gt; list[str]:\n    \"\"\"\n    Get a list of available data channels.\n\n    Returns:\n        channels (list[str]): Available data channel names.\n    \"\"\"\n    return list(cls._REGISTRY.keys())\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/","title":"functions","text":"<p>This module defines functions for working with data channels.</p>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.add","title":"<code>add(channel_1, channel_2)</code>","text":"<p>Add the values of two channels.</p> <p>Parameters:</p> Name Type Description Default <code>channel_1</code> <code>ChannelFcn</code> <p>A channel.</p> required <code>channel_2</code> <code>ChannelFcn</code> <p>Another channel.</p> required <p>Returns:</p> Name Type Description <code>sum</code> <code>ChannelFcn</code> <p>The sum of the channels.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def add(channel_1: ChannelFcn, channel_2: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Add the values of two channels.\n\n    Args:\n        channel_1 (ChannelFcn): A channel.\n        channel_2 (ChannelFcn): Another channel.\n\n    Returns:\n        sum (ChannelFcn): The sum of the channels.\n    \"\"\"\n\n    def inner(solution: Solution) -&gt; list[float]:\n        \"\"\"Inner function.\"\"\"\n        values_1 = channel_1(solution)\n        values_2 = channel_2(solution)\n        return [a + b for a, b in zip(values_1, values_2)]\n\n    return inner\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.cumulative_sum","title":"<code>cumulative_sum(channel)</code>","text":"<p>Calculate the cumulative sum of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ChannelFcn</code> <p>A channel.</p> required <p>Returns:</p> Name Type Description <code>cumulative_sum</code> <code>ChannelFcn</code> <p>A function that returns the cumulative sum of the channel.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def cumulative_sum(channel: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Calculate the cumulative sum of a channel.\n\n    Args:\n        channel (ChannelFcn): A channel.\n\n    Returns:\n        cumulative_sum (ChannelFcn):\n            A function that returns the cumulative sum of the channel.\n    \"\"\"\n\n    def inner(solution: Solution) -&gt; list[float]:\n        \"\"\"Inner function.\"\"\"\n        values = channel(solution)\n        return list(accumulate(values))\n\n    return inner\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.derivative","title":"<code>derivative(channel, wrt)</code>","text":"<p>Calculate the time derivative of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ChannelFcn</code> <p>A channel to differentiate.</p> required <code>wrt</code> <code>ChannelFcn</code> <p>The channel with differentiate with respect to.</p> required <p>Returns:</p> Name Type Description <code>time_derivative</code> <code>ChannelFcn</code> <p>A function that returns the derivative of the channel.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def derivative(channel: ChannelFcn, wrt: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Calculate the time derivative of a channel.\n\n    Args:\n        channel (ChannelFcn): A channel to differentiate.\n        wrt (ChannelFcn): The channel with differentiate with respect to.\n\n    Returns:\n        time_derivative (ChannelFcn):\n            A function that returns the derivative of the channel.\n    \"\"\"\n\n    return divide(difference(channel), wrt)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.difference","title":"<code>difference(channel)</code>","text":"<p>Compute the difference between consecutive values of a channel.</p> <p>Each value is the average of the forward and backward differences. The first and last values are the true differences. This preserves the length of the channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ChannelFcn</code> <p>A channel to take the difference of.</p> required <p>Returns:</p> Name Type Description <code>difference</code> <code>ChannelFcn</code> <p>The differences of the channel.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def difference(channel: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Compute the difference between consecutive values of a channel.\n\n    Each value is the average of the forward and backward differences.\n    The first and last values are the true differences.\n    This preserves the length of the channel.\n\n    Args:\n        channel (ChannelFcn): A channel to take the difference of.\n\n    Returns:\n        difference (ChannelFcn): The differences of the channel.\n    \"\"\"\n\n    def inner(solution: Solution) -&gt; list[float]:\n        \"\"\"Inner function.\"\"\"\n        x = channel(solution)\n        true_diff = [x[i + 1] - x[i] for i in range(len(x) - 1)]\n        average_diff = [\n            0.5 * (true_diff[i + 1] + true_diff[i])\n            for i in range(len(true_diff) - 1)\n        ]\n        return [true_diff[0], *average_diff, true_diff[-1]]\n\n    return inner\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.divide","title":"<code>divide(channel_1, channel_2)</code>","text":"<p>Perform element-wise division of two channels.</p> <p>Parameters:</p> Name Type Description Default <code>channel_1</code> <code>ChannelFcn</code> <p>A channel to be divided.</p> required <code>channel_2</code> <code>ChannelFcn</code> <p>Another channel to divide by.</p> required <p>Returns:</p> Name Type Description <code>division</code> <code>ChannelFcn</code> <p>A function that returns the division of the channels.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def divide(channel_1: ChannelFcn, channel_2: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Perform element-wise division of two channels.\n\n    Args:\n        channel_1 (ChannelFcn): A channel to be divided.\n        channel_2 (ChannelFcn): Another channel to divide by.\n\n    Returns:\n        division (ChannelFcn):\n            A function that returns the division of the channels.\n    \"\"\"\n\n    def inner(solution: Solution) -&gt; list[float]:\n        \"\"\"Inner function.\"\"\"\n        values_1 = channel_1(solution)\n        values_2 = channel_2(solution)\n        return [v1 / v2 for v1, v2 in zip(values_1, values_2)]\n\n    return inner\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.hypotenuse","title":"<code>hypotenuse(channel_1, channel_2)</code>","text":"<p>Compute the hypotenuse of a right triangle.</p> <p>Parameters:</p> Name Type Description Default <code>channel_1</code> <code>ChannelFcn</code> <p>A channel.</p> required <code>channel_2</code> <code>ChannelFcn</code> <p>Another channel.</p> required <p>Returns:</p> Name Type Description <code>hypotenuse</code> <code>ChannelFcn</code> <p>A function that returns the length of the hypotenuse of a triange formed by the two channels.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def hypotenuse(channel_1: ChannelFcn, channel_2: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Compute the hypotenuse of a right triangle.\n\n    Args:\n        channel_1 (ChannelFcn): A channel.\n        channel_2 (ChannelFcn): Another channel.\n\n    Returns:\n        hypotenuse (ChannelFcn):\n            A function that returns the length of the hypotenuse\n            of a triange formed by the two channels.\n    \"\"\"\n\n    return square_root(add(square(channel_1), square(channel_2)))\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.integral","title":"<code>integral(channel, wrt)</code>","text":"<p>Calculate the integral of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ChannelFcn</code> <p>A channel to integrate.</p> required <code>wrt</code> <code>ChannelFcn</code> <p>The channel to integrate with respect to.</p> required <p>Returns:</p> Name Type Description <code>integral</code> <code>ChannelFcn</code> <p>A function that returns the integral of the channel.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def integral(channel: ChannelFcn, wrt: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Calculate the integral of a channel.\n\n    Args:\n        channel (ChannelFcn): A channel to integrate.\n        wrt (ChannelFcn): The channel to integrate with respect to.\n\n    Returns:\n        integral (ChannelFcn):\n            A function that returns the integral of the channel.\n    \"\"\"\n\n    return cumulative_sum(product(channel, wrt))\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.negate","title":"<code>negate(channel)</code>","text":"<p>Perform element-wise negation of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ChannelFcn</code> <p>A channel.</p> required <p>Returns:</p> Name Type Description <code>negation</code> <code>ChannelFcn</code> <p>A function that returns the negation of the channel.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def negate(channel: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Perform element-wise negation of a channel.\n\n    Args:\n        channel (ChannelFcn): A channel.\n\n    Returns:\n        negation (ChannelFcn):\n            A function that returns the negation of the channel.\n    \"\"\"\n\n    def inner(solution: Solution) -&gt; list[float]:\n        \"\"\"Inner function.\"\"\"\n        values = channel(solution)\n        return [-v for v in values]\n\n    return inner\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.power","title":"<code>power(channel, exponent)</code>","text":"<p>Raise the values of a channel to a power.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ChannelFcn</code> <p>A channel.</p> required <code>exponent</code> <code>float</code> <p>The exponent to raise the channel to.</p> required <p>Returns:</p> Name Type Description <code>results</code> <code>ChannelFcn</code> <p>The channel raised to the exponent.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def power(channel: ChannelFcn, exponent: float) -&gt; ChannelFcn:\n    \"\"\"\n    Raise the values of a channel to a power.\n\n    Args:\n        channel (ChannelFcn): A channel.\n        exponent (float): The exponent to raise the channel to.\n\n    Returns:\n        results (ChannelFcn): The channel raised to the exponent.\n    \"\"\"\n\n    def inner(solution: Solution) -&gt; list[float]:\n        \"\"\"Inner function.\"\"\"\n        values = channel(solution)\n        return [v**exponent for v in values]\n\n    return inner\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.product","title":"<code>product(channel_1, channel_2)</code>","text":"<p>Perform element-wise multiplication of two channels.</p> <p>Parameters:</p> Name Type Description Default <code>channel_1</code> <code>ChannelFcn</code> <p>A channel.</p> required <code>channel_2</code> <code>ChannelFcn</code> <p>Another channel.</p> required <p>Returns:</p> Name Type Description <code>product</code> <code>ChannelFcn</code> <p>A function that returns the product of the channels.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def product(channel_1: ChannelFcn, channel_2: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Perform element-wise multiplication of two channels.\n\n    Args:\n        channel_1 (ChannelFcn): A channel.\n        channel_2 (ChannelFcn): Another channel.\n\n    Returns:\n        product (ChannelFcn):\n            A function that returns the product of the channels.\n    \"\"\"\n\n    def inner(solution: Solution) -&gt; list[float]:\n        \"\"\"Inner function.\"\"\"\n        values_1 = channel_1(solution)\n        values_2 = channel_2(solution)\n        return [v1 * v2 for v1, v2 in zip(values_1, values_2)]\n\n    return inner\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.square","title":"<code>square(channel)</code>","text":"<p>Square the values of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ChannelFcn</code> <p>A channel.</p> required <p>Returns:</p> Name Type Description <code>results</code> <code>ChannelFcn</code> <p>The channel squared.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def square(channel: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Square the values of a channel.\n\n    Args:\n        channel (ChannelFcn): A channel.\n\n    Returns:\n        results (ChannelFcn): The channel squared.\n    \"\"\"\n    return power(channel, 2)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.square_root","title":"<code>square_root(channel)</code>","text":"<p>Calculate the square root of the values of a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>ChannelFcn</code> <p>A channel.</p> required <p>Returns:</p> Name Type Description <code>square_root</code> <code>ChannelFcn</code> <p>The square root of the channel.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def square_root(channel: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Calculate the square root of the values of a channel.\n\n    Args:\n        channel (ChannelFcn): A channel.\n\n    Returns:\n        square_root (ChannelFcn): The square root of the channel.\n    \"\"\"\n\n    def inner(solution: Solution) -&gt; list[float]:\n        \"\"\"Inner function.\"\"\"\n        values = channel(solution)\n        return [math.sqrt(v) for v in values]\n\n    return inner\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/functions/#usmlap.simulation.channels.functions.subtract","title":"<code>subtract(channel_1, channel_2)</code>","text":"<p>Subtract the value of <code>channel_2</code> from <code>channel_1</code>.</p> <p>Parameters:</p> Name Type Description Default <code>channel_1</code> <code>ChannelFcn</code> <p>A channel to subtract from.</p> required <code>channel_2</code> <code>ChannelFcn</code> <p>Another channel to be subtracted.</p> required <p>Returns:</p> Name Type Description <code>result</code> <code>ChannelFcn</code> <p>The difference between the channels.</p> Source code in <code>src\\usmlap\\simulation\\channels\\functions.py</code> <pre><code>def subtract(channel_1: ChannelFcn, channel_2: ChannelFcn) -&gt; ChannelFcn:\n    \"\"\"\n    Subtract the value of `channel_2` from `channel_1`.\n\n    Args:\n        channel_1 (ChannelFcn): A channel to subtract from.\n        channel_2 (ChannelFcn): Another channel to be subtracted.\n\n    Returns:\n        result (ChannelFcn): The difference between the channels.\n    \"\"\"\n    return add(channel_1, negate(channel_2))\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/","title":"library","text":"<p>This module contains definitions of data channels.</p>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.CentripetalForce","title":"<code>CentripetalForce</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Centripetal force acting on the vehicle.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class CentripetalForce(Channel, name=\"Centripetal Force\", unit=Unit.NEWTON):\n    \"\"\"Centripetal force acting on the vehicle.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.vehicle_state.centripetal_force for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.CornerRadius","title":"<code>CornerRadius</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Radius of the track.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class CornerRadius(Channel, name=\"Corner Radius\", unit=Unit.METER):\n    \"\"\"Radius of the track.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.track_node.radius for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.Curvature","title":"<code>Curvature</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Curvature of the track.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class Curvature(Channel, name=\"Curvature\", unit=Unit.PER_METER):\n    \"\"\"Curvature of the track.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.track_node.curvature for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.Distance","title":"<code>Distance</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Length of the track segment.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class Distance(Channel, name=\"Distance\", unit=Unit.METER):\n    \"\"\"Length of the track segment.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.track_node.length for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.Downforce","title":"<code>Downforce</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Aerodynamic downforce.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class Downforce(Channel, name=\"Downforce\", unit=Unit.NEWTON):\n    \"\"\"Aerodynamic downforce.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.vehicle_state.downforce for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.Drag","title":"<code>Drag</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Aerodynamic drag force.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class Drag(Channel, name=\"Drag\", unit=Unit.NEWTON):\n    \"\"\"Aerodynamic drag force.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.vehicle_state.drag for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.DragEnergy","title":"<code>DragEnergy</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Aerodynamic drag energy.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class DragEnergy(Channel, name=\"Drag Energy\", unit=Unit.JOULE):\n    \"\"\"Aerodynamic drag energy.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return fcn.integral(Drag, Distance)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.DragPower","title":"<code>DragPower</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Aerodynamic drag power.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class DragPower(Channel, name=\"Drag Power\", unit=Unit.KILOWATT):\n    \"\"\"Aerodynamic drag power.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return fcn.product(Drag, Velocity)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.LateralAcceleration","title":"<code>LateralAcceleration</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Lateral acceleration of the vehicle.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class LateralAcceleration(Channel, name=\"Lateral Acceleration\", unit=Unit.G):\n    \"\"\"Lateral acceleration of the vehicle.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.lateral_acceleration for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.LongitudinalAcceleration","title":"<code>LongitudinalAcceleration</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Longitudinal acceleration of the vehicle.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class LongitudinalAcceleration(\n    Channel, name=\"Longitudinal Acceleration\", unit=Unit.G\n):\n    \"\"\"Longitudinal acceleration of the vehicle.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.longitudinal_acceleration for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.MaximumVelocity","title":"<code>MaximumVelocity</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Maximum, velocity of the vehicle, limited by lateral grip.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class MaximumVelocity(\n    Channel, name=\"Maximum Velocity\", unit=Unit.KILOMETER_PER_HOUR\n):\n    \"\"\"Maximum, velocity of the vehicle, limited by lateral grip.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.maximum_velocity for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.MotorEnergy","title":"<code>MotorEnergy</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Energy output by the motor.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class MotorEnergy(Channel, name=\"Motor Energy\", unit=Unit.KILOWATT_HOUR):\n    \"\"\"Energy output by the motor.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return fcn.integral(MotorPower, SegmentTime)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.MotorForce","title":"<code>MotorForce</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Equivalent motor force measured at the wheels.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class MotorForce(Channel, name=\"Motor Force\", unit=Unit.NEWTON):\n    \"\"\"Equivalent motor force measured at the wheels.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.vehicle_state.motor_force for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.MotorPower","title":"<code>MotorPower</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Power output by the motor.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class MotorPower(Channel, name=\"Motor Power\", unit=Unit.KILOWATT):\n    \"\"\"Power output by the motor.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return fcn.product(MotorTorque, MotorSpeed)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.MotorSpeed","title":"<code>MotorSpeed</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Rotational velocity of the motor.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class MotorSpeed(Channel, name=\"Motor Speed\", unit=Unit.RADIANS_PER_SECOND):\n    \"\"\"Rotational velocity of the motor.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.vehicle_state.motor_speed for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.MotorTorque","title":"<code>MotorTorque</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Torque generated by the motor.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class MotorTorque(Channel, name=\"Motor Torque\", unit=Unit.NEWTON_METER):\n    \"\"\"Torque generated by the motor.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.vehicle_state.motor_torque for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.NormalForce","title":"<code>NormalForce</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Total normal force exerted by the vehicle.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class NormalForce(Channel, name=\"Normal Force\", unit=Unit.NEWTON):\n    \"\"\"Total normal force exerted by the vehicle.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.vehicle_state.normal_force for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.Position","title":"<code>Position</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Position of the vehicle.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class Position(Channel, name=\"Position\", unit=Unit.METER):\n    \"\"\"Position of the vehicle.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.track_node.position for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.RequiredFy","title":"<code>RequiredFy</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Lateral force required to navigate the track.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class RequiredFy(Channel, name=\"Required Fy\", unit=Unit.NEWTON):\n    \"\"\"Lateral force required to navigate the track.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.vehicle_state.required_fy for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.ResistiveFx","title":"<code>ResistiveFx</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Total resistive force acting on the vehicle.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class ResistiveFx(Channel, name=\"Resistive Force\", unit=Unit.NEWTON):\n    \"\"\"Total resistive force acting on the vehicle.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.vehicle_state.resistive_fx for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.ResultantAcceleration","title":"<code>ResultantAcceleration</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Resultant acceleration of the vehicle.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class ResultantAcceleration(\n    Channel, name=\"Resultant Acceleration\", unit=Unit.G\n):\n    \"\"\"Resultant acceleration of the vehicle.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return fcn.hypotenuse(LongitudinalAcceleration, LateralAcceleration)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.SegmentTime","title":"<code>SegmentTime</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Time taken to traverse the track segment.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class SegmentTime(Channel, name=\"Segment Time\", unit=Unit.SECOND):\n    \"\"\"Time taken to traverse the track segment.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [node.time for node in solution.nodes]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.StateOfCharge","title":"<code>StateOfCharge</code>","text":"<p>               Bases: <code>Channel</code></p> <p>State of charge of the battery.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class StateOfCharge(Channel, name=\"State of Charge\", unit=Unit.UNITLESS):\n    \"\"\"State of charge of the battery.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.state_variables.state_of_charge for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.Time","title":"<code>Time</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Cumulative time for the simulation.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class Time(Channel, name=\"Time\", unit=Unit.SECOND):\n    \"\"\"Cumulative time for the simulation.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return fcn.cumulative_sum(SegmentTime)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.TotalLateralTraction","title":"<code>TotalLateralTraction</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Total lateral traction force generated by the tyres.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class TotalLateralTraction(\n    Channel, name=\"Total Lateral Traction\", unit=Unit.NEWTON\n):\n    \"\"\"Total lateral traction force generated by the tyres.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.vehicle_state.total_lateral_traction for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/channels/library/#usmlap.simulation.channels.library.Velocity","title":"<code>Velocity</code>","text":"<p>               Bases: <code>Channel</code></p> <p>Velocity of the vehicle.</p> Source code in <code>src\\usmlap\\simulation\\channels\\library.py</code> <pre><code>class Velocity(Channel, name=\"Velocity\", unit=Unit.KILOMETER_PER_HOUR):\n    \"\"\"Velocity of the vehicle.\"\"\"\n\n    @classmethod\n    def _channel_fcn(cls) -&gt; ChannelFcn:\n        return lambda solution: [\n            node.average_velocity for node in solution.nodes\n        ]\n</code></pre>"},{"location":"autoapi/usmlap/simulation/model/","title":"model","text":""},{"location":"autoapi/usmlap/simulation/model/point_mass/","title":"point_mass","text":"<p>This module defines the point mass vehicle model.</p>"},{"location":"autoapi/usmlap/simulation/model/point_mass/#usmlap.simulation.model.point_mass.PointMassVehicleModel","title":"<code>PointMassVehicleModel</code>","text":"<p>               Bases: <code>VehicleModelInterface</code></p> <p>Point mass vehicle model.</p> Source code in <code>src\\usmlap\\simulation\\model\\point_mass.py</code> <pre><code>class PointMassVehicleModel(VehicleModelInterface):\n    \"\"\"\n    Point mass vehicle model.\n    \"\"\"\n\n    def get_normal_loads(self, normal_force: float) -&gt; FourCorner[float]:\n        normal_load = normal_force / 4\n        return FourCorner([normal_load] * 4)\n\n    def get_tyre_attitudes(\n        self, normal_loads: FourCorner[float]\n    ) -&gt; FourCorner[TyreAttitude]:\n        return FourCorner(\n            [\n                TyreAttitude(normal_load=normal_load)\n                for normal_load in normal_loads\n            ]\n        )\n\n    def get_lateral_traction(\n        self, attitudes: FourCorner[TyreAttitude], required_fx: float\n    ) -&gt; FourCorner[float]:\n        front_tyre = self.vehicle.tyres.front.tyre_model.calculate_lateral_force\n        rear_tyre = self.vehicle.tyres.rear.tyre_model.calculate_lateral_force\n        try:\n            return FourCorner(\n                [\n                    front_tyre(attitudes.front_left, required_fx=0),\n                    front_tyre(attitudes.front_right, required_fx=0),\n                    rear_tyre(attitudes.rear_left, required_fx=required_fx / 2),\n                    rear_tyre(\n                        attitudes.rear_right, required_fx=required_fx / 2\n                    ),\n                ]\n            )\n        except ValueError:\n            return FourCorner([0] * 4)\n\n    def get_longitudinal_traction(\n        self, attitudes: FourCorner[TyreAttitude], required_fy: float\n    ) -&gt; FourCorner[float]:\n        front_tyre = (\n            self.vehicle.tyres.front.tyre_model.calculate_longitudinal_force\n        )\n        rear_tyre = (\n            self.vehicle.tyres.rear.tyre_model.calculate_longitudinal_force\n        )\n        fy_per_tyre = abs(required_fy / 4)\n        try:\n            return FourCorner(\n                [\n                    front_tyre(attitudes.front_left, required_fy=fy_per_tyre),\n                    front_tyre(attitudes.front_right, required_fy=fy_per_tyre),\n                    rear_tyre(attitudes.rear_left, required_fy=fy_per_tyre),\n                    rear_tyre(attitudes.rear_right, required_fy=fy_per_tyre),\n                ]\n            )\n        except ValueError:\n            return FourCorner([0] * 4)\n\n    def lateral_vehicle_model(\n        self, state_variables: StateVariables, node: TrackNode\n    ) -&gt; float:\n        velocity = self.vehicle.maximum_velocity\n        if node.curvature == 0:\n            return velocity\n\n        i = 0\n        while i &lt; 10000:\n            i += 1\n            vehicle_state = self.resolve_vehicle_state(\n                state_variables, node, velocity\n            )\n            try:\n                available_fy = vehicle_state.total_lateral_traction\n            except ValueError:\n                available_fy = 0\n\n            if available_fy &lt; abs(vehicle_state.required_fy):\n                net_force = available_fy - node.z_to_y(vehicle_state.weight)\n                ay = net_force / self.vehicle.total_mass\n                velocity = math.sqrt(ay / abs(node.curvature)) - 0.001\n            else:\n                break\n\n        return velocity\n\n    def calculate_acceleration(\n        self, state_variables: StateVariables, node: TrackNode, velocity: float\n    ) -&gt; float:\n        vehicle_state = self.resolve_vehicle_state(\n            state_variables, node, velocity\n        )\n        traction_limit = (\n            vehicle_state.longitudinal_traction.rear_left\n            + vehicle_state.longitudinal_traction.rear_right\n        )\n        motor_limit = vehicle_state.motor_force\n        drive_limit = min(motor_limit, traction_limit)\n        net_fx = drive_limit - vehicle_state.resistive_fx\n        return net_fx / self.vehicle.equivalent_mass\n\n    def calculate_deceleration(\n        self, state_variables: StateVariables, node: TrackNode, velocity: float\n    ) -&gt; float:\n        vehicle_state = self.resolve_vehicle_state(\n            state_variables, node, velocity\n        )\n        traction_limit = sum(vehicle_state.longitudinal_traction)\n        net_fx = traction_limit + vehicle_state.resistive_fx\n        return net_fx / self.vehicle.equivalent_mass\n</code></pre>"},{"location":"autoapi/usmlap/simulation/model/vehicle_model/","title":"vehicle_model","text":"<p>This module defines the interface for vehicle models.</p>"},{"location":"autoapi/usmlap/simulation/model/vehicle_model/#usmlap.simulation.model.vehicle_model.VehicleModelInterface","title":"<code>VehicleModelInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for vehicle models.</p> Source code in <code>src\\usmlap\\simulation\\model\\vehicle_model.py</code> <pre><code>class VehicleModelInterface(ABC):\n    \"\"\"\n    Abstract base class for vehicle models.\n    \"\"\"\n\n    vehicle: Vehicle\n    environment: Environment\n\n    def __init__(self, vehicle: Vehicle, environment: Environment) -&gt; None:\n        self.vehicle = vehicle\n        self.environment = environment\n\n    def resolve_vehicle_state(\n        self, state_variables: StateVariables, node: TrackNode, velocity: float\n    ) -&gt; FullVehicleState:\n        \"\"\"\n        Calculate the full state of the vehicle at a node.\n\n        Args:\n            state_variables (StateVariables): The vehicle's state variables.\n            node (TrackNode): The track node to evaluate.\n\n        Returns:\n            vehicle_state (FullVehicleState): The full state of the vehicle,\n                including forces, torques, and energy.\n        \"\"\"\n        vehicle = self.vehicle\n\n        weight = vehicle.total_mass * self.environment.gravity\n        centripetal_force = vehicle.total_mass * velocity**2 * node.curvature\n\n        aero_attitude = AeroAttitude(\n            velocity=velocity, air_density=self.environment.air_density\n        )\n        downforce = self.vehicle.aero.get_downforce(aero_attitude)\n        drag = self.vehicle.aero.get_drag(aero_attitude)\n\n        resistive_fx = drag + node.z_to_x(weight)\n        required_fy = node.y_to_y(centripetal_force) + node.z_to_y(weight)\n        normal_force = (\n            node.z_to_z(weight) + node.y_to_z(centripetal_force) + downforce\n        )\n\n        normal_loads = self.get_normal_loads(normal_force)\n        tyre_attitudes = self.get_tyre_attitudes(normal_loads)\n        lateral_traction = self.get_lateral_traction(\n            tyre_attitudes, resistive_fx\n        )\n        longitudinal_traction = self.get_longitudinal_traction(\n            tyre_attitudes, required_fy\n        )\n\n        motor_speed = vehicle.velocity_to_motor_speed(velocity)\n        motor_torque = vehicle.powertrain.get_motor_torque(\n            state_of_charge=state_variables.state_of_charge,\n            motor_speed=motor_speed,\n        )\n        motor_power = motor_speed * motor_torque\n        accumulator_power = vehicle.powertrain.motor_to_accumulator_power(\n            motor_power\n        )\n        motor_force = vehicle.motor_torque_to_drive_force(motor_torque)\n\n        return FullVehicleState(\n            weight=weight,\n            centripetal_force=centripetal_force,\n            downforce=downforce,\n            drag=drag,\n            resistive_fx=resistive_fx,\n            required_fy=required_fy,\n            normal_force=normal_force,\n            normal_loads=normal_loads,\n            tyre_attitudes=tyre_attitudes,\n            lateral_traction=lateral_traction,\n            longitudinal_traction=longitudinal_traction,\n            motor_speed=motor_speed,\n            motor_torque=motor_torque,\n            motor_power=motor_power,\n            accumulator_power=accumulator_power,\n            motor_force=motor_force,\n        )\n\n    @abstractmethod\n    def lateral_vehicle_model(\n        self, state_variables: StateVariables, node: TrackNode\n    ) -&gt; float:\n        \"\"\"\n        Calculate the lateral-traction-limited velocity at a node.\n\n        This is the maximum velocity that the vehicle can travel at\n        while maintaining lateral traction with no longitudinal acceleration.\n\n        Args:\n            node (TrackNode): The track node to evaluate.\n\n        Returns:\n            velocity (float): The lateral traction limited velocity.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def calculate_acceleration(\n        self, state_variables: StateVariables, node: TrackNode, velocity: float\n    ) -&gt; float:\n        pass\n\n    @abstractmethod\n    def calculate_deceleration(\n        self, state_variables: StateVariables, node: TrackNode, velocity: float\n    ) -&gt; float:\n        pass\n\n    @abstractmethod\n    def get_normal_loads(self, normal_force: float) -&gt; FourCorner[float]:\n        pass\n\n    @abstractmethod\n    def get_tyre_attitudes(\n        self, normal_loads: FourCorner[float]\n    ) -&gt; FourCorner[TyreAttitude]:\n        pass\n\n    @abstractmethod\n    def get_lateral_traction(\n        self, attitudes: FourCorner[TyreAttitude], required_fx: float\n    ) -&gt; FourCorner[float]:\n        pass\n\n    @abstractmethod\n    def get_longitudinal_traction(\n        self, attitudes: FourCorner[TyreAttitude], required_fy: float\n    ) -&gt; FourCorner[float]:\n        pass\n</code></pre>"},{"location":"autoapi/usmlap/simulation/model/vehicle_model/#usmlap.simulation.model.vehicle_model.VehicleModelInterface.lateral_vehicle_model","title":"<code>lateral_vehicle_model(state_variables, node)</code>  <code>abstractmethod</code>","text":"<p>Calculate the lateral-traction-limited velocity at a node.</p> <p>This is the maximum velocity that the vehicle can travel at while maintaining lateral traction with no longitudinal acceleration.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>TrackNode</code> <p>The track node to evaluate.</p> required <p>Returns:</p> Name Type Description <code>velocity</code> <code>float</code> <p>The lateral traction limited velocity.</p> Source code in <code>src\\usmlap\\simulation\\model\\vehicle_model.py</code> <pre><code>@abstractmethod\ndef lateral_vehicle_model(\n    self, state_variables: StateVariables, node: TrackNode\n) -&gt; float:\n    \"\"\"\n    Calculate the lateral-traction-limited velocity at a node.\n\n    This is the maximum velocity that the vehicle can travel at\n    while maintaining lateral traction with no longitudinal acceleration.\n\n    Args:\n        node (TrackNode): The track node to evaluate.\n\n    Returns:\n        velocity (float): The lateral traction limited velocity.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/usmlap/simulation/model/vehicle_model/#usmlap.simulation.model.vehicle_model.VehicleModelInterface.resolve_vehicle_state","title":"<code>resolve_vehicle_state(state_variables, node, velocity)</code>","text":"<p>Calculate the full state of the vehicle at a node.</p> <p>Parameters:</p> Name Type Description Default <code>state_variables</code> <code>StateVariables</code> <p>The vehicle's state variables.</p> required <code>node</code> <code>TrackNode</code> <p>The track node to evaluate.</p> required <p>Returns:</p> Name Type Description <code>vehicle_state</code> <code>FullVehicleState</code> <p>The full state of the vehicle, including forces, torques, and energy.</p> Source code in <code>src\\usmlap\\simulation\\model\\vehicle_model.py</code> <pre><code>def resolve_vehicle_state(\n    self, state_variables: StateVariables, node: TrackNode, velocity: float\n) -&gt; FullVehicleState:\n    \"\"\"\n    Calculate the full state of the vehicle at a node.\n\n    Args:\n        state_variables (StateVariables): The vehicle's state variables.\n        node (TrackNode): The track node to evaluate.\n\n    Returns:\n        vehicle_state (FullVehicleState): The full state of the vehicle,\n            including forces, torques, and energy.\n    \"\"\"\n    vehicle = self.vehicle\n\n    weight = vehicle.total_mass * self.environment.gravity\n    centripetal_force = vehicle.total_mass * velocity**2 * node.curvature\n\n    aero_attitude = AeroAttitude(\n        velocity=velocity, air_density=self.environment.air_density\n    )\n    downforce = self.vehicle.aero.get_downforce(aero_attitude)\n    drag = self.vehicle.aero.get_drag(aero_attitude)\n\n    resistive_fx = drag + node.z_to_x(weight)\n    required_fy = node.y_to_y(centripetal_force) + node.z_to_y(weight)\n    normal_force = (\n        node.z_to_z(weight) + node.y_to_z(centripetal_force) + downforce\n    )\n\n    normal_loads = self.get_normal_loads(normal_force)\n    tyre_attitudes = self.get_tyre_attitudes(normal_loads)\n    lateral_traction = self.get_lateral_traction(\n        tyre_attitudes, resistive_fx\n    )\n    longitudinal_traction = self.get_longitudinal_traction(\n        tyre_attitudes, required_fy\n    )\n\n    motor_speed = vehicle.velocity_to_motor_speed(velocity)\n    motor_torque = vehicle.powertrain.get_motor_torque(\n        state_of_charge=state_variables.state_of_charge,\n        motor_speed=motor_speed,\n    )\n    motor_power = motor_speed * motor_torque\n    accumulator_power = vehicle.powertrain.motor_to_accumulator_power(\n        motor_power\n    )\n    motor_force = vehicle.motor_torque_to_drive_force(motor_torque)\n\n    return FullVehicleState(\n        weight=weight,\n        centripetal_force=centripetal_force,\n        downforce=downforce,\n        drag=drag,\n        resistive_fx=resistive_fx,\n        required_fy=required_fy,\n        normal_force=normal_force,\n        normal_loads=normal_loads,\n        tyre_attitudes=tyre_attitudes,\n        lateral_traction=lateral_traction,\n        longitudinal_traction=longitudinal_traction,\n        motor_speed=motor_speed,\n        motor_torque=motor_torque,\n        motor_power=motor_power,\n        accumulator_power=accumulator_power,\n        motor_force=motor_force,\n    )\n</code></pre>"},{"location":"autoapi/usmlap/simulation/points/","title":"points","text":""},{"location":"autoapi/usmlap/simulation/points/competition_data/","title":"competition_data","text":"<p>This module contains code for handling competition data.</p>"},{"location":"autoapi/usmlap/simulation/points/competition_data/#usmlap.simulation.points.competition_data.CompetitionData","title":"<code>CompetitionData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Scores from Formula Student competition, used to calculate points scored at competition.</p> <p>Attributes:</p> Name Type Description <code>acceleration_t_min</code> <code>float</code> <p>The minimum time for the acceleration event.</p> <code>skidpad_t_min</code> <code>float</code> <p>The minimum time for the skidpad event.</p> <code>autocross_t_min</code> <code>float</code> <p>The minimum time for the autocross event.</p> <code>endurance_t_min</code> <code>float</code> <p>The minimum time for the endurance event.</p> Source code in <code>src\\usmlap\\simulation\\points\\competition_data.py</code> <pre><code>class CompetitionData(BaseModel):\n    \"\"\"\n    Scores from Formula Student competition,\n    used to calculate points scored at competition.\n\n    Attributes:\n        acceleration_t_min (float): The minimum time for the acceleration event.\n        skidpad_t_min (float): The minimum time for the skidpad event.\n        autocross_t_min (float): The minimum time for the autocross event.\n        endurance_t_min (float): The minimum time for the endurance event.\n    \"\"\"\n\n    dataset: str\n    acceleration_t_min: float\n    skidpad_t_min: float\n    autocross_t_min: float\n    endurance_t_min: float\n\n    @staticmethod\n    def _get_library_path() -&gt; str:\n        return \"appdata/library/competition/points.json\"\n\n    @classmethod\n    def load_library(cls) -&gt; dict[str, dict[str, Any]]:\n        with open(cls._get_library_path(), \"r\") as library_file:\n            return json.load(library_file)\n\n    @classmethod\n    def list_datasets(cls) -&gt; list[str]:\n        return list(cls.load_library().keys())\n\n    @classmethod\n    def check_dataset_exists(cls, name: str) -&gt; None:\n        available_datasets = cls.list_datasets()\n        if name not in available_datasets:\n            error_message = (\n                f\"Competition dataset '{name}' not found \"\n                f\"(available datasets: {available_datasets})\"\n            )\n            raise KeyError(error_message)\n\n    @classmethod\n    def get_dataset(cls, name: str) -&gt; Self:\n        cls.check_dataset_exists(name)\n        library = cls.load_library()\n        dataset = library[name]\n        dataset[\"dataset\"] = name\n        return cls.model_validate(dataset)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/points/points/","title":"points","text":"<p>This module contains code for calculating points from competition results.</p>"},{"location":"autoapi/usmlap/simulation/points/points/#usmlap.simulation.points.points.CompetitionPoints","title":"<code>CompetitionPoints</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Points scored in each event at Formula Student.</p> <p>Attributes:</p> Name Type Description <code>acceleration</code> <code>float</code> <p>Points scored in the acceleration event.</p> <code>skidpad</code> <code>float</code> <p>Points scored in the skidpad event.</p> <code>autocross</code> <code>float</code> <p>Points scored in the autocross event.</p> <code>endurance</code> <code>float</code> <p>Points scored in the endurance event.</p> Source code in <code>src\\usmlap\\simulation\\points\\points.py</code> <pre><code>@dataclass\nclass CompetitionPoints(object):\n    \"\"\"\n    Points scored in each event at Formula Student.\n\n    Attributes:\n        acceleration (float): Points scored in the acceleration event.\n        skidpad (float): Points scored in the skidpad event.\n        autocross (float): Points scored in the autocross event.\n        endurance (float): Points scored in the endurance event.\n    \"\"\"\n\n    acceleration: float\n    skidpad: float\n    autocross: float\n    endurance: float\n\n    @property\n    def total(self) -&gt; float:\n        return (\n            self.acceleration + self.skidpad + self.autocross + self.endurance\n        )\n\n    def plot_pie_chart(self) -&gt; None:\n        \"\"\"\n        Plot a pie chart of points scored in each event.\n        \"\"\"\n        points = {\n            \"Acceleration\": self.acceleration,\n            \"Skidpad\": self.skidpad,\n            \"Autocross\": self.autocross,\n            \"Endurance\": self.endurance,\n        }\n        plt.pie(list(points.values()), labels=list(points.keys()))\n        plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/simulation/points/points/#usmlap.simulation.points.points.CompetitionPoints.plot_pie_chart","title":"<code>plot_pie_chart()</code>","text":"<p>Plot a pie chart of points scored in each event.</p> Source code in <code>src\\usmlap\\simulation\\points\\points.py</code> <pre><code>def plot_pie_chart(self) -&gt; None:\n    \"\"\"\n    Plot a pie chart of points scored in each event.\n    \"\"\"\n    points = {\n        \"Acceleration\": self.acceleration,\n        \"Skidpad\": self.skidpad,\n        \"Autocross\": self.autocross,\n        \"Endurance\": self.endurance,\n    }\n    plt.pie(list(points.values()), labels=list(points.keys()))\n    plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/simulation/points/points/#usmlap.simulation.points.points.calculate_points","title":"<code>calculate_points(results, data=CompetitionData.get_dataset('FSUK 2025'), formulae=FSUKPointsFunctions())</code>","text":"<p>Calculate points scored in each event at Formula Student.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>CompetitionResults</code> <p>The results of a competition simulation.</p> required <code>data</code> <code>Optional[CompetitionData]</code> <p>The competition data to use for calculating points.</p> <code>get_dataset('FSUK 2025')</code> <code>formulae</code> <code>PointsFunctions</code> <p>The points formulae to use.</p> <code>FSUKPointsFunctions()</code> <p>Returns:</p> Name Type Description <code>points</code> <code>CompetitionPoints</code> <p>The points scored in each event.</p> Source code in <code>src\\usmlap\\simulation\\points\\points.py</code> <pre><code>def calculate_points(\n    results: CompetitionResults,\n    data: CompetitionData = CompetitionData.get_dataset(\"FSUK 2025\"),\n    formulae: PointsFunctions = FSUKPointsFunctions(),\n) -&gt; CompetitionPoints:\n    \"\"\"\n    Calculate points scored in each event at Formula Student.\n\n    Args:\n        results (CompetitionResults):\n            The results of a competition simulation.\n        data (Optional[CompetitionData]):\n            The competition data to use for calculating points.\n        formulae (PointsFunctions, optional):\n            The points formulae to use.\n\n    Returns:\n        points (CompetitionPoints): The points scored in each event.\n    \"\"\"\n    points = CompetitionPoints(\n        acceleration=formulae.calculate_acceleration_points(\n            t_team=results.acceleration.total_time,\n            t_min=data.acceleration_t_min,\n        ),\n        skidpad=formulae.calculate_skidpad_points(\n            t_team=results.skidpad.total_time / 2, t_min=data.skidpad_t_min\n        ),\n        autocross=formulae.calculate_autocross_points(\n            t_team=results.autocross.total_time, t_min=data.autocross_t_min\n        ),\n        endurance=formulae.calculate_endurance_points(\n            t_team=results.endurance.total_time, t_min=data.endurance_t_min\n        ),\n    )\n    return points\n</code></pre>"},{"location":"autoapi/usmlap/simulation/points/points_functions/","title":"points_functions","text":"<p>This module contains functions for calculating points scored at competition.</p>"},{"location":"autoapi/usmlap/simulation/points/points_functions/#usmlap.simulation.points.points_functions.FSUKPointsFunctions","title":"<code>FSUKPointsFunctions</code>","text":"<p>               Bases: <code>PointsFunctions</code></p> <p>Points functions for Formula Student UK.</p> Source code in <code>src\\usmlap\\simulation\\points\\points_functions.py</code> <pre><code>class FSUKPointsFunctions(PointsFunctions):\n    \"\"\"\n    Points functions for Formula Student UK.\n    \"\"\"\n\n    @staticmethod\n    def calculate_acceleration_points(t_team: float, t_min: float) -&gt; float:\n        t_min = min(t_team, t_min)\n        t_max = t_min * 1.5\n        score = 65 * ((t_max / t_team) - 1) / ((t_max / t_min) - 1)\n        base_points = 5\n        return base_points + score\n\n    @staticmethod\n    def calculate_skidpad_points(t_team: float, t_min: float) -&gt; float:\n        t_min = min(t_team, t_min)\n        t_max = t_min * 1.25\n        score = 70 * ((t_max / t_team) ** 2 - 1) / ((t_max / t_min) ** 2 - 1)\n        base_points = 5\n        return base_points + score\n\n    @staticmethod\n    def calculate_autocross_points(t_team: float, t_min: float) -&gt; float:\n        t_min = min(t_team, t_min)\n        t_max = t_min * 1.45\n        score = 95 * ((t_max / t_team) - 1) / ((t_max / t_min) - 1)\n        base_points = 5\n        return base_points + score\n\n    @staticmethod\n    def calculate_endurance_points(t_team: float, t_min: float) -&gt; float:\n        t_min = min(t_team, t_min)\n        t_max = t_min * 1.45\n        score = 225 * ((t_max / t_team) - 1) / ((t_max / t_min) - 1)\n        base_points = 25\n        return base_points + score\n</code></pre>"},{"location":"autoapi/usmlap/simulation/points/points_functions/#usmlap.simulation.points.points_functions.PointsFunctions","title":"<code>PointsFunctions</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Functions for calculating points scored at Formula Student competitions.</p> Source code in <code>src\\usmlap\\simulation\\points\\points_functions.py</code> <pre><code>class PointsFunctions(ABC):\n    \"\"\"\n    Functions for calculating points scored at Formula Student competitions.\n    \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def calculate_acceleration_points(t_team: float, t_min: float) -&gt; float:\n        \"\"\"\n        Calculate the points scored in the acceleration event.\n\n        Args:\n            t_team (float): The acceleration time set by the car.\n            t_min (float): The acceleration time of the fastest team.\n\n        Returns:\n            score (float): The points scored in the acceleration event.\n        \"\"\"\n        ...\n\n    @staticmethod\n    @abstractmethod\n    def calculate_skidpad_points(t_team: float, t_min: float) -&gt; float:\n        \"\"\"\n        Calculate the points scored in the skidpad event.\n\n        Args:\n            t_team (float): The skidpad time set by the car.\n            t_min (float): The skidpad time of the fastest team.\n\n        Returns:\n            score (float): The points scored in the skidpad event.\n        \"\"\"\n        ...\n\n    @staticmethod\n    @abstractmethod\n    def calculate_autocross_points(t_team: float, t_min: float) -&gt; float:\n        \"\"\"\n        Calculate the points scored in the autocross event.\n\n        Args:\n            t_team (float): The autocross time set by the car.\n            t_min (float): The autocross time of the fastest team.\n\n        Returns:\n            score (float): The points scored in the autocross event.\n        \"\"\"\n        ...\n\n    @staticmethod\n    @abstractmethod\n    def calculate_endurance_points(t_team: float, t_min: float) -&gt; float:\n        \"\"\"\n        Calculate the points scored in the endurance event.\n\n        Args:\n            t_team (float): The endurance time set by the car.\n            t_min (float): The endurance time of the fastest team.\n\n        Returns:\n            score (float): The points scored in the endurance event.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"autoapi/usmlap/simulation/points/points_functions/#usmlap.simulation.points.points_functions.PointsFunctions.calculate_acceleration_points","title":"<code>calculate_acceleration_points(t_team, t_min)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Calculate the points scored in the acceleration event.</p> <p>Parameters:</p> Name Type Description Default <code>t_team</code> <code>float</code> <p>The acceleration time set by the car.</p> required <code>t_min</code> <code>float</code> <p>The acceleration time of the fastest team.</p> required <p>Returns:</p> Name Type Description <code>score</code> <code>float</code> <p>The points scored in the acceleration event.</p> Source code in <code>src\\usmlap\\simulation\\points\\points_functions.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef calculate_acceleration_points(t_team: float, t_min: float) -&gt; float:\n    \"\"\"\n    Calculate the points scored in the acceleration event.\n\n    Args:\n        t_team (float): The acceleration time set by the car.\n        t_min (float): The acceleration time of the fastest team.\n\n    Returns:\n        score (float): The points scored in the acceleration event.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"autoapi/usmlap/simulation/points/points_functions/#usmlap.simulation.points.points_functions.PointsFunctions.calculate_autocross_points","title":"<code>calculate_autocross_points(t_team, t_min)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Calculate the points scored in the autocross event.</p> <p>Parameters:</p> Name Type Description Default <code>t_team</code> <code>float</code> <p>The autocross time set by the car.</p> required <code>t_min</code> <code>float</code> <p>The autocross time of the fastest team.</p> required <p>Returns:</p> Name Type Description <code>score</code> <code>float</code> <p>The points scored in the autocross event.</p> Source code in <code>src\\usmlap\\simulation\\points\\points_functions.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef calculate_autocross_points(t_team: float, t_min: float) -&gt; float:\n    \"\"\"\n    Calculate the points scored in the autocross event.\n\n    Args:\n        t_team (float): The autocross time set by the car.\n        t_min (float): The autocross time of the fastest team.\n\n    Returns:\n        score (float): The points scored in the autocross event.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"autoapi/usmlap/simulation/points/points_functions/#usmlap.simulation.points.points_functions.PointsFunctions.calculate_endurance_points","title":"<code>calculate_endurance_points(t_team, t_min)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Calculate the points scored in the endurance event.</p> <p>Parameters:</p> Name Type Description Default <code>t_team</code> <code>float</code> <p>The endurance time set by the car.</p> required <code>t_min</code> <code>float</code> <p>The endurance time of the fastest team.</p> required <p>Returns:</p> Name Type Description <code>score</code> <code>float</code> <p>The points scored in the endurance event.</p> Source code in <code>src\\usmlap\\simulation\\points\\points_functions.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef calculate_endurance_points(t_team: float, t_min: float) -&gt; float:\n    \"\"\"\n    Calculate the points scored in the endurance event.\n\n    Args:\n        t_team (float): The endurance time set by the car.\n        t_min (float): The endurance time of the fastest team.\n\n    Returns:\n        score (float): The points scored in the endurance event.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"autoapi/usmlap/simulation/points/points_functions/#usmlap.simulation.points.points_functions.PointsFunctions.calculate_skidpad_points","title":"<code>calculate_skidpad_points(t_team, t_min)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Calculate the points scored in the skidpad event.</p> <p>Parameters:</p> Name Type Description Default <code>t_team</code> <code>float</code> <p>The skidpad time set by the car.</p> required <code>t_min</code> <code>float</code> <p>The skidpad time of the fastest team.</p> required <p>Returns:</p> Name Type Description <code>score</code> <code>float</code> <p>The points scored in the skidpad event.</p> Source code in <code>src\\usmlap\\simulation\\points\\points_functions.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef calculate_skidpad_points(t_team: float, t_min: float) -&gt; float:\n    \"\"\"\n    Calculate the points scored in the skidpad event.\n\n    Args:\n        t_team (float): The skidpad time set by the car.\n        t_min (float): The skidpad time of the fastest team.\n\n    Returns:\n        score (float): The points scored in the skidpad event.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solver/","title":"solver","text":""},{"location":"autoapi/usmlap/simulation/solver/quasi_steady_state/","title":"quasi_steady_state","text":"<p>This module implements a quasi-steady-state solver.</p>"},{"location":"autoapi/usmlap/simulation/solver/quasi_steady_state/#usmlap.simulation.solver.quasi_steady_state.QuasiSteadyStateSolver","title":"<code>QuasiSteadyStateSolver</code>","text":"<p>               Bases: <code>SolverInterface</code></p> <p>Quasi-steady-state solver.</p> Source code in <code>src\\usmlap\\simulation\\solver\\quasi_steady_state.py</code> <pre><code>class QuasiSteadyStateSolver(SolverInterface):\n    \"\"\"\n    Quasi-steady-state solver.\n    \"\"\"\n\n    @staticmethod\n    def solve(previous_solution: Solution) -&gt; Solution:\n\n        solution = previous_solution\n\n        solution.nodes[0].anchor_initial_velocity(0)\n\n        logger.info(\"Solving maximum velocities...\")\n        solution = solve_maximum_velocities(solution)\n\n        logger.info(\"Finding apexes...\")\n        solution.set_apexes(find_apexes(solution))\n\n        logger.info(\"Solving forward propagation...\")\n        for apex in progress.track(\n            solution.get_sorted_apex_indices(),\n            description=\"Solving forward propagation...\",\n        ):\n            if solution.nodes[apex].is_apex():\n                solution = propagate_forward(solution, start_index=apex)\n\n        logger.info(\"Solving backward propagation...\")\n        for apex in progress.track(\n            solution.get_sorted_apex_indices(),\n            description=\"Solving backward propagation...\",\n        ):\n            if solution.nodes[apex].is_apex():\n                solution = propagate_backward(solution, start_index=apex)\n\n        logger.info(\"Resolving full vehicle state...\")\n        solution.evaluate_full_vehicle_state(solution.vehicle_model)\n\n        logger.info(\"Recalculating state variables...\")\n        solution = recalculate_state_variables(solution)\n\n        return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solver/quasi_steady_state/#usmlap.simulation.solver.quasi_steady_state.find_apexes","title":"<code>find_apexes(solution)</code>","text":"<p>Identify the apexes of a solution.</p> <p>Apexes are the indices at which the maximum velocity is a local minimum.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Solution</code> <p>The solution to analyze.</p> required <p>Returns:</p> Name Type Description <code>apexes</code> <code>list[int]</code> <p>The indices of the apexes.</p> Source code in <code>src\\usmlap\\simulation\\solver\\quasi_steady_state.py</code> <pre><code>def find_apexes(solution: Solution) -&gt; list[int]:\n    \"\"\"\n    Identify the apexes of a solution.\n\n    Apexes are the indices at which the maximum velocity is a local minimum.\n\n    Args:\n        solution (Solution): The solution to analyze.\n\n    Returns:\n        apexes (list[int]): The indices of the apexes.\n    \"\"\"\n    maximum_velocities = [-node.maximum_velocity for node in solution.nodes]\n    apex_indices, _ = find_peaks(maximum_velocities)\n    apex_indices = set(apex_indices.tolist())\n    apex_indices.update([0, len(solution.nodes) - 1])\n    return list(apex_indices)\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solver/quasi_steady_state/#usmlap.simulation.solver.quasi_steady_state.propagate_backward","title":"<code>propagate_backward(solution, start_index)</code>","text":"<p>Propagate the solution backwards.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Solution</code> <p>The initial unpropagated solution.</p> required <code>start_index</code> <code>int</code> <p>The index of the node to begin propagating from.</p> required <p>Returns:</p> Name Type Description <code>solution</code> <code>Solution</code> <p>The backward-propagated solution.</p> Source code in <code>src\\usmlap\\simulation\\solver\\quasi_steady_state.py</code> <pre><code>def propagate_backward(solution: Solution, start_index: int) -&gt; Solution:\n    \"\"\"\n    Propagate the solution backwards.\n\n    Args:\n        solution (Solution): The initial unpropagated solution.\n        start_index (int): The index of the node to begin propagating from.\n\n    Returns:\n        solution (Solution): The backward-propagated solution.\n    \"\"\"\n\n    logger.debug(f\"Backward propagating apex {start_index}\")\n\n    for node in solution.nodes[start_index::-1]:\n        if node.previous is None:\n            break\n\n        if node.previous.final_velocity &lt; node.final_velocity:\n            break\n\n        if node.previous.is_apex():\n            node.previous.remove_apex()\n\n        traction_limit_velocity = traction_limit_velocity_braking(\n            solution.vehicle_model, node\n        )\n        initial_velocity = min(\n            traction_limit_velocity, node.previous.final_velocity\n        )\n\n        node.set_initial_velocity(initial_velocity)\n        node.previous.set_final_velocity(initial_velocity)\n\n    logger.debug(f\"Solved backward propogation of apex {start_index}.\")\n    return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solver/quasi_steady_state/#usmlap.simulation.solver.quasi_steady_state.propagate_forward","title":"<code>propagate_forward(solution, start_index)</code>","text":"<p>Propagate the solution forward.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Solution</code> <p>The initial unpropagated solution.</p> required <code>start_index</code> <code>int</code> <p>The index of the node to begin propagating from.</p> required <p>Returns:</p> Name Type Description <code>solution</code> <code>Solution</code> <p>The forward-propagated solution.</p> Source code in <code>src\\usmlap\\simulation\\solver\\quasi_steady_state.py</code> <pre><code>def propagate_forward(solution: Solution, start_index: int) -&gt; Solution:\n    \"\"\"\n    Propagate the solution forward.\n\n    Args:\n        solution (Solution): The initial unpropagated solution.\n        start_index (int): The index of the node to begin propagating from.\n\n    Returns:\n        solution (Solution): The forward-propagated solution.\n    \"\"\"\n    logger.debug(f\"Forward propagating from apex {start_index}\")\n\n    maximum_velocity = solution.nodes[start_index].maximum_velocity\n    solution.nodes[start_index].set_initial_velocity(maximum_velocity)\n\n    for node in solution.nodes[start_index:]:\n        traction_limited_velocity = traction_limit_velocity(\n            solution.vehicle_model, node\n        )\n        final_velocity = min(traction_limited_velocity, node.maximum_velocity)\n\n        node.set_final_velocity(final_velocity)\n        if node.next is None:\n            break\n        node.next.set_initial_velocity(final_velocity)\n\n        if node.next.is_apex():\n            if final_velocity &lt; node.next.maximum_velocity:\n                node.next.remove_apex()\n            else:\n                break\n\n    logger.debug(f\"Solved forward propogation of apex {start_index}.\")\n    return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solver/quasi_steady_state/#usmlap.simulation.solver.quasi_steady_state.recalculate_state_variables","title":"<code>recalculate_state_variables(solution)</code>","text":"<p>Recalculate the state variables of the vehicle.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Solution</code> <p>The solution object.</p> required <p>Returns:</p> Name Type Description <code>solution</code> <code>Solution</code> <p>The solution with updated state variables.</p> Source code in <code>src\\usmlap\\simulation\\solver\\quasi_steady_state.py</code> <pre><code>def recalculate_state_variables(solution: Solution) -&gt; Solution:\n    \"\"\"\n    Recalculate the state variables of the vehicle.\n\n    Args:\n        solution (Solution): The solution object.\n\n    Returns:\n        solution (Solution): The solution with updated state variables.\n    \"\"\"\n    for i in range(1, len(solution.nodes)):\n        previous_node = solution.nodes[i - 1]\n        updated_soc = (\n            solution.vehicle_model.vehicle.powertrain.update_state_of_charge(\n                state_of_charge=previous_node.state_variables.state_of_charge,\n                energy_used=previous_node.energy_used,\n            )\n        )\n        new_state_variables = StateVariables(state_of_charge=updated_soc)\n        solution.nodes[i].state_variables = new_state_variables\n\n    return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solver/quasi_steady_state/#usmlap.simulation.solver.quasi_steady_state.solve_maximum_velocities","title":"<code>solve_maximum_velocities(solution)</code>","text":"<p>Calculate the theoretical maximum velocity at each node.</p> <p>Nodes are solved independently of each other. Only the potential lateral acceleration of the vehicle is considered. The potential longitudinal acceleration is assumed to be infinite.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Solution</code> <p>The solution with no maximum velocities.</p> required <p>Returns:</p> Name Type Description <code>solution</code> <code>Solution</code> <p>The solution with maximum velocities solved.</p> Source code in <code>src\\usmlap\\simulation\\solver\\quasi_steady_state.py</code> <pre><code>def solve_maximum_velocities(solution: Solution) -&gt; Solution:\n    \"\"\"\n    Calculate the theoretical maximum velocity at each node.\n\n    Nodes are solved independently of each other.\n    Only the potential lateral acceleration of the vehicle is considered.\n    The potential longitudinal acceleration is assumed to be infinite.\n\n    Args:\n        solution (Solution): The solution with no maximum velocities.\n\n    Returns:\n        solution (Solution): The solution with maximum velocities solved.\n    \"\"\"\n    lateral_vehicle_model = solution.vehicle_model.lateral_vehicle_model\n    for node in progress.track(\n        solution.nodes, description=\"Solving maximum velocities...\"\n    ):\n        node.maximum_velocity = lateral_vehicle_model(\n            node.state_variables, node.track_node\n        )\n    return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solver/quasi_steady_state/#usmlap.simulation.solver.quasi_steady_state.traction_limit_velocity","title":"<code>traction_limit_velocity(vehicle_model, node_solution)</code>","text":"<p>Calculate the traction limited velocity at a node when accelerating.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle_model</code> <code>VehicleModelInterface</code> <p>The vehicle model.</p> required <code>node_solution</code> <code>SolutionNode</code> <p>The node solution.</p> required <p>Returns:</p> Name Type Description <code>traction_limited_velocity</code> <code>float</code> <p>The traction limited velocity.</p> Source code in <code>src\\usmlap\\simulation\\solver\\quasi_steady_state.py</code> <pre><code>def traction_limit_velocity(\n    vehicle_model: VehicleModelInterface, node_solution: SolutionNode\n) -&gt; float:\n    \"\"\"\n    Calculate the traction limited velocity at a node when accelerating.\n\n    Args:\n        vehicle_model (VehicleModelInterface): The vehicle model.\n        node_solution (SolutionNode): The node solution.\n\n    Returns:\n        traction_limited_velocity (float): The traction limited velocity.\n    \"\"\"\n    try:\n        traction_limited_acceleration = vehicle_model.calculate_acceleration(\n            node=node_solution.track_node,\n            state_variables=node_solution.state_variables,\n            velocity=node_solution.initial_velocity,\n        )\n        traction_limited_velocity = calculate_next_velocity(\n            initial_velocity=node_solution.initial_velocity,\n            acceleration=traction_limited_acceleration,\n            displacement=node_solution.track_node.length,\n        )\n        return traction_limited_velocity\n    except ValueError:\n        return node_solution.initial_velocity  # TODO\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solver/quasi_steady_state/#usmlap.simulation.solver.quasi_steady_state.traction_limit_velocity_braking","title":"<code>traction_limit_velocity_braking(vehicle_model, node_solution)</code>","text":"<p>Calculate the traction limited velocity at a node when braking.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle_model</code> <code>VehicleModelInterface</code> <p>The vehicle model.</p> required <code>node_solution</code> <code>SolutionNode</code> <p>The node solution.</p> required <p>Returns:</p> Name Type Description <code>traction_limited_velocity</code> <code>float</code> <p>The traction limited velocity.</p> Source code in <code>src\\usmlap\\simulation\\solver\\quasi_steady_state.py</code> <pre><code>def traction_limit_velocity_braking(\n    vehicle_model: VehicleModelInterface, node_solution: SolutionNode\n) -&gt; float:\n    \"\"\"\n    Calculate the traction limited velocity at a node when braking.\n\n    Args:\n        vehicle_model (VehicleModelInterface): The vehicle model.\n        node_solution (SolutionNode): The node solution.\n\n    Returns:\n        traction_limited_velocity (float): The traction limited velocity.\n    \"\"\"\n    try:\n        traction_limited_deceleration = vehicle_model.calculate_deceleration(\n            node=node_solution.track_node,\n            state_variables=node_solution.state_variables,\n            velocity=node_solution.final_velocity,\n        )\n        traction_limited_velocity = calculate_previous_velocity(\n            final_velocity=node_solution.final_velocity,\n            deceleration=traction_limited_deceleration,\n            displacement=node_solution.track_node.length,\n        )\n        return traction_limited_velocity\n    except ValueError:\n        return node_solution.final_velocity  # TODO\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solver/quasi_transient/","title":"quasi_transient","text":"<p>This module implements a quasi-transient solver.</p>"},{"location":"autoapi/usmlap/simulation/solver/quasi_transient/#usmlap.simulation.solver.quasi_transient.QuasiTransientSolver","title":"<code>QuasiTransientSolver</code>","text":"<p>               Bases: <code>SolverInterface</code></p> <p>Quasi-transient solver.</p> Source code in <code>src\\usmlap\\simulation\\solver\\quasi_transient.py</code> <pre><code>class QuasiTransientSolver(SolverInterface):\n    \"\"\"\n    Quasi-transient solver.\n    \"\"\"\n\n    @staticmethod\n    def solve(previous_solution: Solution) -&gt; Solution:\n        times: list[float] = []\n        solution = previous_solution\n\n        for i in range(MAXIMUM_TRANSIENT_ITERATIONS):\n            solution = _solve_next_iteration(previous_solution=solution)\n            times.append(solution.total_time)\n            logging.info(f\"Iteration {i}, time: {solution.total_time:.3f}s\")\n\n            if _convergence_achieved(times, CONVERGENCE_TOLERANCE):\n                logging.info(f\"Converged after {i} iterations.\")\n                break\n\n        return solution\n</code></pre>"},{"location":"autoapi/usmlap/simulation/solver/solver_interface/","title":"solver_interface","text":"<p>This module defines the interface for simulation solvers.</p>"},{"location":"autoapi/usmlap/simulation/solver/solver_interface/#usmlap.simulation.solver.solver_interface.SolverInterface","title":"<code>SolverInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for simulation solvers.</p> Source code in <code>src\\usmlap\\simulation\\solver\\solver_interface.py</code> <pre><code>class SolverInterface(ABC):\n    \"\"\"\n    Abstract base class for simulation solvers.\n    \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def solve(previous_solution: Solution) -&gt; Solution: ...\n</code></pre>"},{"location":"autoapi/usmlap/track/","title":"track","text":""},{"location":"autoapi/usmlap/track/mesh/","title":"mesh","text":"<p>This module contains code for generating a track mesh.</p>"},{"location":"autoapi/usmlap/track/mesh/#usmlap.track.mesh.Mesh","title":"<code>Mesh</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A mesh of a track.</p> <p>Attributes:</p> Name Type Description <code>nodes</code> <code>list[Node]</code> <p>A list of nodes making up the track.</p> <code>configuration</code> <code>Configuration</code> <p>The configuration of the track (OPEN or CLOSED).</p> Source code in <code>src\\usmlap\\track\\mesh.py</code> <pre><code>class Mesh(BaseModel):\n    \"\"\"\n    A mesh of a track.\n\n    Attributes:\n        nodes (list[Node]): A list of nodes making up the track.\n        configuration (Configuration): The configuration of the track\n            (OPEN or CLOSED).\n    \"\"\"\n\n    nodes: list[TrackNode]\n    configuration: Configuration\n\n    @property\n    def node_count(self) -&gt; float:\n        return len(self.nodes)\n\n    @property\n    def track_length(self) -&gt; float:\n        return sum(node.length for node in self.nodes)\n\n    @property\n    def resolution(self) -&gt; float:\n        return self.track_length / self.node_count\n\n    def generate_endurance_mesh(self) -&gt; Mesh:\n        number_of_laps = ceil(ENDURANCE_TRACK_LENGTH / self.track_length)\n\n        endurance_nodes: list[TrackNode] = []\n        for _ in range(number_of_laps):\n            for node in self.nodes:\n                endurance_nodes.append(copy.copy(node))\n\n        position = 0\n        for node in endurance_nodes:\n            node.position = position\n            position += node.length\n\n        return Mesh(nodes=endurance_nodes, configuration=self.configuration)\n\n    def plot_traces(self) -&gt; None:\n        position = [node.position for node in self.nodes]\n        curvature = [node.curvature for node in self.nodes]\n        elevation = [node.elevation for node in self.nodes]\n        inclination = [node.inclination for node in self.nodes]\n        banking = [node.banking for node in self.nodes]\n\n        data: dict[str, list[float]] = {\n            \"Curvature\": curvature,\n            \"Elevation\": elevation,\n            \"Inclination\": inclination,\n            \"Banking\": banking,\n        }\n\n        fig, axs = plt.subplots(len(data), sharex=True)\n        fig.suptitle(\"Track Mesh Parameters\")\n        axs[-1].set_xlabel(\"Position\")\n\n        i = 0\n        for label, ydata in data.items():\n            axs[i].plot(position, ydata)\n            axs[i].set_title(label)\n            axs[i].set_ylabel(label)\n            axs[i].grid()\n            i += 1\n        plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/track/mesh/#usmlap.track.mesh.MeshGenerator","title":"<code>MeshGenerator</code>","text":"<p>               Bases: <code>object</code></p> <p>Generates a mesh from a track data object.</p> <p>Attributes:</p> Name Type Description <code>resolution</code> <code>float</code> <p>The target length of a node in meters.</p> Source code in <code>src\\usmlap\\track\\mesh.py</code> <pre><code>@dataclass\nclass MeshGenerator(object):\n    \"\"\"\n    Generates a mesh from a track data object.\n\n    Attributes:\n        resolution (float): The target length of a node in meters.\n    \"\"\"\n\n    resolution: Annotated[float, Field(gt=0, default=1), Unit(\"m\")]\n\n    def generate_mesh(self, track_data: TrackData) -&gt; Mesh:\n        \"\"\"\n        Generate a mesh from a track data object.\n\n        Args:\n            track_data (TrackData): The track data object.\n\n        Returns:\n            mesh (Mesh): A mesh of the track.\n        \"\"\"\n        self.track_data = track_data\n        self.track_length = track_data.shape.total_length\n        self.node_count = round(self.track_length / self.resolution)\n        self.spacing = self.track_length / (self.node_count - 1)\n        self.position = np.arange(0, self.track_length, self.spacing).tolist()\n\n        length = diff(self.position + [self.track_length])\n        curvature = track_data.shape.interpolate_curvature(self.position)\n        # TODO: Implement code for closing the track\n        # fractional_position = [p / self.track_length for p in position]\n\n        elevation = track_data.elevation.interpolate(self.position)\n        banking = track_data.banking.interpolate(self.position)\n        grip_factor = track_data.grip_factor.interpolate(self.position)\n        sector = track_data.sector.interpolate(self.position)\n        inclination = self._calculate_inclination(self.position, elevation)\n\n        nodes = [\n            TrackNode(\n                position=self.position[i],\n                length=length[i],\n                curvature=curvature[i],\n                elevation=elevation[i],\n                inclination=inclination[i],\n                banking=banking[i],\n                grip_factor=grip_factor[i],\n                sector=sector[i],\n            )\n            for i in range(len(self.position))\n        ]\n\n        return Mesh(nodes=nodes, configuration=track_data.configuration)\n\n    @staticmethod\n    def _calculate_inclination(\n        position: list[float], elevation: list[float]\n    ) -&gt; list[float]:\n        diff_position = diff(position)\n        diff_elevation = diff(elevation)\n        inclination_position = [\n            position[i] + diff_position[i] / 2\n            for i in range(len(diff_position))\n        ]\n        inclination_value = [\n            atan(diff_elevation[i] / diff_position[i])\n            for i in range(len(diff_position))\n        ]\n        return np.interp(\n            position, inclination_position, inclination_value\n        ).tolist()\n</code></pre>"},{"location":"autoapi/usmlap/track/mesh/#usmlap.track.mesh.MeshGenerator.generate_mesh","title":"<code>generate_mesh(track_data)</code>","text":"<p>Generate a mesh from a track data object.</p> <p>Parameters:</p> Name Type Description Default <code>track_data</code> <code>TrackData</code> <p>The track data object.</p> required <p>Returns:</p> Name Type Description <code>mesh</code> <code>Mesh</code> <p>A mesh of the track.</p> Source code in <code>src\\usmlap\\track\\mesh.py</code> <pre><code>def generate_mesh(self, track_data: TrackData) -&gt; Mesh:\n    \"\"\"\n    Generate a mesh from a track data object.\n\n    Args:\n        track_data (TrackData): The track data object.\n\n    Returns:\n        mesh (Mesh): A mesh of the track.\n    \"\"\"\n    self.track_data = track_data\n    self.track_length = track_data.shape.total_length\n    self.node_count = round(self.track_length / self.resolution)\n    self.spacing = self.track_length / (self.node_count - 1)\n    self.position = np.arange(0, self.track_length, self.spacing).tolist()\n\n    length = diff(self.position + [self.track_length])\n    curvature = track_data.shape.interpolate_curvature(self.position)\n    # TODO: Implement code for closing the track\n    # fractional_position = [p / self.track_length for p in position]\n\n    elevation = track_data.elevation.interpolate(self.position)\n    banking = track_data.banking.interpolate(self.position)\n    grip_factor = track_data.grip_factor.interpolate(self.position)\n    sector = track_data.sector.interpolate(self.position)\n    inclination = self._calculate_inclination(self.position, elevation)\n\n    nodes = [\n        TrackNode(\n            position=self.position[i],\n            length=length[i],\n            curvature=curvature[i],\n            elevation=elevation[i],\n            inclination=inclination[i],\n            banking=banking[i],\n            grip_factor=grip_factor[i],\n            sector=sector[i],\n        )\n        for i in range(len(self.position))\n    ]\n\n    return Mesh(nodes=nodes, configuration=track_data.configuration)\n</code></pre>"},{"location":"autoapi/usmlap/track/mesh/#usmlap.track.mesh.TrackNode","title":"<code>TrackNode</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A node of a track.</p> <p>Attributes:</p> Name Type Description <code>Position</code> <code>float</code> <p>The position of the node from the start of the track.</p> <code>Length</code> <code>float</code> <p>The length of the track section.</p> <code>Curvature</code> <code>float</code> <p>The curvature of the track section (left +ve).</p> <code>Elevation</code> <code>float</code> <p>The elevation of the track section.</p> <code>Inclination</code> <code>float</code> <p>The inclination angle of the track section.</p> <code>Banking</code> <code>float</code> <p>The banking angle of the track section (+ve slope right to left).</p> <code>GripFactor</code> <code>float</code> <p>The grip factor of the track section.</p> <code>Sector</code> <code>int</code> <p>The sector of the track section.</p> Source code in <code>src\\usmlap\\track\\mesh.py</code> <pre><code>class TrackNode(BaseModel):\n    \"\"\"\n    A node of a track.\n\n    Attributes:\n        Position (float): The position of the node from the start of the track.\n        Length (float): The length of the track section.\n        Curvature (float): The curvature of the track section (left +ve).\n        Elevation (float): The elevation of the track section.\n        Inclination (float): The inclination angle of the track section.\n        Banking (float): The banking angle of the track section (+ve slope right to left).\n        GripFactor (float): The grip factor of the track section.\n        Sector (int): The sector of the track section.\n    \"\"\"\n\n    position: float = Field(ge=0)\n    length: float = Field(gt=0)\n    curvature: float\n    elevation: float\n    inclination: float = Field(gt=-pi / 2, lt=pi / 2, default=0)\n    banking: float = Field(ge=-pi / 2, le=pi / 2, default=0)\n    grip_factor: float = Field(gt=0, default=1)\n    sector: int = Field(gt=0, default=1)\n\n    @property\n    def radius(self) -&gt; float:\n        return 1 / self.curvature\n\n    def y_to_y(self, value: float) -&gt; float:\n        return value * math.cos(self.banking)\n\n    def y_to_z(self, value: float) -&gt; float:\n        return value * math.sin(self.banking)\n\n    def z_to_x(self, value: float) -&gt; float:\n        return value * math.sin(self.inclination)\n\n    def z_to_y(self, value: float) -&gt; float:\n        return value * math.sin(self.banking)\n\n    def z_to_z(self, value: float) -&gt; float:\n        return value * math.cos(self.banking) * math.cos(self.inclination)\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/","title":"track_data","text":"<p>This module contains code for reading track data from an Excel file.</p>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.BankingData","title":"<code>BankingData</code>","text":"<p>               Bases: <code>LocationData</code></p> <p>Data describing the banking angle of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass BankingData(LocationData):\n    \"\"\"\n    Data describing the banking angle of the track.\n    \"\"\"\n\n    value: list[\n        Annotated[float, Field(ge=-math.pi / 2, le=math.pi / 2), Unit(\"rad\")]\n    ]\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Configuration","title":"<code>Configuration</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the configuration of the track.</p> <p>A closed track returns back to its starting position. An open track can start and end in different locations.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class Configuration(Enum):\n    \"\"\"\n    Enum representing the configuration of the track.\n\n    A closed track returns back to its starting position.\n    An open track can start and end in different locations.\n    \"\"\"\n\n    CLOSED = \"Closed\"\n    OPEN = \"Open\"\n\n    def __str__(self) -&gt; str:\n        return self.name.lower().capitalize()\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Direction","title":"<code>Direction</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the direction of driving.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class Direction(Enum):\n    \"\"\"\n    Enum representing the direction of driving.\n    \"\"\"\n\n    FORWARD = 1\n    BACKWARD = -1\n\n    def __str__(self) -&gt; str:\n        return self.name.lower().capitalize()\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.ElevationData","title":"<code>ElevationData</code>","text":"<p>               Bases: <code>LocationData</code></p> <p>Data describing the elevation of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass ElevationData(LocationData):\n    \"\"\"\n    Data describing the elevation of the track.\n    \"\"\"\n\n    value: list[Annotated[float, Unit(\"m\")]]\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the type of event the track is suitable for.</p> <p>If a track is used to simulate an unsuitable event, a warning will be issued.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class Event(Enum):\n    \"\"\"\n    Enum representing the type of event the track is suitable for.\n\n    If a track is used to simulate an unsuitable event,\n    a warning will be issued.\n    \"\"\"\n\n    ACCELERATION = \"Acceleration\"\n    SKIDPAD = \"Skidpad\"\n    AUTOX = \"AutoX\"\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.GripFactorData","title":"<code>GripFactorData</code>","text":"<p>               Bases: <code>StartpointData[float]</code></p> <p>Data describing the grip factor of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass GripFactorData(StartpointData[float]):\n    \"\"\"\n    Data describing the grip factor of the track.\n    \"\"\"\n\n    value: list[Annotated[float, Field(gt=0)]]\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.LocationData","title":"<code>LocationData</code>","text":"<p>               Bases: <code>PositionData[float]</code></p> <p>Base class for data recorded at a number of locations.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class LocationData(PositionData[float]):\n    \"\"\"\n    Base class for data recorded at a number of locations.\n    \"\"\"\n\n    def interpolate(self, position: list[float]) -&gt; list[float]:\n        return np.interp(position, self.position, self.value).tolist()\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Metadata","title":"<code>Metadata</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata for a track.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the track.</p> <code>country</code> <code>str</code> <p>The country the track is located in.</p> <code>city</code> <code>str</code> <p>The city the track is located near.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class Metadata(BaseModel):\n    \"\"\"\n    Metadata for a track.\n\n    Attributes:\n        name (str): The name of the track.\n        country (str): The country the track is located in.\n        city (str): The city the track is located near.\n    \"\"\"\n\n    name: str | None\n    country: str | None\n    city: str | None\n\n    @property\n    def display_name(self) -&gt; str:\n        \"\"\"\n        The display name for the track.\n\n        If the track has a name, this is returned.\n        Otherwise, \"Unnamed Track\" is returned.\n        \"\"\"\n        return self.name if self.name else \"Unnamed Track\"\n\n    @property\n    def location(self) -&gt; str:\n        \"\"\"\n        The location of the track.\n\n        Uses the city and/or country attributes, if present.\n        Otherwise, an empty string is returned.\n        \"\"\"\n        if self.city and self.country:\n            location = f\"{self.city}, {self.country}\"\n        elif self.city:\n            location = self.city\n        elif self.country:\n            location = self.country\n        else:\n            location = \"\"\n        return location\n\n    def __str__(self) -&gt; str:\n        return f\"{self.display_name}, {self.location}\".strip(\", \")\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Metadata.display_name","title":"<code>display_name</code>  <code>property</code>","text":"<p>The display name for the track.</p> <p>If the track has a name, this is returned. Otherwise, \"Unnamed Track\" is returned.</p>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Metadata.location","title":"<code>location</code>  <code>property</code>","text":"<p>The location of the track.</p> <p>Uses the city and/or country attributes, if present. Otherwise, an empty string is returned.</p>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.PositionData","title":"<code>PositionData</code>","text":"<p>               Bases: <code>Sequence[T]</code>, <code>ABC</code></p> <p>Abstract base class for data recorded against a series of positions.</p> <p>Subclasses must implement the <code>interpolate</code> method.</p> <p>Attributes:</p> Name Type Description <code>position</code> <code>list[float]</code> <p>The positions of the data.</p> <code>value</code> <code>list[T]</code> <p>The values of the data at each position.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass PositionData[T](Sequence[T], ABC):\n    \"\"\"\n    Abstract base class for data recorded against a series of positions.\n\n    Subclasses must implement the `interpolate` method.\n\n    Attributes:\n        position (list[float]): The positions of the data.\n        value (list[T]): The values of the data at each position.\n    \"\"\"\n\n    position: list[Annotated[float, Field(ge=0), Unit(\"m\")]]\n    value: list[T]\n\n    def __post_init__(self) -&gt; None:\n        if len(self.position) != len(self.value):\n            raise ValueError(\"position and value must have the same length\")\n\n    def __len__(self) -&gt; int:\n        return len(self.value)\n\n    @overload\n    def __getitem__(self, key: int) -&gt; T: ...\n\n    @overload\n    def __getitem__(self, key: slice) -&gt; Sequence[T]: ...\n\n    def __getitem__(self, key: int | slice) -&gt; Sequence[T] | T:\n        if isinstance(key, int):\n            return self.value[key]\n        else:\n            return self.__class__(self.position[key], self.value[key])\n\n    @abstractmethod\n    def interpolate(self, position: list[float]) -&gt; list[T]: ...\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.SectionType","title":"<code>SectionType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum representing the type of section of track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class SectionType(Enum):\n    \"\"\"\n    Enum representing the type of section of track.\n    \"\"\"\n\n    STRAIGHT = 0\n    LEFT = 1\n    RIGHT = -1\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.SectorData","title":"<code>SectorData</code>","text":"<p>               Bases: <code>StartpointData[int]</code></p> <p>Data specifying sectors of the track.</p> <p>Sector data has no impact on the simulation, and is used purely for visualisation.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass SectorData(StartpointData[int]):\n    \"\"\"\n    Data specifying sectors of the track.\n\n    Sector data has no impact on the simulation,\n    and is used purely for visualisation.\n    \"\"\"\n\n    value: list[Annotated[int, Field(gt=0)]]\n\n    def list_sectors(self) -&gt; str:\n        return \", \".join(str(value) for value in self.value)\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.Segment","title":"<code>Segment</code>","text":"<p>               Bases: <code>object</code></p> <p>Data describing the shape of a section of track.</p> <p>Attributes:</p> Name Type Description <code>section_type</code> <code>SectionType</code> <p>The type of track section (STRAIGHT, LEFT, or RIGHT).</p> <code>length</code> <code>float</code> <p>The length of the track section.</p> <code>corner_radius</code> <code>float</code> <p>The radius of the section of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass Segment(object):\n    \"\"\"\n    Data describing the shape of a section of track.\n\n    Attributes:\n        section_type (SectionType):\n            The type of track section (STRAIGHT, LEFT, or RIGHT).\n        length (float): The length of the track section.\n        corner_radius (float): The radius of the section of the track.\n    \"\"\"\n\n    model_config = ConfigDict(\n        use_enum_values=True, arbitrary_types_allowed=True\n    )\n\n    section_type: SectionType\n    length: Annotated[float, Field(gt=0), Unit(\"m\")]\n    corner_radius: Annotated[float, Unit(\"m\")]\n\n    def __post_init__(self) -&gt; None:\n        if self.section_type == SectionType.STRAIGHT:\n            self.corner_radius = math.inf\n        else:\n            self.corner_radius = self.corner_radius * self.section_type.value\n\n    @property\n    def curvature(self) -&gt; float:\n        return 1 / self.corner_radius\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.ShapeData","title":"<code>ShapeData</code>","text":"<p>               Bases: <code>object</code></p> <p>Data describing the shape of the track.</p> <p>Attributes:</p> Name Type Description <code>segments</code> <code>list[Segment]</code> <p>The segments making up the track.</p> <code>total_length</code> <code>float</code> <p>The total length of the track.</p> <code>corner_radius</code> <code>float</code> <p>The radius of the section of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>@dataclass\nclass ShapeData(object):\n    \"\"\"\n    Data describing the shape of the track.\n\n    Attributes:\n        segments (list[Segment]): The segments making up the track.\n        total_length (float): The total length of the track.\n        corner_radius (float): The radius of the section of the track.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    # total_length: Annotated[float, Unit(\"m\")]\n    segments: list[Segment]\n\n    @property\n    def total_length(self) -&gt; float:\n        return sum(segment.length for segment in self.segments)\n\n    @property\n    def segment_count(self) -&gt; float:\n        return len(self.segments)\n\n    def interpolate_curvature(\n        self, position: list[float], closed_track: bool = False\n    ) -&gt; list[float]:\n        lengths = [s.length for s in self.segments]\n        end_positions = cumsum(lengths)\n        curvature_position = [\n            position - (0.5 * length)\n            for position, length in zip(end_positions, lengths)\n        ]\n        curvature_value = [s.curvature for s in self.segments]\n        if closed_track:\n            curvature_position.append(end_positions[-1] + (0.5 * lengths[0]))\n            curvature_value.append(curvature_value[0])\n        return np.interp(position, curvature_position, curvature_value).tolist()\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.StartpointData","title":"<code>StartpointData</code>","text":"<p>               Bases: <code>PositionData[T]</code></p> <p>Base class for data recorded with a series of startpoints.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class StartpointData[T](PositionData[T]):\n    \"\"\"\n    Base class for data recorded with a series of startpoints.\n    \"\"\"\n\n    def interpolate(self, position: list[float]) -&gt; list[T]:\n        return interp_previous(position, self.position, self.value)\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackData","title":"<code>TrackData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains information about a racetrack.</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>Metadata</code> <p>Metadata for the track, such as name and location.</p> <code>shape</code> <code>ShapeData</code> <p>Data describing the shape of the track.</p> <code>elevation</code> <code>ElevationData</code> <p>Data describing the track elevation.</p> <code>banking</code> <code>BankingData</code> <p>Data describing the track banking.</p> <code>grip_factor</code> <code>GripFactorData</code> <p>Grip factor data for the track.</p> <code>sector</code> <code>SectorData</code> <p>Data specifying sectors of the track.</p> <code>event</code> <code>Event</code> <p>The type of event the track is suitable for.</p> <code>configuration</code> <code>Configuration</code> <p>The configuration of the track.</p> <code>direction</code> <code>Direction</code> <p>The direction of driving (default = FORWARD).</p> <code>mirror</code> <code>bool</code> <p>Whether the track should be mirrored (default = False).</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class TrackData(BaseModel):\n    \"\"\"\n    Contains information about a racetrack.\n\n    Attributes:\n        metadata (Metadata): Metadata for the track, such as name and location.\n        shape (ShapeData): Data describing the shape of the track.\n        elevation (ElevationData): Data describing the track elevation.\n        banking (BankingData): Data describing the track banking.\n        grip_factor (GripFactorData): Grip factor data for the track.\n        sector (SectorData): Data specifying sectors of the track.\n        event (Event): The type of event the track is suitable for.\n        configuration (Configuration): The configuration of the track.\n        direction (Direction): The direction of driving (default = FORWARD).\n        mirror (bool): Whether the track should be mirrored (default = False).\n    \"\"\"\n\n    model_config = ConfigDict()\n\n    metadata: Metadata\n    shape: ShapeData\n    elevation: ElevationData\n    banking: BankingData\n    grip_factor: GripFactorData\n    sector: SectorData\n    event: Event\n    configuration: Configuration\n    direction: Direction = Direction.FORWARD\n    mirror: bool = False\n\n    def __str__(self) -&gt; str:\n        return (\n            f\"{self.metadata}\\n\\n\"\n            f\"Length: {self.shape.total_length} m\\n\"\n            f\"Configuration: {str(self.configuration)}\\n\"\n            f\"Direction: {str(self.direction)}\\n\"\n            f\"Mirrored: {self.mirror}\\n\\n\"\n            f\"Shape data: {self.shape.segment_count} segments\\n\"\n            f\"Elevation data: {len(self.elevation)} points \"\n            f\"(high: {max(self.elevation)} m, low: {min(self.elevation)} m)\\n\"\n            f\"Banking data: {len(self.banking)} points \"\n            f\"(max: {math.degrees(max(self.banking, key=abs))}\u00b0)\\n\"\n            f\"Grip factor data: {len(self.grip_factor)} points \"\n            f\"(max: {max(self.grip_factor)}, min: {min(self.grip_factor)})\\n\"\n            f\"Sector data: {len(self.sector)} sectors \"\n            f\"({self.sector.list_sectors()})\\n\"\n        )\n\n    @classmethod\n    def load_track_from_spreadsheet(cls, filepath: Path) -&gt; Self:\n        reader = TrackReader(filepath)\n        return cls(\n            metadata=reader.get_metadata(),\n            shape=reader.get_shape_data(),\n            elevation=reader.get_elevation_data(),\n            banking=reader.get_banking_data(),\n            grip_factor=reader.get_grip_factor_data(),\n            sector=reader.get_sector_data(),\n            event=Event.AUTOX,\n            configuration=reader.get_configuration(),\n            direction=reader.get_direction(),\n            mirror=reader.get_mirror(),\n        )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader","title":"<code>TrackReader</code>","text":"<p>               Bases: <code>object</code></p> <p>Reads track data from an OpenLAP Excel spreadsheet.</p> <p>Attributes:</p> Name Type Description <code>workbook</code> <code>ExcelFile</code> <p>The Excel file containing the track data.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>class TrackReader(object):\n    \"\"\"\n    Reads track data from an OpenLAP Excel spreadsheet.\n\n    Attributes:\n        workbook (pandas.ExcelFile): The Excel file containing the track data.\n    \"\"\"\n\n    def __init__(self, filepath: Path) -&gt; None:\n        \"\"\"\n        Initialises the TrackReader from a filepath.\n\n        Args:\n            filepath (Path): Path to the Excel file to be read.\n        \"\"\"\n        self.workbook = pandas.ExcelFile(filepath, engine=\"openpyxl\")\n\n    def _get_info(self) -&gt; pandas.DataFrame:\n        return pandas.read_excel(\n            self.workbook,\n            header=None,\n            sheet_name=\"Info\",\n            usecols=\"A:B\",\n            index_col=0,\n            dtype=str,\n        )\n\n    def get_metadata(self) -&gt; Metadata:\n        \"\"\"Returns the metadata for the track.\"\"\"\n        info = self._get_info()\n        return Metadata(\n            name=str(info.at[\"Name\", 1]),\n            country=str(info.at[\"Country\", 1]),\n            city=str(info.at[\"City\", 1]),\n        )\n\n    def get_shape_data(self) -&gt; ShapeData:\n        \"\"\"Returns the shape data for the track.\"\"\"\n        dataframe = pandas.read_excel(self.workbook, sheet_name=\"Shape\")\n        segments = [\n            Segment(\n                section_type=SectionType[row[\"Type\"].upper()],\n                length=row[\"Section Length\"],\n                corner_radius=row[\"Corner Radius\"],\n            )\n            for _, row in dataframe.iterrows()\n        ]\n        return ShapeData(segments=segments)\n\n    def get_elevation_data(self) -&gt; ElevationData:\n        \"\"\"Returns the elevation data for the track.\"\"\"\n        dataframe = pandas.read_excel(self.workbook, sheet_name=\"Elevation\")\n        return ElevationData(\n            position=dataframe[\"Point [m]\"].tolist(),\n            value=dataframe[\"Elevation [m]\"].tolist(),\n        )\n\n    def get_banking_data(self) -&gt; BankingData:\n        \"\"\"Returns the banking data for the track.\"\"\"\n        dataframe = pandas.read_excel(self.workbook, sheet_name=\"Banking\")\n        return BankingData(\n            position=dataframe[\"Point [m]\"].tolist(),\n            value=dataframe[\"Banking [deg]\"].apply(math.radians).tolist(),\n        )\n\n    def get_grip_factor_data(self) -&gt; GripFactorData:\n        \"\"\"Returns the grip factor data for the track.\"\"\"\n        dataframe = pandas.read_excel(self.workbook, sheet_name=\"Grip Factors\")\n        return GripFactorData(\n            position=dataframe[\"Start Point [m]\"].tolist(),\n            value=dataframe[\"Grip Factor [-]\"].tolist(),\n        )\n\n    def get_sector_data(self) -&gt; SectorData:\n        \"\"\"Returns the sector data for the track.\"\"\"\n        dataframe = pandas.read_excel(self.workbook, sheet_name=\"Sectors\")\n        return SectorData(\n            position=dataframe[\"Start Point [m]\"].tolist(),\n            value=dataframe[\"Sector\"].tolist(),\n        )\n\n    def get_configuration(self) -&gt; Configuration:\n        \"\"\"Returns the configuration of the track.\"\"\"\n        return Configuration[\n            str(self._get_info().at[\"Configuration\", 1]).upper()\n        ]\n\n    def get_direction(self) -&gt; Direction:\n        \"\"\"Returns the direction of driving.\"\"\"\n        return Direction[str(self._get_info().at[\"Direction\", 1]).upper()]\n\n    def get_mirror(self) -&gt; bool:\n        \"\"\"Returns whether the track should be mirrored.\"\"\"\n        mirror_str = str(self._get_info().at[\"Mirror\", 1])\n        return True if mirror_str.lower() in [\"on\", \"yes\", \"true\"] else False\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.__init__","title":"<code>__init__(filepath)</code>","text":"<p>Initialises the TrackReader from a filepath.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Path</code> <p>Path to the Excel file to be read.</p> required Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def __init__(self, filepath: Path) -&gt; None:\n    \"\"\"\n    Initialises the TrackReader from a filepath.\n\n    Args:\n        filepath (Path): Path to the Excel file to be read.\n    \"\"\"\n    self.workbook = pandas.ExcelFile(filepath, engine=\"openpyxl\")\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_banking_data","title":"<code>get_banking_data()</code>","text":"<p>Returns the banking data for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_banking_data(self) -&gt; BankingData:\n    \"\"\"Returns the banking data for the track.\"\"\"\n    dataframe = pandas.read_excel(self.workbook, sheet_name=\"Banking\")\n    return BankingData(\n        position=dataframe[\"Point [m]\"].tolist(),\n        value=dataframe[\"Banking [deg]\"].apply(math.radians).tolist(),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_configuration","title":"<code>get_configuration()</code>","text":"<p>Returns the configuration of the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_configuration(self) -&gt; Configuration:\n    \"\"\"Returns the configuration of the track.\"\"\"\n    return Configuration[\n        str(self._get_info().at[\"Configuration\", 1]).upper()\n    ]\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_direction","title":"<code>get_direction()</code>","text":"<p>Returns the direction of driving.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_direction(self) -&gt; Direction:\n    \"\"\"Returns the direction of driving.\"\"\"\n    return Direction[str(self._get_info().at[\"Direction\", 1]).upper()]\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_elevation_data","title":"<code>get_elevation_data()</code>","text":"<p>Returns the elevation data for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_elevation_data(self) -&gt; ElevationData:\n    \"\"\"Returns the elevation data for the track.\"\"\"\n    dataframe = pandas.read_excel(self.workbook, sheet_name=\"Elevation\")\n    return ElevationData(\n        position=dataframe[\"Point [m]\"].tolist(),\n        value=dataframe[\"Elevation [m]\"].tolist(),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_grip_factor_data","title":"<code>get_grip_factor_data()</code>","text":"<p>Returns the grip factor data for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_grip_factor_data(self) -&gt; GripFactorData:\n    \"\"\"Returns the grip factor data for the track.\"\"\"\n    dataframe = pandas.read_excel(self.workbook, sheet_name=\"Grip Factors\")\n    return GripFactorData(\n        position=dataframe[\"Start Point [m]\"].tolist(),\n        value=dataframe[\"Grip Factor [-]\"].tolist(),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_metadata","title":"<code>get_metadata()</code>","text":"<p>Returns the metadata for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_metadata(self) -&gt; Metadata:\n    \"\"\"Returns the metadata for the track.\"\"\"\n    info = self._get_info()\n    return Metadata(\n        name=str(info.at[\"Name\", 1]),\n        country=str(info.at[\"Country\", 1]),\n        city=str(info.at[\"City\", 1]),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_mirror","title":"<code>get_mirror()</code>","text":"<p>Returns whether the track should be mirrored.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_mirror(self) -&gt; bool:\n    \"\"\"Returns whether the track should be mirrored.\"\"\"\n    mirror_str = str(self._get_info().at[\"Mirror\", 1])\n    return True if mirror_str.lower() in [\"on\", \"yes\", \"true\"] else False\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_sector_data","title":"<code>get_sector_data()</code>","text":"<p>Returns the sector data for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_sector_data(self) -&gt; SectorData:\n    \"\"\"Returns the sector data for the track.\"\"\"\n    dataframe = pandas.read_excel(self.workbook, sheet_name=\"Sectors\")\n    return SectorData(\n        position=dataframe[\"Start Point [m]\"].tolist(),\n        value=dataframe[\"Sector\"].tolist(),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.TrackReader.get_shape_data","title":"<code>get_shape_data()</code>","text":"<p>Returns the shape data for the track.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def get_shape_data(self) -&gt; ShapeData:\n    \"\"\"Returns the shape data for the track.\"\"\"\n    dataframe = pandas.read_excel(self.workbook, sheet_name=\"Shape\")\n    segments = [\n        Segment(\n            section_type=SectionType[row[\"Type\"].upper()],\n            length=row[\"Section Length\"],\n            corner_radius=row[\"Corner Radius\"],\n        )\n        for _, row in dataframe.iterrows()\n    ]\n    return ShapeData(segments=segments)\n</code></pre>"},{"location":"autoapi/usmlap/track/track_data/#usmlap.track.track_data.load_track_from_spreadsheet","title":"<code>load_track_from_spreadsheet(filename)</code>","text":"<p>Load a track from the library.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the track file.</p> required <p>Returns:</p> Name Type Description <code>track_data</code> <code>TrackData</code> <p>The loaded track data.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> Source code in <code>src\\usmlap\\track\\track_data.py</code> <pre><code>def load_track_from_spreadsheet(filename: str) -&gt; TrackData:\n    \"\"\"\n    Load a track from the library.\n\n    Args:\n        filename (str): The name of the track file.\n\n    Returns:\n        track_data (TrackData): The loaded track data.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n    \"\"\"\n    try:\n        filepath = TRACK_LIBRARY / filename\n        reader = TrackReader(filepath)\n        return TrackData(\n            metadata=reader.get_metadata(),\n            shape=reader.get_shape_data(),\n            elevation=reader.get_elevation_data(),\n            banking=reader.get_banking_data(),\n            grip_factor=reader.get_grip_factor_data(),\n            sector=reader.get_sector_data(),\n            event=Event.AUTOX,\n            configuration=reader.get_configuration(),\n            direction=reader.get_direction(),\n            mirror=reader.get_mirror(),\n        )\n    except FileNotFoundError:\n        error_message = (\n            f\"Unable to find '{filename}' in track library. \"\n            f\"Available tracks: {AVAILABLE_TRACKS}\"\n        )\n        raise FileNotFoundError(error_message)\n</code></pre>"},{"location":"autoapi/usmlap/utils/","title":"utils","text":""},{"location":"autoapi/usmlap/utils/array/","title":"array","text":"<p>This module contains functions for working with arrays.</p>"},{"location":"autoapi/usmlap/utils/array/#usmlap.utils.array.cumsum","title":"<code>cumsum(values)</code>","text":"<p>Returns the cumulative sum of a list.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[float]</code> <p>The input list.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: The cumulative sum of values.</p> Source code in <code>src\\usmlap\\utils\\array.py</code> <pre><code>def cumsum(values: list[float]) -&gt; list[float]:\n    \"\"\"\n    Returns the cumulative sum of a list.\n\n    Args:\n        values (list[float]): The input list.\n\n    Returns:\n        list[float]: The cumulative sum of values.\n    \"\"\"\n    return list(accumulate(values))\n</code></pre>"},{"location":"autoapi/usmlap/utils/array/#usmlap.utils.array.diff","title":"<code>diff(x)</code>","text":"<p>Compute the difference between consecutive elements of a list.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>The input list.</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>list[float]</code> <p>The difference between consecutive elements of x. y has one fewer elements than x.</p> Source code in <code>src\\usmlap\\utils\\array.py</code> <pre><code>def diff(x: list[float]) -&gt; list[float]:\n    \"\"\"\n    Compute the difference between consecutive elements of a list.\n\n    Args:\n        x (list[float]): The input list.\n\n    Returns:\n        y (list[float]): The difference between consecutive elements of x.\n            y has one fewer elements than x.\n    \"\"\"\n    assert len(x) &gt; 1, \"x must have at least two elements\"\n    return [x[i + 1] - x[i] for i in range(len(x) - 1)]\n</code></pre>"},{"location":"autoapi/usmlap/utils/array/#usmlap.utils.array.interp_previous","title":"<code>interp_previous(x, xp, yp)</code>","text":"<p>Interpolate a list of values by choosing the previous value.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>The x-coordinates at which to evaluate the interpolated values.</p> required <code>xp</code> <code>list[float]</code> <p>The x-coordinates of the data points. Must be strictly increasing.</p> required <code>yp</code> <code>list[T]</code> <p>The y-coordinates of the data points. Must be the same length as xp.</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>list[T]</code> <p>The interpolated values. The same length as x.</p> Source code in <code>src\\usmlap\\utils\\array.py</code> <pre><code>def interp_previous(x: list[float], xp: list[float], yp: list[T]) -&gt; list[T]:\n    \"\"\"\n    Interpolate a list of values by choosing the previous value.\n\n    Args:\n        x (list[float]):\n            The x-coordinates at which to evaluate the interpolated values.\n        xp (list[float]):\n            The x-coordinates of the data points. Must be strictly increasing.\n        yp (list[T]):\n            The y-coordinates of the data points. Must be the same length as xp.\n\n    Returns:\n        y (list[T]): The interpolated values. The same length as x.\n    \"\"\"\n    assert len(xp) == len(yp), \"xp and yp must have the same length\"\n    xp.append(math.inf)\n    yp.append(yp[-1])\n\n    pos = 0\n    y: list[T] = []\n\n    for i in range(len(x)):\n        while x[i] &gt;= xp[pos + 1]:\n            pos += 1\n        y.append(yp[pos])\n\n    return y\n</code></pre>"},{"location":"autoapi/usmlap/utils/datatypes/","title":"datatypes","text":"<p>This module defines custom datatypes used throughout the project.</p>"},{"location":"autoapi/usmlap/utils/datatypes/#usmlap.utils.datatypes.Coordinate","title":"<code>Coordinate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a coordinate with x, y, and z components.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>x component.</p> <code>y</code> <code>float</code> <p>y component.</p> <code>z</code> <code>float</code> <p>z component (default: 0).</p> Source code in <code>src\\usmlap\\utils\\datatypes.py</code> <pre><code>class Coordinate(BaseModel):\n    \"\"\"\n    Represents a coordinate with x, y, and z components.\n\n    Attributes:\n        x (float): x component.\n        y (float): y component.\n        z (float): z component (default: 0).\n    \"\"\"\n\n    x: float\n    y: float\n    z: float = 0\n\n    def norm(self) -&gt; float:\n        return math.sqrt(self.x**2 + self.y**2 + self.z**2)\n</code></pre>"},{"location":"autoapi/usmlap/utils/datatypes/#usmlap.utils.datatypes.FourCorner","title":"<code>FourCorner</code>","text":"<p>               Bases: <code>tuple[T, T, T, T]</code></p> <p>Represents a property with values for each corner of the vehicle.</p> <p>Attributes:</p> Name Type Description <code>front_left</code> <code>T</code> <p>Value for the front left corner.</p> <code>front_right</code> <code>T</code> <p>Value for the front right corner.</p> <code>rear_left</code> <code>T</code> <p>Value for the rear left corner.</p> <code>rear_right</code> <code>T</code> <p>Value for the rear right corner.</p> Source code in <code>src\\usmlap\\utils\\datatypes.py</code> <pre><code>class FourCorner[T](tuple[T, T, T, T]):\n    \"\"\"\n    Represents a property with values for each corner of the vehicle.\n\n    Attributes:\n        front_left (T): Value for the front left corner.\n        front_right (T): Value for the front right corner.\n        rear_left (T): Value for the rear left corner.\n        rear_right (T): Value for the rear right corner.\n    \"\"\"\n\n    @property\n    def front_left(self) -&gt; T:\n        return self[0]\n\n    @property\n    def front_right(self) -&gt; T:\n        return self[1]\n\n    @property\n    def rear_left(self) -&gt; T:\n        return self[2]\n\n    @property\n    def rear_right(self) -&gt; T:\n        return self[3]\n</code></pre>"},{"location":"autoapi/usmlap/utils/datatypes/#usmlap.utils.datatypes.FrontRear","title":"<code>FrontRear</code>","text":"<p>               Bases: <code>tuple[T, T]</code></p> <p>Represents a property with a front and rear value.</p> <p>Used for properties which differ on each axle of the vehicle.</p> <p>Attributes:</p> Name Type Description <code>front</code> <code>T</code> <p>Value for the front axle.</p> <code>rear</code> <code>T</code> <p>Value for the rear axle.</p> Source code in <code>src\\usmlap\\utils\\datatypes.py</code> <pre><code>class FrontRear[T](tuple[T, T]):\n    \"\"\"\n    Represents a property with a front and rear value.\n\n    Used for properties which differ on each axle of the vehicle.\n\n    Attributes:\n        front (T): Value for the front axle.\n        rear (T): Value for the rear axle.\n    \"\"\"\n\n    @property\n    def front(self) -&gt; T:\n        return self[0]\n\n    @property\n    def rear(self) -&gt; T:\n        return self[1]\n\n    def __str__(self) -&gt; str:\n        return f\"front: {self.front}, rear: {self.rear}\"\n</code></pre>"},{"location":"autoapi/usmlap/utils/datatypes/#usmlap.utils.datatypes.Vector3","title":"<code>Vector3</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Represents a 3D vector with x, y, and z components.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>x component.</p> <code>y</code> <code>float</code> <p>y component.</p> <code>z</code> <code>float</code> <p>z component.</p> Source code in <code>src\\usmlap\\utils\\datatypes.py</code> <pre><code>@dataclass\nclass Vector3(object):\n    \"\"\"\n    Represents a 3D vector with x, y, and z components.\n\n    Attributes:\n        x (float): x component.\n        y (float): y component.\n        z (float): z component.\n    \"\"\"\n\n    x: float = 0\n    y: float = 0\n    z: float = 0\n\n    def __array__(self, dtype: np.dtype | None = None) -&gt; np.ndarray:\n        if dtype:\n            return np.array([self.x, self.y, self.z], dtype=dtype)\n        else:\n            return np.array([self.x, self.y, self.z])\n</code></pre>"},{"location":"autoapi/usmlap/utils/geometry/","title":"geometry","text":"<p>This module contains utility functions for working with geometry, such as calculating areas and volumes.</p>"},{"location":"autoapi/usmlap/utils/geometry/#usmlap.utils.geometry.area_of_circle","title":"<code>area_of_circle(diameter)</code>","text":"<p>Calculate the area of a circle from its diameter.</p> <p>Parameters:</p> Name Type Description Default <code>diameter</code> <code>float</code> <p>Diameter of the circle.</p> required <p>Returns:</p> Name Type Description <code>area</code> <code>float</code> <p>Area of the circle.</p> Source code in <code>src\\usmlap\\utils\\geometry.py</code> <pre><code>def area_of_circle(diameter: float) -&gt; float:\n    \"\"\"\n    Calculate the area of a circle from its diameter.\n\n    Args:\n        diameter (float): Diameter of the circle.\n\n    Returns:\n        area (float): Area of the circle.\n    \"\"\"\n    return pow(diameter, 2) * (pi / 4)\n</code></pre>"},{"location":"autoapi/usmlap/utils/proportion/","title":"proportion","text":"<p>This module contains utility functions for working with proportions.</p>"},{"location":"autoapi/usmlap/utils/proportion/#usmlap.utils.proportion.normalise","title":"<code>normalise(values)</code>","text":"<p>Normalise a tuple of values.</p> <p>Values retain their relative proportions, but sum to 1.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>tuple[float, float]</code> <p>Tuple of values</p> required <p>Returns:</p> Name Type Description <code>normalised_values</code> <code>tuple[float, float]</code> <p>Tuple of normalised values</p> Source code in <code>src\\usmlap\\utils\\proportion.py</code> <pre><code>def normalise(values: tuple[float, ...]):\n    \"\"\"\n    Normalise a tuple of values.\n\n    Values retain their relative proportions, but sum to 1.\n\n    Args:\n        values (tuple[float, float]): Tuple of values\n\n    Returns:\n        normalised_values (tuple[float, float]): Tuple of normalised values\n    \"\"\"\n    total = sum(values)\n    return tuple(v / total for v in values)\n</code></pre>"},{"location":"autoapi/usmlap/utils/proportion/#usmlap.utils.proportion.split","title":"<code>split(total, proportions)</code>","text":"<p>Split a value proportionally</p> <p>Parameters:</p> Name Type Description Default <code>total</code> <code>float</code> <p>Total value</p> required <code>proportions</code> <code>tuple[float, ...]</code> <p>List of proportions</p> required <p>Returns:</p> Name Type Description <code>split_value</code> <code>tuple[float, ...]</code> <p>Total split proportionally according to proportions</p> Source code in <code>src\\usmlap\\utils\\proportion.py</code> <pre><code>def split(total: float, proportions: tuple[float, ...]):\n    \"\"\"\n    Split a value proportionally\n\n    Args:\n        total (float): Total value\n        proportions (tuple[float, ...]): List of proportions\n\n    Returns:\n        split_value (tuple[float, ...]):\n            Total split proportionally according to proportions\n    \"\"\"\n    return tuple(p * total / sum(proportions) for p in proportions)\n</code></pre>"},{"location":"autoapi/usmlap/utils/proportion/#usmlap.utils.proportion.with_complement","title":"<code>with_complement(proportion)</code>","text":"<p>Get a tuple containing a proportion and its complement</p> <p>Parameters:</p> Name Type Description Default <code>proportion</code> <code>float</code> <p>Value between 0 and 1</p> required <p>Returns:</p> Name Type Description <code>proportion_with_complement</code> <code>tuple[float, float]</code> <p>Tuple of proportion and (1 - proportion)</p> Source code in <code>src\\usmlap\\utils\\proportion.py</code> <pre><code>def with_complement(proportion: float) -&gt; tuple[float, float]:\n    \"\"\"\n    Get a tuple containing a proportion and its complement\n\n    Args:\n        proportion (float): Value between 0 and 1\n\n    Returns:\n        proportion_with_complement (tuple[float, float]):\n            Tuple of proportion and (1 - proportion)\n    \"\"\"\n    complement = 1 - proportion\n    return proportion, complement\n</code></pre>"},{"location":"autoapi/usmlap/utils/units/","title":"units","text":"<p>This module contains definitions of physical units and quantities.</p>"},{"location":"autoapi/usmlap/utils/units/#usmlap.utils.units.Quantity","title":"<code>Quantity</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of physical quantities.</p> Source code in <code>src\\usmlap\\utils\\units.py</code> <pre><code>class Quantity(Enum):\n    \"\"\"\n    Enumeration of physical quantities.\n    \"\"\"\n\n    UNITLESS = \"unitless\"\n    TIME = \"time\"\n    LENGTH = \"length\"\n    CURVATURE = \"curvature\"\n    VELOCITY = \"velocity\"\n    ACCELERATION = \"acceleration\"\n    ANGLE = \"angle\"\n    ANGULAR_VELOCITY = \"angular_velocity\"\n    ANGULAR_ACCELERATION = \"angular_acceleration\"\n    MASS = \"mass\"\n    FORCE = \"force\"\n    TORQUE = \"torque\"\n    ENERGY = \"energy\"\n    POWER = \"power\"\n\n    def __str__(self) -&gt; str:\n        return self.value\n</code></pre>"},{"location":"autoapi/usmlap/utils/units/#usmlap.utils.units.Unit","title":"<code>Unit</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of physical units.</p> <p>Attributes:</p> Name Type Description <code>print_name</code> <code>str</code> <p>The name of the unit.</p> <code>quantity</code> <code>Quantity</code> <p>The physical quantity the unit represents.</p> <code>symbol</code> <code>str</code> <p>The symbol of the unit.</p> Source code in <code>src\\usmlap\\utils\\units.py</code> <pre><code>class Unit(Enum):\n    \"\"\"\n    Enumeration of physical units.\n\n    Attributes:\n        print_name (str): The name of the unit.\n        quantity (Quantity): The physical quantity the unit represents.\n        symbol (str): The symbol of the unit.\n    \"\"\"\n\n    def __new__(cls, *args: Any, **kwargs: Any) -&gt; Unit:\n        value = len(cls.__members__) + 1\n        obj = object.__new__(cls)\n        obj._value_ = value\n        return obj\n\n    def __init__(\n        self,\n        name: str,\n        quantity: Quantity,\n        symbol: str,\n        conversion_factor: float = 1,\n    ) -&gt; None:\n        self.print_name = name\n        self.quantity = quantity\n        self.symbol = symbol\n        self.conversion_factor = conversion_factor\n\n    def convert(self, value: float) -&gt; float:\n        return value / self.conversion_factor\n\n    def __str__(self) -&gt; str:\n        return self.symbol\n\n    UNITLESS = (\"unitless\", Quantity.UNITLESS, \"-\")\n    METER = (\"meter\", Quantity.LENGTH, \"m\")\n    PER_METER = (\"per meter\", Quantity.CURVATURE, \"1/m\")\n    SECOND = (\"second\", Quantity.TIME, \"s\")\n    KILOGRAM = (\"kilogram\", Quantity.MASS, \"kg\")\n    RADIAN = (\"radian\", Quantity.ANGLE, \"rad\")\n    RADIANS_PER_SECOND = (\n        \"radians per second\",\n        Quantity.ANGULAR_VELOCITY,\n        \"rad/s\",\n    )\n    RPM = (\"revolutions per minute\", Quantity.ANGULAR_VELOCITY, \"rpm\", pi / 30)\n    METER_PER_SECOND = (\"meter per second\", Quantity.VELOCITY, \"m/s\")\n    KILOMETER_PER_HOUR = (\n        \"kilometer per hour\",\n        Quantity.VELOCITY,\n        \"km/h\",\n        1 / 3.6,\n    )\n    MILE_PER_HOUR = (\"mile per hour\", Quantity.VELOCITY, \"mph\", 0.44704)\n    METER_PER_SECOND_SQUARED = (\n        \"meter per second squared\",\n        Quantity.ACCELERATION,\n        \"m/s^2\",\n    )\n    G = (\"g\", Quantity.ACCELERATION, \"g\", 9.81)\n    NEWTON = (\"newton\", Quantity.FORCE, \"N\")\n    NEWTON_METER = (\"newton meter\", Quantity.TORQUE, \"Nm\")\n    JOULE = (\"joule\", Quantity.ENERGY, \"J\")\n    MEGAJOULE = (\"megajoule\", Quantity.ENERGY, \"MJ\", 1e6)\n    KILOWATT_HOUR = (\"kilowatt hour\", Quantity.ENERGY, \"kWh\", 3.6e6)\n    WATT = (\"watt\", Quantity.POWER, \"W\")\n    KILOWATT = (\"kilowatt\", Quantity.POWER, \"kW\", 1e3)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/","title":"vehicle","text":"<p>This module contains definitions of vehicle components.</p>"},{"location":"autoapi/usmlap/vehicle/aero/","title":"aero","text":"<p>This module models the aerodynamics of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/aero/#usmlap.vehicle.aero.AeroAttitude","title":"<code>AeroAttitude</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Aerodynamic attitude of a vehicle.</p> <p>Attributes:</p> Name Type Description <code>air_density</code> <code>float</code> <p>The density of air.</p> <code>velocity</code> <code>float</code> <p>The velocity of the vehicle.</p> <code>front_ride_height</code> <code>float</code> <p>The front ride height of the vehicle.</p> <code>rear_ride_height</code> <code>float</code> <p>The rear ride height of the vehicle.</p> <code>roll_angle</code> <code>float</code> <p>The roll angle of the vehicle.</p> <code>pitch_angle</code> <code>float</code> <p>The pitch angle of the vehicle.</p> <code>yaw_angle</code> <code>float</code> <p>The yaw angle of the vehicle.</p> Source code in <code>src\\usmlap\\vehicle\\aero.py</code> <pre><code>class AeroAttitude(BaseModel):\n    \"\"\"\n    Aerodynamic attitude of a vehicle.\n\n    Attributes:\n        air_density (float): The density of air.\n        velocity (float): The velocity of the vehicle.\n        front_ride_height (float): The front ride height of the vehicle.\n        rear_ride_height (float): The rear ride height of the vehicle.\n        roll_angle (float): The roll angle of the vehicle.\n        pitch_angle (float): The pitch angle of the vehicle.\n        yaw_angle (float): The yaw angle of the vehicle.\n    \"\"\"\n\n    air_density: float = Field(gt=0)\n    velocity: float = Field(ge=0)\n    front_ride_height: float = Field(ge=0, default=0)\n    rear_ride_height: float = Field(ge=0, default=0)\n    roll_angle: float = Field(ge=-pi / 2, le=pi / 2, default=0)\n    pitch_angle: float = Field(ge=-pi / 2, le=pi / 2, default=0)\n    yaw_angle: float = Field(ge=-pi / 2, le=pi / 2, default=0)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/aero/#usmlap.vehicle.aero.AeroModelInterface","title":"<code>AeroModelInterface</code>","text":"<p>               Bases: <code>ABC</code>, <code>AbstractSubsystem</code></p> <p>Abstract  base class for aero models.</p> Source code in <code>src\\usmlap\\vehicle\\aero.py</code> <pre><code>class AeroModelInterface(ABC, AbstractSubsystem):\n    \"\"\"\n    Abstract  base class for aero models.\n    \"\"\"\n\n    @abstractmethod\n    def get_lift_coefficient(self, attitude: AeroAttitude) -&gt; float: ...\n\n    @abstractmethod\n    def get_drag_coefficient(self, attitude: AeroAttitude) -&gt; float: ...\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/aero/#usmlap.vehicle.aero.AeroPackage","title":"<code>AeroPackage</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The aerodynamic package of a vehicle.</p> <p>Attributes:</p> Name Type Description <code>frontal_area</code> <code>float</code> <p>The frontal area of the vehicle.</p> <code>aero_model</code> <code>AeroModel</code> <p>The aerodynamic model to use.</p> Source code in <code>src\\usmlap\\vehicle\\aero.py</code> <pre><code>class AeroPackage(Subsystem):\n    \"\"\"\n    The aerodynamic package of a vehicle.\n\n    Attributes:\n        frontal_area (float): The frontal area of the vehicle.\n        aero_model (AeroModel): The aerodynamic model to use.\n    \"\"\"\n\n    frontal_area: Annotated[float, Field(gt=0), Unit(\"m^2\")]\n    aero_model: AeroModel\n\n    def get_downforce(self, attitude: AeroAttitude) -&gt; float:\n        lift_coefficient = self.aero_model.get_lift_coefficient(attitude)\n        return self.calculate_aero_force(lift_coefficient, attitude)\n\n    def get_drag(self, attitude: AeroAttitude) -&gt; float:\n        drag_coefficient = self.aero_model.get_drag_coefficient(attitude)\n        return self.calculate_aero_force(drag_coefficient, attitude)\n\n    def calculate_aero_force(\n        self, coefficient: float, attitude: AeroAttitude\n    ) -&gt; float:\n        return (\n            0.5\n            * coefficient\n            * self.frontal_area\n            * attitude.air_density\n            * attitude.velocity**2\n        )\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/aero/#usmlap.vehicle.aero.ConstantAero","title":"<code>ConstantAero</code>","text":"<p>               Bases: <code>AeroModelInterface</code></p> <p>Constant aero model.</p> <p>Lift and drag coefficients do not change with velocity.</p> <p>Attributes:</p> Name Type Description <code>model_type</code> <code>Literal['constant']</code> <p>The type of aero model.</p> <code>lift_coefficient</code> <code>float</code> <p>The lift coefficient (positive).</p> <code>drag_coefficient</code> <code>float</code> <p>The drag coefficient (positive).</p> Source code in <code>src\\usmlap\\vehicle\\aero.py</code> <pre><code>class ConstantAero(AeroModelInterface, type=\"constant\"):\n    \"\"\"\n    Constant aero model.\n\n    Lift and drag coefficients do not change with velocity.\n\n    Attributes:\n        model_type (Literal[\"constant\"]): The type of aero model.\n        lift_coefficient (float): The lift coefficient (positive).\n        drag_coefficient (float): The drag coefficient (positive).\n    \"\"\"\n\n    model_type: Literal[\"constant\"]\n\n    lift_coefficient: float = Field(gt=0)\n    drag_coefficient: float = Field(gt=0)\n\n    def get_lift_coefficient(self, attitude: AeroAttitude) -&gt; float:\n        return self.lift_coefficient\n\n    def get_drag_coefficient(self, attitude: AeroAttitude) -&gt; float:\n        return self.drag_coefficient\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/","title":"brakes","text":"<p>This module models the brake system of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeCaliper","title":"<code>BrakeCaliper</code>","text":"<p>               Bases: <code>Component</code></p> <p>The brake caliper, transmitting force from the brake line to the wheel.</p> <p>Attributes:</p> Name Type Description <code>piston_count</code> <code>int</code> <p>The number of pistons in the caliper.</p> <code>piston_diameter</code> <code>float</code> <p>The diameter of the piston.</p> <code>piston_area</code> <code>float</code> <p>The total area of the pistons.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class BrakeCaliper(Component, library=\"brake_calipers.json\"):\n    \"\"\"\n    The brake caliper, transmitting force from the brake line to the wheel.\n\n    Attributes:\n        piston_count (int): The number of pistons in the caliper.\n        piston_diameter (float): The diameter of the piston.\n        piston_area (float): The total area of the pistons.\n    \"\"\"\n\n    piston_count: PositiveInt\n    piston_diameter: Annotated[PositiveFloat, Unit(\"m\")]\n\n    @property\n    def piston_area(self) -&gt; float:\n        return self.piston_count * geometry.area_of_circle(self.piston_diameter)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeDisc","title":"<code>BrakeDisc</code>","text":"<p>               Bases: <code>Component</code></p> <p>The brake disc attached to the wheel.</p> <p>Attributes:</p> Name Type Description <code>outer_diameter</code> <code>float</code> <p>The outer diameter of the brake disc.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class BrakeDisc(Component, library=\"brake_discs.json\"):\n    \"\"\"\n    The brake disc attached to the wheel.\n\n    Attributes:\n        outer_diameter (float): The outer diameter of the brake disc.\n    \"\"\"\n\n    outer_diameter: Annotated[PositiveFloat, Unit(\"m\")]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine","title":"<code>BrakeLine</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>An individual brake line.</p> <p>Attributes:</p> Name Type Description <code>cylinder</code> <code>MasterCylinder</code> <p>The master cylinder attached to the pedal.</p> <code>caliper</code> <code>BrakeCaliper</code> <p>The brake caliper attached to the wheel.</p> <code>disc</code> <code>BrakeDisc</code> <p>The brake disc attached to the wheel.</p> <code>pad</code> <code>BrakePad</code> <p>The brake pad attached to the caliper.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class BrakeLine(Subsystem):\n    \"\"\"\n    An individual brake line.\n\n    Attributes:\n        cylinder (MasterCylinder): The master cylinder attached to the pedal.\n        caliper (BrakeCaliper): The brake caliper attached to the wheel.\n        disc (BrakeDisc): The brake disc attached to the wheel.\n        pad (BrakePad): The brake pad attached to the caliper.\n    \"\"\"\n\n    cylinder: MasterCylinder\n    caliper: BrakeCaliper\n    disc: BrakeDisc\n    pad: BrakePad\n\n    @property\n    def area_scaling_factor(self) -&gt; float:\n        \"\"\"The force scaling factor between the cylinder and caliper.\"\"\"\n        return self.caliper.piston_area / self.cylinder.piston_area\n\n    @property\n    def effective_radius(self) -&gt; float:\n        \"\"\"The radius at which the braking force is applied to the wheel.\"\"\"\n        return 0.5 * (self.disc.outer_diameter - self.pad.height)\n\n    @property\n    def force_to_torque_scaling_factor(self) -&gt; float:\n        \"\"\"The ratio between braking torque and master cylinder force.\"\"\"\n        return (\n            self.area_scaling_factor\n            * self.pad.coefficient_of_friction\n            * self.effective_radius\n        )\n\n    def get_brake_pressure(self, cylinder_force: float) -&gt; float:\n        \"\"\"\n        Calculate the pressure of the brake fluid.\n\n        Args:\n            cylinder_force (float): Force applied to the master cylinder.\n\n        Returns:\n            brake_pressure (float): Gauge pressure of the brake fluid.\n        \"\"\"\n        return cylinder_force / self.cylinder.piston_area\n\n    def force_to_torque(self, cylinder_force: float) -&gt; float:\n        \"\"\"\n        Calculate the braking torque applied to the wheel.\n\n        Args:\n            cylinder_force (float): Force applied to the master cylinder.\n\n        Returns:\n            braking_torque (float): Torque applied to the wheel.\n        \"\"\"\n        return cylinder_force * self.force_to_torque_scaling_factor\n\n    def torque_to_force(self, braking_torque: float) -&gt; float:\n        \"\"\"\n        Calculate the force required to apply a torque to the wheel.\n\n        Args:\n            braking_torque (float): Braking torque required on the wheel.\n\n        Returns:\n            cylinder_force (float): Force required on the master cylinder.\n        \"\"\"\n        return braking_torque / self.force_to_torque_scaling_factor\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine.area_scaling_factor","title":"<code>area_scaling_factor</code>  <code>property</code>","text":"<p>The force scaling factor between the cylinder and caliper.</p>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine.effective_radius","title":"<code>effective_radius</code>  <code>property</code>","text":"<p>The radius at which the braking force is applied to the wheel.</p>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine.force_to_torque_scaling_factor","title":"<code>force_to_torque_scaling_factor</code>  <code>property</code>","text":"<p>The ratio between braking torque and master cylinder force.</p>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine.force_to_torque","title":"<code>force_to_torque(cylinder_force)</code>","text":"<p>Calculate the braking torque applied to the wheel.</p> <p>Parameters:</p> Name Type Description Default <code>cylinder_force</code> <code>float</code> <p>Force applied to the master cylinder.</p> required <p>Returns:</p> Name Type Description <code>braking_torque</code> <code>float</code> <p>Torque applied to the wheel.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>def force_to_torque(self, cylinder_force: float) -&gt; float:\n    \"\"\"\n    Calculate the braking torque applied to the wheel.\n\n    Args:\n        cylinder_force (float): Force applied to the master cylinder.\n\n    Returns:\n        braking_torque (float): Torque applied to the wheel.\n    \"\"\"\n    return cylinder_force * self.force_to_torque_scaling_factor\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine.get_brake_pressure","title":"<code>get_brake_pressure(cylinder_force)</code>","text":"<p>Calculate the pressure of the brake fluid.</p> <p>Parameters:</p> Name Type Description Default <code>cylinder_force</code> <code>float</code> <p>Force applied to the master cylinder.</p> required <p>Returns:</p> Name Type Description <code>brake_pressure</code> <code>float</code> <p>Gauge pressure of the brake fluid.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>def get_brake_pressure(self, cylinder_force: float) -&gt; float:\n    \"\"\"\n    Calculate the pressure of the brake fluid.\n\n    Args:\n        cylinder_force (float): Force applied to the master cylinder.\n\n    Returns:\n        brake_pressure (float): Gauge pressure of the brake fluid.\n    \"\"\"\n    return cylinder_force / self.cylinder.piston_area\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakeLine.torque_to_force","title":"<code>torque_to_force(braking_torque)</code>","text":"<p>Calculate the force required to apply a torque to the wheel.</p> <p>Parameters:</p> Name Type Description Default <code>braking_torque</code> <code>float</code> <p>Braking torque required on the wheel.</p> required <p>Returns:</p> Name Type Description <code>cylinder_force</code> <code>float</code> <p>Force required on the master cylinder.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>def torque_to_force(self, braking_torque: float) -&gt; float:\n    \"\"\"\n    Calculate the force required to apply a torque to the wheel.\n\n    Args:\n        braking_torque (float): Braking torque required on the wheel.\n\n    Returns:\n        cylinder_force (float): Force required on the master cylinder.\n    \"\"\"\n    return braking_torque / self.force_to_torque_scaling_factor\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.BrakePad","title":"<code>BrakePad</code>","text":"<p>               Bases: <code>Component</code></p> <p>The brake pad attached to the caliper.</p> <p>Attributes:</p> Name Type Description <code>height</code> <code>float</code> <p>The height of the brake pad.</p> <code>coefficient_of_friction</code> <code>float</code> <p>The coefficient of friction between the brake pad and brake disc.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class BrakePad(Component, library=\"brake_pads.json\"):\n    \"\"\"\n    The brake pad attached to the caliper.\n\n    Attributes:\n        height (float): The height of the brake pad.\n        coefficient_of_friction (float):\n            The coefficient of friction between the brake pad and brake disc.\n    \"\"\"\n\n    height: Annotated[PositiveFloat, Unit(\"m\")]\n    coefficient_of_friction: PositiveFloat\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.Brakes","title":"<code>Brakes</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The brake system of the vehicle.</p> <p>Attributes:</p> Name Type Description <code>front</code> <code>BrakeLine</code> <p>Brake line for the front wheels.</p> <code>rear</code> <code>BrakeLine</code> <p>Brake line for the rear wheels.</p> <code>pedal_ratio</code> <code>float</code> <p>Ratio of master cylinder force to pedal force.</p> <code>front_brake_bias</code> <code>float</code> <p>Proportion of force applied to the front master cylinder (value between 0 and 1).</p> <code>regen_torque</code> <code>float</code> <p>Maximum regenerative braking torque.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class Brakes(Subsystem):\n    \"\"\"\n    The brake system of the vehicle.\n\n    Attributes:\n        front (BrakeLine): Brake line for the front wheels.\n        rear (BrakeLine): Brake line for the rear wheels.\n        pedal_ratio (float): Ratio of master cylinder force to pedal force.\n        front_brake_bias (float):\n            Proportion of force applied to the front master cylinder\n            (value between 0 and 1).\n        regen_torque (float): Maximum regenerative braking torque.\n    \"\"\"\n\n    front: BrakeLine\n    rear: BrakeLine\n    pedal_ratio: PositiveFloat\n    front_brake_bias: Percentage\n    regen_torque: Annotated[PositiveFloat, Unit(\"Nm\")]\n\n    @property\n    def brake_bias(self) -&gt; FrontRear[float]:\n        \"\"\"Tuple of brake biases for the front and rear wheels.\"\"\"\n        return FrontRear(proportion.with_complement(self.front_brake_bias))\n\n    @property\n    def brake_lines(self) -&gt; FrontRear[BrakeLine]:\n        \"\"\"Tuple of front and rear brake lines.\"\"\"\n        return FrontRear((self.front, self.rear))\n\n    def _get_front_brake_balance(self) -&gt; float:\n        front_multiplier = self.front.force_to_torque(1)\n        rear_multiplier = self.rear.force_to_torque(1)\n        return front_multiplier / (front_multiplier + rear_multiplier)\n\n    def _get_cylinder_forces(self, pedal_force: float) -&gt; FrontRear[float]:\n        \"\"\"\n        Get the force applied to the front and rear master cylinders.\n\n        Args:\n            pedal_force (float): Force applied to the pedal.\n\n        Returns:\n            cylinder_forces (FrontRear[float]):\n                Force applied to the master cylinders.\n        \"\"\"\n        total_force = pedal_force * self.pedal_ratio\n        return FrontRear([total_force * bias for bias in self.brake_bias])\n\n    def pedal_force_to_wheel_torque(\n        self, pedal_force: float\n    ) -&gt; FrontRear[float]:\n        cylinder_forces = self._get_cylinder_forces(pedal_force)\n        return FrontRear(\n            brake_line.force_to_torque(force)\n            for brake_line, force in zip(self.brake_lines, cylinder_forces)\n        )\n\n    def get_overall_brake_balance(self) -&gt; FrontRear[float]:\n        torques = self.pedal_force_to_wheel_torque(1)\n        return FrontRear(proportion.normalise(torques))\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.Brakes.brake_bias","title":"<code>brake_bias</code>  <code>property</code>","text":"<p>Tuple of brake biases for the front and rear wheels.</p>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.Brakes.brake_lines","title":"<code>brake_lines</code>  <code>property</code>","text":"<p>Tuple of front and rear brake lines.</p>"},{"location":"autoapi/usmlap/vehicle/brakes/#usmlap.vehicle.brakes.MasterCylinder","title":"<code>MasterCylinder</code>","text":"<p>               Bases: <code>Component</code></p> <p>The master cylinder, transmitting force from the pedal to the brake line.</p> <p>Attributes:</p> Name Type Description <code>piston_diameter</code> <code>float</code> <p>The diameter of the piston.</p> <code>colour</code> <code>str</code> <p>The colour of the master cylinder.</p> <code>piston_area</code> <code>float</code> <p>The area of the piston.</p> Source code in <code>src\\usmlap\\vehicle\\brakes.py</code> <pre><code>class MasterCylinder(Component, library=\"master_cylinders.json\"):\n    \"\"\"\n    The master cylinder, transmitting force from the pedal to the brake line.\n\n    Attributes:\n        piston_diameter (float): The diameter of the piston.\n        colour (str): The colour of the master cylinder.\n        piston_area (float): The area of the piston.\n    \"\"\"\n\n    piston_diameter: Annotated[PositiveFloat, Unit(\"m\")]\n    colour: str\n\n    @property\n    def piston_area(self) -&gt; float:\n        return geometry.area_of_circle(self.piston_diameter)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/","title":"common","text":"<p>This module contains code shared by all vehicle components.</p>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.AbstractSubsystem","title":"<code>AbstractSubsystem</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>Abstract base class for subsystems with different implementations.</p> <p>https://typethepipe.com/post/pydantic-discriminated-union/</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>class AbstractSubsystem(Subsystem):\n    \"\"\"\n    Abstract base class for subsystems with different implementations.\n\n    https://typethepipe.com/post/pydantic-discriminated-union/\n    \"\"\"\n\n    _subtypes: ClassVar[dict[str, type]] = {}\n\n    def __init_subclass__(\n        cls: type[AbstractSubsystem], type: Optional[str] = None\n    ) -&gt; None:\n        super().__init_subclass__()\n        if type:\n            cls.type = type\n            if type in cls._subtypes:\n                error_message = (\n                    f\"Class {cls.__name__} cannot be registered \"\n                    f\"with polymorphic type '{type}' \"\n                    f\"because it's already registered \"\n                    f\"to {cls._subtypes[type].__name__}\"\n                )\n                raise AttributeError(error_message)\n            cls._subtypes[type] = cls\n\n    @classmethod\n    def get_subtype_dictionary(cls) -&gt; dict[str, type]:\n        return cls._subtypes\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Component","title":"<code>Component</code>","text":"<p>               Bases: <code>ABC</code>, <code>Subsystem</code></p> <p>Abstract base class for vehicle components.</p> <p>Provides functionality for loading components from a library.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>class Component(ABC, Subsystem):\n    \"\"\"\n    Abstract base class for vehicle components.\n\n    Provides functionality for loading components from a library.\n    \"\"\"\n\n    name: str\n    _library: str\n\n    def __init_subclass__(cls: type[Component], library: str) -&gt; None:\n        super().__init_subclass__()\n        cls._library = library\n\n    @classmethod\n    def _get_library_path(cls) -&gt; str:\n        \"\"\"\n        Get the path to the component library.\n\n        Returns:\n            library_path (str): Path to the component library.\n        \"\"\"\n\n        return \"appdata/library/components/\" + cls._library\n\n    @classmethod\n    def load_library(cls) -&gt; dict[str, JSONDict]:\n        \"\"\"\n        Load the component library as a dictionary.\n\n        The library is loaded from a JSON file,\n        specified by the  `library_name` method.\n\n        Returns:\n            library (dict[str, JSONDict]):\n                A dictionary of components.\n                The component names are used as keys.\n                The values are dictionaries containing component data.\n        \"\"\"\n        with open(cls._get_library_path(), \"r\") as library_file:\n            return json.load(library_file)\n\n    @classmethod\n    def list_components(cls) -&gt; list[str]:\n        \"\"\"\n        Get a list of available components.\n\n        Returns:\n            components (list[str]): Available component names.\n        \"\"\"\n        return list(cls.load_library().keys())\n\n    @classmethod\n    def check_component_exists(cls, name: str) -&gt; None:\n        \"\"\"\n        Check if a component exists in the library.\n\n        Args:\n            name (str): The name of the component.\n\n        Raises:\n            KeyError: If no component with the given name is found.\n        \"\"\"\n        components = cls.list_components()\n        if name not in components:\n            error_message = (\n                f\"Component '{name}' not found \"\n                f\"in library '{cls._library}' \"\n                f\"(available components: {components})\"\n            )\n            raise KeyError(error_message)\n\n    @classmethod\n    def get_component(cls, name: str) -&gt; JSONDict:\n        \"\"\"\n        Select a component from the library.\n\n        The name of the component is added to the returned dictionary.\n\n        Args:\n            name (str): The name of the component.\n\n        Raises:\n            KeyError: If no component with the given name is found.\n\n        Returns:\n            component (JSONDict):\n                A dictionary containing the component data.\n        \"\"\"\n        cls.check_component_exists(name)\n        library = cls.load_library()\n        component = library[name]\n        component[\"name\"] = name\n        return component\n\n    @classmethod\n    def from_library(cls, name: str) -&gt; Self:\n        \"\"\"\n        Create a component object from the library.\n\n        Args:\n            name (str): The name of the component.\n\n        Raises:\n            KeyError: If no component with the given name is found.\n\n        Returns:\n            component (Component): A component object.\n        \"\"\"\n        dictionary = cls.get_component(name)\n        return cls.model_validate(dictionary)\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def expand_component(cls, data: Any) -&gt; Any:\n        \"\"\"\n        JSON deserialiser.\n\n        If a component is specified by a string,\n        this is looked up in the corresponding component library\n        and expanded into a dictionary\n        containing the component data.\n        \"\"\"\n        if isinstance(data, str):\n            data = cls.get_component(data)\n        return data\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Component.check_component_exists","title":"<code>check_component_exists(name)</code>  <code>classmethod</code>","text":"<p>Check if a component exists in the library.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the component.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If no component with the given name is found.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>@classmethod\ndef check_component_exists(cls, name: str) -&gt; None:\n    \"\"\"\n    Check if a component exists in the library.\n\n    Args:\n        name (str): The name of the component.\n\n    Raises:\n        KeyError: If no component with the given name is found.\n    \"\"\"\n    components = cls.list_components()\n    if name not in components:\n        error_message = (\n            f\"Component '{name}' not found \"\n            f\"in library '{cls._library}' \"\n            f\"(available components: {components})\"\n        )\n        raise KeyError(error_message)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Component.expand_component","title":"<code>expand_component(data)</code>  <code>classmethod</code>","text":"<p>JSON deserialiser.</p> <p>If a component is specified by a string, this is looked up in the corresponding component library and expanded into a dictionary containing the component data.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef expand_component(cls, data: Any) -&gt; Any:\n    \"\"\"\n    JSON deserialiser.\n\n    If a component is specified by a string,\n    this is looked up in the corresponding component library\n    and expanded into a dictionary\n    containing the component data.\n    \"\"\"\n    if isinstance(data, str):\n        data = cls.get_component(data)\n    return data\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Component.from_library","title":"<code>from_library(name)</code>  <code>classmethod</code>","text":"<p>Create a component object from the library.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the component.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If no component with the given name is found.</p> <p>Returns:</p> Name Type Description <code>component</code> <code>Component</code> <p>A component object.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>@classmethod\ndef from_library(cls, name: str) -&gt; Self:\n    \"\"\"\n    Create a component object from the library.\n\n    Args:\n        name (str): The name of the component.\n\n    Raises:\n        KeyError: If no component with the given name is found.\n\n    Returns:\n        component (Component): A component object.\n    \"\"\"\n    dictionary = cls.get_component(name)\n    return cls.model_validate(dictionary)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Component.get_component","title":"<code>get_component(name)</code>  <code>classmethod</code>","text":"<p>Select a component from the library.</p> <p>The name of the component is added to the returned dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the component.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If no component with the given name is found.</p> <p>Returns:</p> Name Type Description <code>component</code> <code>JSONDict</code> <p>A dictionary containing the component data.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>@classmethod\ndef get_component(cls, name: str) -&gt; JSONDict:\n    \"\"\"\n    Select a component from the library.\n\n    The name of the component is added to the returned dictionary.\n\n    Args:\n        name (str): The name of the component.\n\n    Raises:\n        KeyError: If no component with the given name is found.\n\n    Returns:\n        component (JSONDict):\n            A dictionary containing the component data.\n    \"\"\"\n    cls.check_component_exists(name)\n    library = cls.load_library()\n    component = library[name]\n    component[\"name\"] = name\n    return component\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Component.list_components","title":"<code>list_components()</code>  <code>classmethod</code>","text":"<p>Get a list of available components.</p> <p>Returns:</p> Name Type Description <code>components</code> <code>list[str]</code> <p>Available component names.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>@classmethod\ndef list_components(cls) -&gt; list[str]:\n    \"\"\"\n    Get a list of available components.\n\n    Returns:\n        components (list[str]): Available component names.\n    \"\"\"\n    return list(cls.load_library().keys())\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Component.load_library","title":"<code>load_library()</code>  <code>classmethod</code>","text":"<p>Load the component library as a dictionary.</p> <p>The library is loaded from a JSON file, specified by the  <code>library_name</code> method.</p> <p>Returns:</p> Name Type Description <code>library</code> <code>dict[str, JSONDict]</code> <p>A dictionary of components. The component names are used as keys. The values are dictionaries containing component data.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>@classmethod\ndef load_library(cls) -&gt; dict[str, JSONDict]:\n    \"\"\"\n    Load the component library as a dictionary.\n\n    The library is loaded from a JSON file,\n    specified by the  `library_name` method.\n\n    Returns:\n        library (dict[str, JSONDict]):\n            A dictionary of components.\n            The component names are used as keys.\n            The values are dictionaries containing component data.\n    \"\"\"\n    with open(cls._get_library_path(), \"r\") as library_file:\n        return json.load(library_file)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Subsystem","title":"<code>Subsystem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Abstract base class for vehicle subsystems.</p> <p>Provides functionality for loading from, and saving to, JSON.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>class Subsystem(BaseModel):\n    \"\"\"\n    Abstract base class for vehicle subsystems.\n\n    Provides functionality for loading from, and saving to, JSON.\n    \"\"\"\n\n    @classmethod\n    def from_json(cls, filepath: Path) -&gt; Self:\n        \"\"\"\n        Load a subsystem from a JSON file.\n\n        Args:\n            filepath (str): The path to the JSON file.\n\n        Returns:\n            subsystem (Self): The loaded subsystem.\n        \"\"\"\n        with open(filepath, \"r\") as file:\n            data = file.read()\n            return cls.model_validate_json(data)\n\n    def to_json(self) -&gt; str:\n        \"\"\"\n        Converts a subsystem to a JSON string.\n\n        Args:\n            self (Subsystem): The subsystem to convert.\n\n        Returns:\n            json_string (str): The JSON string representation of the subsystem.\n        \"\"\"\n        return self.model_dump_json(indent=4)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Subsystem.from_json","title":"<code>from_json(filepath)</code>  <code>classmethod</code>","text":"<p>Load a subsystem from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>The path to the JSON file.</p> required <p>Returns:</p> Name Type Description <code>subsystem</code> <code>Self</code> <p>The loaded subsystem.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>@classmethod\ndef from_json(cls, filepath: Path) -&gt; Self:\n    \"\"\"\n    Load a subsystem from a JSON file.\n\n    Args:\n        filepath (str): The path to the JSON file.\n\n    Returns:\n        subsystem (Self): The loaded subsystem.\n    \"\"\"\n    with open(filepath, \"r\") as file:\n        data = file.read()\n        return cls.model_validate_json(data)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/common/#usmlap.vehicle.common.Subsystem.to_json","title":"<code>to_json()</code>","text":"<p>Converts a subsystem to a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>Subsystem</code> <p>The subsystem to convert.</p> required <p>Returns:</p> Name Type Description <code>json_string</code> <code>str</code> <p>The JSON string representation of the subsystem.</p> Source code in <code>src\\usmlap\\vehicle\\common.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"\n    Converts a subsystem to a JSON string.\n\n    Args:\n        self (Subsystem): The subsystem to convert.\n\n    Returns:\n        json_string (str): The JSON string representation of the subsystem.\n    \"\"\"\n    return self.model_dump_json(indent=4)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/driver/","title":"driver","text":"<p>This module models the driver of the vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/driver/#usmlap.vehicle.driver.Driver","title":"<code>Driver</code>","text":"<p>               Bases: <code>Component</code></p> <p>The driver of the vehicle.</p> <p>Attributes:</p> Name Type Description <code>mass</code> <code>float</code> <p>Mass of the driver.</p> <code>height</code> <code>float</code> <p>Height of the driver.</p> Source code in <code>src\\usmlap\\vehicle\\driver.py</code> <pre><code>class Driver(Component, library=\"drivers.json\"):\n    \"\"\"\n    The driver of the vehicle.\n\n    Attributes:\n        mass (float): Mass of the driver.\n        height (float): Height of the driver.\n    \"\"\"\n\n    mass: float\n    height: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/inertia/","title":"inertia","text":"<p>This module models the inertia of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/inertia/#usmlap.vehicle.inertia.Inertia","title":"<code>Inertia</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>Inertia properties for a vehicle.</p> <p>Attributes:</p> Name Type Description <code>curb_mass</code> <code>float</code> <p>Mass of the vehicle.</p> <code>front_mass_distribution</code> <code>float</code> <p>mass balance</p> <code>yaw_inertia</code> <code>float</code> <p>Yaw inertia of the vehicle.</p> <code>centre_of_gravity_height</code> <code>float</code> <p>Height of the centre of gravity above the ground plane.</p> <code>front_unsprung_mass</code> <code>UnsprungMass</code> <p>Unsprung mass for the front axle.</p> <code>rear_unsprung_mass</code> <code>UnsprungMass</code> <p>Unsprung mass for the rear axle.</p> Source code in <code>src\\usmlap\\vehicle\\inertia.py</code> <pre><code>class Inertia(Subsystem):\n    \"\"\"\n    Inertia properties for a vehicle.\n\n    Attributes:\n        curb_mass (float): Mass of the vehicle.\n        front_mass_distribution (float): mass balance\n        yaw_inertia (float): Yaw inertia of the vehicle.\n        centre_of_gravity_height (float):\n            Height of the centre of gravity above the ground plane.\n        front_unsprung_mass (UnsprungMass): Unsprung mass for the front axle.\n        rear_unsprung_mass (UnsprungMass): Unsprung mass for the rear axle.\n    \"\"\"\n\n    curb_mass: Annotated[PositiveFloat, Unit(\"kg\")]\n    front_mass_distribution: Percentage\n    centre_of_gravity_height: Annotated[PositiveFloat, Unit(\"m\")]\n    yaw_inertia: Annotated[PositiveFloat, Unit(\"kg.m^2\")]\n    front_unsprung_mass: UnsprungMass\n    rear_unsprung_mass: UnsprungMass\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/inertia/#usmlap.vehicle.inertia.UnsprungMass","title":"<code>UnsprungMass</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>Unsprung mass properties for a vehicle.</p> <p>Attributes:</p> Name Type Description <code>mass</code> <code>float</code> <p>Mass of the unsprung mass.</p> <code>centre_of_gravity_height</code> <code>float</code> <p>Height of the centre of gravity above the ground plane.</p> Source code in <code>src\\usmlap\\vehicle\\inertia.py</code> <pre><code>class UnsprungMass(Subsystem):\n    \"\"\"\n    Unsprung mass properties for a vehicle.\n\n    Attributes:\n        mass (float): Mass of the unsprung mass.\n        centre_of_gravity_height (float):\n            Height of the centre of gravity above the ground plane.\n    \"\"\"\n\n    mass: Annotated[PositiveFloat, Unit(\"kg\")]\n    centre_of_gravity_height: Annotated[PositiveFloat, Unit(\"m\")]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/parameters/","title":"parameters","text":"<p>This module contains code for getting and setting vehicle parameters.</p>"},{"location":"autoapi/usmlap/vehicle/parameters/#usmlap.vehicle.parameters.CurbMass","title":"<code>CurbMass</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>The mass of the vehicle without the driver.</p> Source code in <code>src\\usmlap\\vehicle\\parameters.py</code> <pre><code>class CurbMass(Parameter, parameter_name=\"Curb Mass\", unit=\"kg\"):\n    \"\"\"The mass of the vehicle without the driver.\"\"\"\n\n    @staticmethod\n    def get_value(vehicle: Vehicle) -&gt; float:\n        return vehicle.inertia.curb_mass\n\n    @staticmethod\n    def set_value(vehicle: Vehicle, value: float) -&gt; None:\n        vehicle.inertia.curb_mass = value\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/parameters/#usmlap.vehicle.parameters.DragCoefficient","title":"<code>DragCoefficient</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>The drag coefficient of the aero package.</p> Source code in <code>src\\usmlap\\vehicle\\parameters.py</code> <pre><code>class DragCoefficient(Parameter, parameter_name=\"Drag Coefficient\"):\n    \"\"\"The drag coefficient of the aero package.\"\"\"\n\n    @staticmethod\n    def get_value(vehicle: Vehicle) -&gt; float:\n        return vehicle.aero.aero_model.drag_coefficient\n\n    @staticmethod\n    def set_value(vehicle: Vehicle, value: float) -&gt; None:\n        vehicle.aero.aero_model.drag_coefficient = value\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/parameters/#usmlap.vehicle.parameters.FinalDriveRatio","title":"<code>FinalDriveRatio</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>The final drive ratio of the transmission.</p> Source code in <code>src\\usmlap\\vehicle\\parameters.py</code> <pre><code>class FinalDriveRatio(Parameter, parameter_name=\"Final Drive Ratio\"):\n    \"\"\"The final drive ratio of the transmission.\"\"\"\n\n    @staticmethod\n    def get_value(vehicle: Vehicle) -&gt; float:\n        return vehicle.transmission.final_drive_ratio\n\n    @staticmethod\n    def set_value(vehicle: Vehicle, value: float) -&gt; None:\n        vehicle.transmission.final_drive_ratio = value\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/parameters/#usmlap.vehicle.parameters.LiftCoefficient","title":"<code>LiftCoefficient</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>The lift coefficient of the aero package.</p> Source code in <code>src\\usmlap\\vehicle\\parameters.py</code> <pre><code>class LiftCoefficient(Parameter, parameter_name=\"Lift Coefficient\"):\n    \"\"\"The lift coefficient of the aero package.\"\"\"\n\n    @staticmethod\n    def get_value(vehicle: Vehicle) -&gt; float:\n        return vehicle.aero.aero_model.lift_coefficient\n\n    @staticmethod\n    def set_value(vehicle: Vehicle, value: float) -&gt; None:\n        vehicle.aero.aero_model.lift_coefficient = value\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/parameters/#usmlap.vehicle.parameters.Parameter","title":"<code>Parameter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract class representing a vehicle parameter.</p> Source code in <code>src\\usmlap\\vehicle\\parameters.py</code> <pre><code>class Parameter(ABC):\n    \"\"\"\n    An abstract class representing a vehicle parameter.\n    \"\"\"\n\n    _REGISTRY: dict[str, type[Parameter]] = {}\n    name: str\n    unit: Optional[str] = None\n\n    def __init_subclass__(\n        cls: type[Parameter], parameter_name: str, unit: Optional[str] = None\n    ) -&gt; None:\n        super().__init_subclass__()\n        cls._REGISTRY[parameter_name] = cls\n        cls.name = parameter_name\n        cls.unit = unit\n\n    @classmethod\n    def get_parameter(cls, parameter_name: str) -&gt; Parameter:\n        \"\"\"\n        Get a parameter from its name.\n\n        Args:\n            parameter_name (str): The name of the parameter.\n\n        Raises:\n            KeyError: If no parameter with the given name exists.\n\n        Returns:\n            parameter (type[Parameter]): A parameter object.\n        \"\"\"\n        try:\n            return cls._REGISTRY[parameter_name]()\n        except KeyError:\n            error_message = (\n                f\"Parameter '{parameter_name}' not found. \"\n                f\"Available parameters: {list(cls._REGISTRY.keys())}\"\n            )\n            raise KeyError(error_message)\n\n    @classmethod\n    def list_parameters(cls) -&gt; list[str]:\n        \"\"\"\n        Get a list of available parameters.\n\n        Returns:\n            parameters (list[str]): Available parameter names.\n        \"\"\"\n        return list(cls._REGISTRY.keys())\n\n    @classmethod\n    def get_name_with_unit(cls) -&gt; str:\n        if cls.unit:\n            return f\"{cls.name} ({cls.unit})\"\n        else:\n            return f\"{cls.name} (-)\"\n\n    @staticmethod\n    @abstractmethod\n    def get_value(vehicle: Vehicle) -&gt; float:\n        \"\"\"\n        Get the value of a vehicle parameter.\n\n        Args:\n            vehicle (Vehicle): A vehicle object.\n\n        Returns:\n            value (float): The value of the corresponding parameter.\n        \"\"\"\n        ...\n\n    @staticmethod\n    @abstractmethod\n    def set_value(vehicle: Vehicle, value: float) -&gt; None:\n        \"\"\"\n        Set the value of a vehicle parameter.\n\n        Args:\n            vehicle (Vehicle): A vehicle object.\n            value (float): The value to set the parameter to.\n\n        Returns:\n            vehicle (Vehicle): The modified vehicle object.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/parameters/#usmlap.vehicle.parameters.Parameter.get_parameter","title":"<code>get_parameter(parameter_name)</code>  <code>classmethod</code>","text":"<p>Get a parameter from its name.</p> <p>Parameters:</p> Name Type Description Default <code>parameter_name</code> <code>str</code> <p>The name of the parameter.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If no parameter with the given name exists.</p> <p>Returns:</p> Name Type Description <code>parameter</code> <code>type[Parameter]</code> <p>A parameter object.</p> Source code in <code>src\\usmlap\\vehicle\\parameters.py</code> <pre><code>@classmethod\ndef get_parameter(cls, parameter_name: str) -&gt; Parameter:\n    \"\"\"\n    Get a parameter from its name.\n\n    Args:\n        parameter_name (str): The name of the parameter.\n\n    Raises:\n        KeyError: If no parameter with the given name exists.\n\n    Returns:\n        parameter (type[Parameter]): A parameter object.\n    \"\"\"\n    try:\n        return cls._REGISTRY[parameter_name]()\n    except KeyError:\n        error_message = (\n            f\"Parameter '{parameter_name}' not found. \"\n            f\"Available parameters: {list(cls._REGISTRY.keys())}\"\n        )\n        raise KeyError(error_message)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/parameters/#usmlap.vehicle.parameters.Parameter.get_value","title":"<code>get_value(vehicle)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Get the value of a vehicle parameter.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>Vehicle</code> <p>A vehicle object.</p> required <p>Returns:</p> Name Type Description <code>value</code> <code>float</code> <p>The value of the corresponding parameter.</p> Source code in <code>src\\usmlap\\vehicle\\parameters.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef get_value(vehicle: Vehicle) -&gt; float:\n    \"\"\"\n    Get the value of a vehicle parameter.\n\n    Args:\n        vehicle (Vehicle): A vehicle object.\n\n    Returns:\n        value (float): The value of the corresponding parameter.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/parameters/#usmlap.vehicle.parameters.Parameter.list_parameters","title":"<code>list_parameters()</code>  <code>classmethod</code>","text":"<p>Get a list of available parameters.</p> <p>Returns:</p> Name Type Description <code>parameters</code> <code>list[str]</code> <p>Available parameter names.</p> Source code in <code>src\\usmlap\\vehicle\\parameters.py</code> <pre><code>@classmethod\ndef list_parameters(cls) -&gt; list[str]:\n    \"\"\"\n    Get a list of available parameters.\n\n    Returns:\n        parameters (list[str]): Available parameter names.\n    \"\"\"\n    return list(cls._REGISTRY.keys())\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/parameters/#usmlap.vehicle.parameters.Parameter.set_value","title":"<code>set_value(vehicle, value)</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Set the value of a vehicle parameter.</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>Vehicle</code> <p>A vehicle object.</p> required <code>value</code> <code>float</code> <p>The value to set the parameter to.</p> required <p>Returns:</p> Name Type Description <code>vehicle</code> <code>Vehicle</code> <p>The modified vehicle object.</p> Source code in <code>src\\usmlap\\vehicle\\parameters.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef set_value(vehicle: Vehicle, value: float) -&gt; None:\n    \"\"\"\n    Set the value of a vehicle parameter.\n\n    Args:\n        vehicle (Vehicle): A vehicle object.\n        value (float): The value to set the parameter to.\n\n    Returns:\n        vehicle (Vehicle): The modified vehicle object.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/parameters/#usmlap.vehicle.parameters.get_new_vehicle","title":"<code>get_new_vehicle(baseline, parameter, value)</code>","text":"<p>Generate a new vehicle with a modified parameter value.</p> <p>Parameters:</p> Name Type Description Default <code>baseline</code> <code>Vehicle</code> <p>The baseline vehicle to use.</p> required <code>parameter</code> <code>Parameter</code> <p>The parameter to modify.</p> required <code>value</code> <code>float</code> <p>The updated parameter value.</p> required <p>Returns:</p> Name Type Description <code>new_vehicle</code> <code>Vehicle</code> <p>A new vehicle with the updated parameter.</p> Source code in <code>src\\usmlap\\vehicle\\parameters.py</code> <pre><code>def get_new_vehicle(\n    baseline: Vehicle, parameter: Parameter, value: float\n) -&gt; Vehicle:\n    \"\"\"\n    Generate a new vehicle with a modified parameter value.\n\n    Args:\n        baseline (Vehicle): The baseline vehicle to use.\n        parameter (Parameter): The parameter to modify.\n        value (float): The updated parameter value.\n\n    Returns:\n        new_vehicle(Vehicle): A new vehicle with the updated parameter.\n    \"\"\"\n    new_vehicle = deepcopy(baseline)\n    parameter.set_value(new_vehicle, value)\n    return new_vehicle\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/steering/","title":"steering","text":"<p>This module models the steering system of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/steering/#usmlap.vehicle.steering.Steering","title":"<code>Steering</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The steering system of the vehicle.</p> <p>Attributes:</p> Name Type Description <code>steering_ratio</code> <code>float</code> <p>The ratio of steering angle to wheel angle. A steering ratio of 5 means that for every 5 degrees the steering wheel is rotated, the wheels rotate 1 degree.</p> <code>steering_wheel_radius</code> <code>float</code> <p>The radius of the steering wheel. Used for calculating steering torque.</p> Source code in <code>src\\usmlap\\vehicle\\steering.py</code> <pre><code>class Steering(Subsystem):\n    \"\"\"\n    The steering system of the vehicle.\n\n    Attributes:\n        steering_ratio (float):\n            The ratio of steering angle to wheel angle.\n            A steering ratio of 5 means that\n            for every 5 degrees the steering wheel is rotated,\n            the wheels rotate 1 degree.\n        steering_wheel_radius (float):\n            The radius of the steering wheel.\n            Used for calculating steering torque.\n    \"\"\"\n\n    steering_ratio: PositiveFloat\n    steering_wheel_radius: Annotated[PositiveFloat, Unit(\"m\")]\n\n    def get_steering_wheel_angle(self, wheel_angle: float) -&gt; float:\n        \"\"\"\n        Calculate the steering wheel angle required for a given wheel angle.\n\n        Args:\n            wheel_angle (float):\n                Angular displacement of the wheel from static\n                (clockwise positive).\n\n        Returns:\n            steering_wheel_angle (float):\n                Angular displacement of the steering wheel from neutral\n                (clockwise positive).\n        \"\"\"\n        return wheel_angle * self.steering_ratio\n\n    def get_wheel_angle(self, steering_wheel_angle: float) -&gt; float:\n        \"\"\"\n        Calculate the wheel angle for a given steering angle.\n\n        Args:\n            steering_wheel_angle (float):\n                Angular displacement of the steering wheel from neutral\n                (clockwise positive).\n\n        Returns:\n            wheel_angle (float):\n                Angular displacement of the wheels from static\n                (clockwise positive).\n        \"\"\"\n        return steering_wheel_angle / self.steering_ratio\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/steering/#usmlap.vehicle.steering.Steering.get_steering_wheel_angle","title":"<code>get_steering_wheel_angle(wheel_angle)</code>","text":"<p>Calculate the steering wheel angle required for a given wheel angle.</p> <p>Parameters:</p> Name Type Description Default <code>wheel_angle</code> <code>float</code> <p>Angular displacement of the wheel from static (clockwise positive).</p> required <p>Returns:</p> Name Type Description <code>steering_wheel_angle</code> <code>float</code> <p>Angular displacement of the steering wheel from neutral (clockwise positive).</p> Source code in <code>src\\usmlap\\vehicle\\steering.py</code> <pre><code>def get_steering_wheel_angle(self, wheel_angle: float) -&gt; float:\n    \"\"\"\n    Calculate the steering wheel angle required for a given wheel angle.\n\n    Args:\n        wheel_angle (float):\n            Angular displacement of the wheel from static\n            (clockwise positive).\n\n    Returns:\n        steering_wheel_angle (float):\n            Angular displacement of the steering wheel from neutral\n            (clockwise positive).\n    \"\"\"\n    return wheel_angle * self.steering_ratio\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/steering/#usmlap.vehicle.steering.Steering.get_wheel_angle","title":"<code>get_wheel_angle(steering_wheel_angle)</code>","text":"<p>Calculate the wheel angle for a given steering angle.</p> <p>Parameters:</p> Name Type Description Default <code>steering_wheel_angle</code> <code>float</code> <p>Angular displacement of the steering wheel from neutral (clockwise positive).</p> required <p>Returns:</p> Name Type Description <code>wheel_angle</code> <code>float</code> <p>Angular displacement of the wheels from static (clockwise positive).</p> Source code in <code>src\\usmlap\\vehicle\\steering.py</code> <pre><code>def get_wheel_angle(self, steering_wheel_angle: float) -&gt; float:\n    \"\"\"\n    Calculate the wheel angle for a given steering angle.\n\n    Args:\n        steering_wheel_angle (float):\n            Angular displacement of the steering wheel from neutral\n            (clockwise positive).\n\n    Returns:\n        wheel_angle (float):\n            Angular displacement of the wheels from static\n            (clockwise positive).\n    \"\"\"\n    return steering_wheel_angle / self.steering_ratio\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/suspension/","title":"suspension","text":"<p>This module models the suspension of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/suspension/#usmlap.vehicle.suspension.DecoupledSuspension","title":"<code>DecoupledSuspension</code>","text":"<p>               Bases: <code>SuspensionAxle</code></p> <p>Decoupled suspension, with separate heave and roll springs.</p> Source code in <code>src\\usmlap\\vehicle\\suspension.py</code> <pre><code>class DecoupledSuspension(SuspensionAxle, type=\"decoupled\"):\n    \"\"\"\n    Decoupled suspension, with separate heave and roll springs.\n    \"\"\"\n\n    suspension_type: Literal[\"decoupled\"]\n\n    roll_centre_height: Annotated[PositiveFloat, Unit(\"m\")]\n    heave_motion_ratio: PositiveFloat\n    heave_spring_rate: Annotated[PositiveFloat, Unit(\"N/m\")]\n    roll_motion_ratio: PositiveFloat\n    roll_spring_rate: Annotated[PositiveFloat, Unit(\"N/m\")]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/suspension/#usmlap.vehicle.suspension.DirectActuationSuspension","title":"<code>DirectActuationSuspension</code>","text":"<p>               Bases: <code>SuspensionAxle</code></p> <p>Direct actuation suspension, with one spring per corner.</p> Source code in <code>src\\usmlap\\vehicle\\suspension.py</code> <pre><code>class DirectActuationSuspension(SuspensionAxle, type=\"direct_actuation\"):\n    \"\"\"\n    Direct actuation suspension, with one spring per corner.\n    \"\"\"\n\n    suspension_type: Literal[\"direct_actuation\"]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/suspension/#usmlap.vehicle.suspension.Suspension","title":"<code>Suspension</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The suspension system of a vehicle.</p> <p>Attributes:</p> Name Type Description <code>front</code> <code>SuspensionImplementation</code> <p>Front axle suspension.</p> <code>rear</code> <code>SuspensionImplementation</code> <p>Rear axle suspension.</p> <code>wheelbase</code> <code>float</code> <p>The distance between the front and rear wheels, measured between contact patches.</p> <code>front_track_width</code> <code>float</code> <p>The width of the front track, measured between contact patches.</p> <code>rear_track_width</code> <code>float</code> <p>The width of the rear track, measured between contact patches.</p> <code>centre_of_gravity_height</code> <code>float</code> <p>The height of the centre of gravity above the ground plane.</p> Source code in <code>src\\usmlap\\vehicle\\suspension.py</code> <pre><code>class Suspension(Subsystem):\n    \"\"\"\n    The suspension system of a vehicle.\n\n    Attributes:\n        front (SuspensionImplementation):\n            Front axle suspension.\n        rear (SuspensionImplementation):\n            Rear axle suspension.\n        wheelbase (float):\n            The distance between the front and rear wheels,\n            measured between contact patches.\n        front_track_width (float):\n            The width of the front track,\n            measured between contact patches.\n        rear_track_width (float):\n            The width of the rear track,\n            measured between contact patches.\n        centre_of_gravity_height (float):\n            The height of the centre of gravity above the ground plane.\n    \"\"\"\n\n    front: SuspensionImplementation\n    rear: SuspensionImplementation\n    wheelbase: Annotated[PositiveFloat, Unit(\"m\")]\n    centre_of_gravity_height: Annotated[PositiveFloat, Unit(\"m\")]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/suspension/#usmlap.vehicle.suspension.SuspensionAxle","title":"<code>SuspensionAxle</code>","text":"<p>               Bases: <code>ABC</code>, <code>AbstractSubsystem</code></p> <p>Abstract base class for suspension on a single axle of a vehicle.</p> <p>Attributes:</p> Name Type Description <code>track_width</code> <code>float</code> <p>The width of the track, measured between contact patches.</p> Source code in <code>src\\usmlap\\vehicle\\suspension.py</code> <pre><code>class SuspensionAxle(ABC, AbstractSubsystem):\n    \"\"\"\n    Abstract base class for suspension on a single axle of a vehicle.\n\n    Attributes:\n        track_width (float):\n            The width of the track, measured between contact patches.\n    \"\"\"\n\n    track_width: Annotated[PositiveFloat, Unit(\"m\")]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/transmission/","title":"transmission","text":"<p>This module models the transmission of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/transmission/#usmlap.vehicle.transmission.Transmission","title":"<code>Transmission</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The transmission of the vehicle.</p> <p>Transmits power from the motor to the wheels.</p> <p>Attributes:</p> Name Type Description <code>final_drive_ratio</code> <code>float</code> <p>The overall gear reduction of the transmission. A final drive ratio of 3 means that the drive axle rotates once for every 3 revolutions of the motor.</p> Source code in <code>src\\usmlap\\vehicle\\transmission.py</code> <pre><code>class Transmission(Subsystem):\n    \"\"\"\n    The transmission of the vehicle.\n\n    Transmits power from the motor to the wheels.\n\n    Attributes:\n        final_drive_ratio (float):\n            The overall gear reduction of the transmission.\n            A final drive ratio of 3\n            means that the drive axle rotates once\n            for every 3 revolutions of the motor.\n    \"\"\"\n\n    final_drive_ratio: PositiveFloat\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/vehicle/","title":"vehicle","text":"<p>This module models the full vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/vehicle/#usmlap.vehicle.vehicle.Metadata","title":"<code>Metadata</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>Metadata for a vehicle.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the vehicle.</p> <code>year</code> <code>int</code> <p>The year the vehicle was built.</p> <code>description</code> <code>str</code> <p>A description of the vehicle (default = \"\").</p> Source code in <code>src\\usmlap\\vehicle\\vehicle.py</code> <pre><code>class Metadata(Subsystem):\n    \"\"\"\n    Metadata for a vehicle.\n\n    Attributes:\n        name (str): The name of the vehicle.\n        year (int): The year the vehicle was built.\n        description (str): A description of the vehicle (default = \"\").\n    \"\"\"\n\n    name: str\n    year: int\n    description: str = \"\"\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/vehicle/#usmlap.vehicle.vehicle.Vehicle","title":"<code>Vehicle</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The full vehicle.</p> <p>Attributes:</p> Name Type Description <code>metadata</code> <code>Metadata</code> <p>The metadata of the vehicle.</p> <code>driver</code> <code>Driver</code> <p>The driver of the vehicle.</p> <code>aero</code> <code>AeroPackage</code> <p>The aerodynamic package of the vehicle.</p> <code>brakes</code> <code>Brakes</code> <p>The brakes of the vehicle.</p> <code>powertrain</code> <code>RWDPowertrain</code> <p>The powertrain of the vehicle.</p> <code>inertia</code> <code>Inertia</code> <p>The inertia properties of the vehicle.</p> <code>steering</code> <code>Steering</code> <p>The steering of the vehicle.</p> <code>suspension</code> <code>Suspension</code> <p>The suspension of the vehicle.</p> <code>transmission</code> <code>Transmission</code> <p>The transmission of the vehicle.</p> <code>tyres</code> <code>Tyres</code> <p>The tyres of the vehicle.</p> Source code in <code>src\\usmlap\\vehicle\\vehicle.py</code> <pre><code>class Vehicle(Subsystem):\n    \"\"\"\n    The full vehicle.\n\n    Attributes:\n        metadata (Metadata): The metadata of the vehicle.\n        driver (Driver): The driver of the vehicle.\n        aero (AeroPackage): The aerodynamic package of the vehicle.\n        brakes (Brakes): The brakes of the vehicle.\n        powertrain (RWDPowertrain): The powertrain of the vehicle.\n        inertia (Inertia): The inertia properties of the vehicle.\n        steering (Steering): The steering of the vehicle.\n        suspension (Suspension): The suspension of the vehicle.\n        transmission (Transmission): The transmission of the vehicle.\n        tyres (Tyres): The tyres of the vehicle.\n    \"\"\"\n\n    metadata: Metadata\n    driver: Driver\n    aero: AeroPackage\n    brakes: Brakes\n    inertia: Inertia\n    powertrain: RWDPowertrain\n    steering: Steering\n    suspension: Suspension\n    transmission: Transmission\n    tyres: Tyres\n\n    @property\n    def total_mass(self) -&gt; float:\n        return self.inertia.curb_mass + self.driver.mass\n\n    @property\n    def equivalent_mass(self) -&gt; float:\n        return self.total_mass  # TODO\n\n    @property\n    def maximum_velocity(self) -&gt; float:\n        maximum_motor_speed = self.powertrain.get_maximum_motor_speed(1)\n        return self.motor_speed_to_velocity(maximum_motor_speed)\n\n    @property\n    def _overall_motor_scaling(self) -&gt; float:\n        final_drive_ratio = self.transmission.final_drive_ratio\n        tyre_radius = self.tyres.rear.unloaded_radius\n        return final_drive_ratio / tyre_radius\n\n    def motor_torque_to_drive_force(self, motor_torque: float) -&gt; float:\n        return motor_torque * self._overall_motor_scaling\n\n    def traction_force_to_motor_torque(self, traction_force: float) -&gt; float:\n        return traction_force / self._overall_motor_scaling\n\n    def motor_speed_to_velocity(self, motor_speed: float) -&gt; float:\n        return motor_speed / self._overall_motor_scaling\n\n    def velocity_to_motor_speed(self, velocity: float) -&gt; float:\n        return velocity * self._overall_motor_scaling\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/vehicle/#usmlap.vehicle.vehicle.load_vehicle","title":"<code>load_vehicle(filename)</code>","text":"<p>Load a vehicle from the library.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the vehicle file.</p> required <p>Returns:</p> Name Type Description <code>vehicle</code> <code>Vehicle</code> <p>The loaded vehicle.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> Source code in <code>src\\usmlap\\vehicle\\vehicle.py</code> <pre><code>def load_vehicle(filename: str) -&gt; Vehicle:\n    \"\"\"\n    Load a vehicle from the library.\n\n    Args:\n        filename (str): The name of the vehicle file.\n\n    Returns:\n        vehicle (Vehicle): The loaded vehicle.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n    \"\"\"\n    try:\n        filepath = VEHICLE_LIBRARY / filename\n        return Vehicle.from_json(filepath)\n    except FileNotFoundError:\n        error_message = (\n            f\"Unable to find '{filename}' in vehicle library. \"\n            f\"Available vehicles: {AVAILABLE_VEHICLES}\"\n        )\n        raise FileNotFoundError(error_message)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/","title":"powertrain","text":""},{"location":"autoapi/usmlap/vehicle/powertrain/accumulator/","title":"accumulator","text":"<p>This module models the electric accumulator of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/powertrain/accumulator/#usmlap.vehicle.powertrain.accumulator.Accumulator","title":"<code>Accumulator</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>An electric accumulator.</p> <p>Attributes:</p> Name Type Description <code>cell</code> <code>Cell</code> <p>The cell used in the accumulator.</p> <code>cells_in_parallel</code> <code>int</code> <p>Number of cells in parallel.</p> <code>cells_in_series</code> <code>int</code> <p>Number of cells in series.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\accumulator.py</code> <pre><code>class Accumulator(Subsystem):\n    \"\"\"\n    An electric accumulator.\n\n    Attributes:\n        cell (Cell): The cell used in the accumulator.\n        cells_in_parallel (int): Number of cells in parallel.\n        cells_in_series (int): Number of cells in series.\n    \"\"\"\n\n    cell: Cell\n    cells_in_parallel: int\n    cells_in_series: int\n    soc_current_derate_point: float\n\n    @property\n    def number_of_cells(self) -&gt; int:\n        return self.cells_in_parallel * self.cells_in_series\n\n    @property\n    def capacity(self) -&gt; float:\n        return self.cell.capacity * self.number_of_cells\n\n    @property\n    def maximum_voltage(self) -&gt; float:\n        return self.get_voltage(state_of_charge=1)\n\n    @property\n    def minimum_voltage(self) -&gt; float:\n        return self.get_voltage(state_of_charge=0)\n\n    @property\n    def maximum_discharge_current(self) -&gt; float:\n        return self.cell.discharge_current * self.cells_in_parallel\n\n    @property\n    def resistance(self) -&gt; float:\n        return (\n            self.cell.resistance * self.cells_in_series / self.cells_in_parallel\n        )\n\n    def get_voltage(self, state_of_charge: float) -&gt; float:\n        \"\"\"\n        Get the voltage of the accumulator at a given state of charge.\n\n        Args:\n            state_of_charge (float): State of charge, between 0 and 1.\n\n        Returns:\n            voltage (float): Voltage of the accumulator.\n        \"\"\"\n        return self.cell.get_voltage(state_of_charge) * self.cells_in_series\n\n    def get_discharge_current(self, state_of_charge: float) -&gt; float:\n        \"\"\"\n        Get the available discharge current at a given state of charge.\n\n        Above the current derate point,\n        the maximum discharge current is available.\n\n        Below the current derate point,\n        the current is scaled linearly to zero.\n\n        Args:\n            state_of_charge (float): State of charge, between 0 and 1.\n\n        Returns:\n            current (float): Available discharge current.\n        \"\"\"\n        if state_of_charge &gt;= self.soc_current_derate_point:\n            scalar = 1\n        else:\n            scalar = state_of_charge / self.soc_current_derate_point\n\n        return self.maximum_discharge_current * scalar\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/accumulator/#usmlap.vehicle.powertrain.accumulator.Accumulator.get_discharge_current","title":"<code>get_discharge_current(state_of_charge)</code>","text":"<p>Get the available discharge current at a given state of charge.</p> <p>Above the current derate point, the maximum discharge current is available.</p> <p>Below the current derate point, the current is scaled linearly to zero.</p> <p>Parameters:</p> Name Type Description Default <code>state_of_charge</code> <code>float</code> <p>State of charge, between 0 and 1.</p> required <p>Returns:</p> Name Type Description <code>current</code> <code>float</code> <p>Available discharge current.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\accumulator.py</code> <pre><code>def get_discharge_current(self, state_of_charge: float) -&gt; float:\n    \"\"\"\n    Get the available discharge current at a given state of charge.\n\n    Above the current derate point,\n    the maximum discharge current is available.\n\n    Below the current derate point,\n    the current is scaled linearly to zero.\n\n    Args:\n        state_of_charge (float): State of charge, between 0 and 1.\n\n    Returns:\n        current (float): Available discharge current.\n    \"\"\"\n    if state_of_charge &gt;= self.soc_current_derate_point:\n        scalar = 1\n    else:\n        scalar = state_of_charge / self.soc_current_derate_point\n\n    return self.maximum_discharge_current * scalar\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/accumulator/#usmlap.vehicle.powertrain.accumulator.Accumulator.get_voltage","title":"<code>get_voltage(state_of_charge)</code>","text":"<p>Get the voltage of the accumulator at a given state of charge.</p> <p>Parameters:</p> Name Type Description Default <code>state_of_charge</code> <code>float</code> <p>State of charge, between 0 and 1.</p> required <p>Returns:</p> Name Type Description <code>voltage</code> <code>float</code> <p>Voltage of the accumulator.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\accumulator.py</code> <pre><code>def get_voltage(self, state_of_charge: float) -&gt; float:\n    \"\"\"\n    Get the voltage of the accumulator at a given state of charge.\n\n    Args:\n        state_of_charge (float): State of charge, between 0 and 1.\n\n    Returns:\n        voltage (float): Voltage of the accumulator.\n    \"\"\"\n    return self.cell.get_voltage(state_of_charge) * self.cells_in_series\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/accumulator/#usmlap.vehicle.powertrain.accumulator.Cell","title":"<code>Cell</code>","text":"<p>               Bases: <code>Component</code></p> <p>An electrochemical cell.</p> <p>Attributes:</p> Name Type Description <code>capacity</code> <code>float</code> <p>Capacity of the cell.</p> <code>nominal_voltage</code> <code>float</code> <p>Nominal voltage of the cell.</p> <code>charge_voltage</code> <code>float</code> <p>Maximum voltage of the fully charged cell.</p> <code>discharge_voltage</code> <code>float</code> <p>Minimum voltage of the fully discharged cell.</p> <code>discharge_current</code> <code>float</code> <p>Maximum continuous discharge current.</p> <code>resistance</code> <code>float</code> <p>Internal resistance of the cell. Note that this is an approximation, and will be updated later.</p> <code>datasheet_url</code> <code>str</code> <p>URL to the datasheet of the cell.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\accumulator.py</code> <pre><code>class Cell(Component, library=\"cells.json\"):\n    \"\"\"\n    An electrochemical cell.\n\n    Attributes:\n        capacity (float): Capacity of the cell.\n        nominal_voltage (float): Nominal voltage of the cell.\n        charge_voltage (float): Maximum voltage of the fully charged cell.\n        discharge_voltage (float): Minimum voltage of the fully discharged cell.\n        discharge_current (float): Maximum continuous discharge current.\n        resistance (float): Internal resistance of the cell.\n            Note that this is an approximation, and will be updated later.\n        datasheet_url (str): URL to the datasheet of the cell.\n    \"\"\"\n\n    capacity: float\n    nominal_voltage: float\n    charge_voltage: float\n    discharge_voltage: float\n    discharge_current: float\n    resistance: float\n    datasheet_url: str\n\n    def get_voltage(self, state_of_charge: float) -&gt; float:\n        \"\"\"\n        Get approximate cell voltage from state of charge.\n\n        This function interpolates linearly\n        between the charge and discharge voltage.\n\n        Args:\n            state_of_charge (float): State of charge, between 0 and 1.\n\n        Returns:\n            voltage (float): Voltage of the cell.\n        \"\"\"\n        if state_of_charge &lt; 0 or state_of_charge &gt; 1:\n            raise ValueError(\"State of charge must be between 0 and 1.\")\n\n        return (\n            self.charge_voltage * state_of_charge\n            + self.discharge_voltage * (1 - state_of_charge)\n        )\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/accumulator/#usmlap.vehicle.powertrain.accumulator.Cell.get_voltage","title":"<code>get_voltage(state_of_charge)</code>","text":"<p>Get approximate cell voltage from state of charge.</p> <p>This function interpolates linearly between the charge and discharge voltage.</p> <p>Parameters:</p> Name Type Description Default <code>state_of_charge</code> <code>float</code> <p>State of charge, between 0 and 1.</p> required <p>Returns:</p> Name Type Description <code>voltage</code> <code>float</code> <p>Voltage of the cell.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\accumulator.py</code> <pre><code>def get_voltage(self, state_of_charge: float) -&gt; float:\n    \"\"\"\n    Get approximate cell voltage from state of charge.\n\n    This function interpolates linearly\n    between the charge and discharge voltage.\n\n    Args:\n        state_of_charge (float): State of charge, between 0 and 1.\n\n    Returns:\n        voltage (float): Voltage of the cell.\n    \"\"\"\n    if state_of_charge &lt; 0 or state_of_charge &gt; 1:\n        raise ValueError(\"State of charge must be between 0 and 1.\")\n\n    return (\n        self.charge_voltage * state_of_charge\n        + self.discharge_voltage * (1 - state_of_charge)\n    )\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/motor/","title":"motor","text":"<p>This module models the motor of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/powertrain/motor/#usmlap.vehicle.powertrain.motor.Motor","title":"<code>Motor</code>","text":"<p>               Bases: <code>Component</code></p> <p>An electric motor.</p> <p>Attributes:</p> Name Type Description <code>electrical_resistance</code> <code>float</code> <p>Electrical resistance of the motor.</p> <code>peak_torque</code> <code>float</code> <p>Peak torque which the motor can deliver for a short period.</p> <code>continuous_torque</code> <code>float</code> <p>Maximum torque which the motor can deliver continuously.</p> <code>peak_current</code> <code>float</code> <p>Current required to deliver the peak torque.</p> <code>continuous_current</code> <code>float</code> <p>Current required to deliver the continuous torque.</p> <code>maximum_rpm</code> <code>float</code> <p>Maximum rotational speed of the motor.</p> <code>rated_voltage</code> <code>float</code> <p>Rated voltage of the motor.</p> <code>datasheet_url</code> <code>str</code> <p>URL for the datasheet of the motor.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\motor.py</code> <pre><code>class Motor(Component, library=\"motors.json\"):\n    \"\"\"\n    An electric motor.\n\n    Attributes:\n        electrical_resistance (float): Electrical resistance of the motor.\n        peak_torque (float):\n            Peak torque which the motor can deliver for a short period.\n        continuous_torque (float):\n            Maximum torque which the motor can deliver continuously.\n        peak_current (float): Current required to deliver the peak torque.\n        continuous_current (float):\n            Current required to deliver the continuous torque.\n        maximum_rpm (float): Maximum rotational speed of the motor.\n        rated_voltage (float): Rated voltage of the motor.\n        datasheet_url (str): URL for the datasheet of the motor.\n    \"\"\"\n\n    electrical_resistance: float\n    peak_torque: float\n    continuous_torque: float\n    peak_current: float\n    continuous_current: float\n    maximum_rpm: float\n    rated_voltage: float\n    datasheet_url: str\n\n\n    @property\n    def maximum_speed(self) -&gt; float:\n        return rpm_to_rads(self.maximum_rpm)\n\n    @property\n    def speed_per_volt(self) -&gt; float:\n        return self.maximum_speed / self.rated_voltage\n\n    @property\n    def torque_per_amp(self) -&gt; float:\n        return self.peak_torque / self.peak_current\n\n    def get_speed(self, voltage: float) -&gt; float:\n        \"\"\"\n        Calculate the motor speed for an input voltage.\n\n        Args:\n            voltage (float): Voltage applied to the motor.\n\n        Returns:\n            speed (float): Rotational speed of the motor.\n        \"\"\"\n        return voltage * self.speed_per_volt\n\n    def get_torque(self, current: float) -&gt; float:\n        \"\"\"\n        Calculate the motor torque for an input current.\n\n        Args:\n            current (float): Current applied to the motor.\n\n        Returns:\n            torque (float): Torque output of the motor.\n        \"\"\"\n        return current * self.torque_per_amp\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/motor/#usmlap.vehicle.powertrain.motor.Motor.get_speed","title":"<code>get_speed(voltage)</code>","text":"<p>Calculate the motor speed for an input voltage.</p> <p>Parameters:</p> Name Type Description Default <code>voltage</code> <code>float</code> <p>Voltage applied to the motor.</p> required <p>Returns:</p> Name Type Description <code>speed</code> <code>float</code> <p>Rotational speed of the motor.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\motor.py</code> <pre><code>def get_speed(self, voltage: float) -&gt; float:\n    \"\"\"\n    Calculate the motor speed for an input voltage.\n\n    Args:\n        voltage (float): Voltage applied to the motor.\n\n    Returns:\n        speed (float): Rotational speed of the motor.\n    \"\"\"\n    return voltage * self.speed_per_volt\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/motor/#usmlap.vehicle.powertrain.motor.Motor.get_torque","title":"<code>get_torque(current)</code>","text":"<p>Calculate the motor torque for an input current.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>float</code> <p>Current applied to the motor.</p> required <p>Returns:</p> Name Type Description <code>torque</code> <code>float</code> <p>Torque output of the motor.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\motor.py</code> <pre><code>def get_torque(self, current: float) -&gt; float:\n    \"\"\"\n    Calculate the motor torque for an input current.\n\n    Args:\n        current (float): Current applied to the motor.\n\n    Returns:\n        torque (float): Torque output of the motor.\n    \"\"\"\n    return current * self.torque_per_amp\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/motor/#usmlap.vehicle.powertrain.motor.rads_to_rpm","title":"<code>rads_to_rpm(speed)</code>","text":"<p>Convert from radians per second to RPM</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>Speed in radians per second</p> required <p>Returns:</p> Name Type Description <code>rpm</code> <code>float</code> <p>Speed in revolutions per minute</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\motor.py</code> <pre><code>def rads_to_rpm(speed: float) -&gt; float:\n    \"\"\"\n    Convert from radians per second to RPM\n\n    Args:\n        speed (float): Speed in radians per second\n\n    Returns:\n        rpm (float): Speed in revolutions per minute\n    \"\"\"\n    return speed * (30 / math.pi)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/motor/#usmlap.vehicle.powertrain.motor.rpm_to_rads","title":"<code>rpm_to_rads(rpm)</code>","text":"<p>Convert from RPM to radians per second</p> <p>Parameters:</p> Name Type Description Default <code>rpm</code> <code>float</code> <p>Speed in revolutions per minute</p> required <p>Returns:</p> Name Type Description <code>speed</code> <code>float</code> <p>Speed in radians per second</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\motor.py</code> <pre><code>def rpm_to_rads(rpm: float) -&gt; float:\n    \"\"\"\n    Convert from RPM to radians per second\n\n    Args:\n        rpm (float): Speed in revolutions per minute\n\n    Returns:\n        speed (float): Speed in radians per second\n    \"\"\"\n    return rpm * (math.pi / 30)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/motor_controller/","title":"motor_controller","text":"<p>This modules models the motor controller of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/powertrain/motor_controller/#usmlap.vehicle.powertrain.motor_controller.MotorController","title":"<code>MotorController</code>","text":"<p>               Bases: <code>Component</code></p> <p>A motor controller.</p> <p>Attributes:</p> Name Type Description <code>resistance</code> <code>float</code> <p>The resistance of the motor controller.</p> <code>efficiency</code> <code>float</code> <p>The efficiency of the motor controller (approximate).</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\motor_controller.py</code> <pre><code>class MotorController(Component, library=\"motor_controllers.json\"):\n    \"\"\"\n    A motor controller.\n\n    Attributes:\n        resistance: The resistance of the motor controller.\n        efficiency: The efficiency of the motor controller (approximate).\n    \"\"\"\n\n    resistance: float\n    efficiency: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/","title":"powertrain","text":"<p>This module models the electric powertrain of a vehicle.</p>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/#usmlap.vehicle.powertrain.powertrain.MotorCurve","title":"<code>MotorCurve</code>","text":"<p>               Bases: <code>object</code></p> <p>A curve of torque and power vs motor speed.</p> <p>Attributes:</p> Name Type Description <code>speed</code> <code>list[float]</code> <p>Motor speed in rad/s.</p> <code>torque</code> <code>list[float]</code> <p>Corresponding torque at each motor speed.</p> <code>power</code> <code>list[float]</code> <p>Corresponding power at each motor speed.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\powertrain.py</code> <pre><code>@dataclass\nclass MotorCurve(object):\n    \"\"\"\n    A curve of torque and power vs motor speed.\n\n    Attributes:\n        speed (list[float]): Motor speed in rad/s.\n        torque (list[float]): Corresponding torque at each motor speed.\n        power (list[float]): Corresponding power at each motor speed.\n    \"\"\"\n\n    speed: list[float]\n    torque: list[float]\n    power: list[float]\n\n    @property\n    def rpm(self) -&gt; list[float]:\n        return [speed * (30 / np.pi) for speed in self.speed]\n\n    @property\n    def power_kw(self) -&gt; list[float]:\n        return [power / 1000 for power in self.power]\n\n    def plot(self) -&gt; None:\n        \"\"\"\n        Plot the motor curve using matplotlib.\n\n        Torque is plotted on the left axis in blue.\n        Power is plotted on the right axis in green.\n        \"\"\"\n        _, ax_torque = plt.subplots()\n        ax_torque.plot(self.rpm, self.torque, color=\"blue\")\n        ax_torque.set_title(\"Motor Curves\")\n        ax_torque.set_xlabel(\"Motor Speed (RPM)\")\n        ax_torque.set_ylabel(\"Torque (Nm)\")\n        ax_torque.grid()\n\n        ax_power = ax_torque.twinx()\n        ax_power.plot(self.rpm, self.power_kw, color=\"green\")\n        ax_power.set_ylabel(\"Power (kW)\")\n        plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/#usmlap.vehicle.powertrain.powertrain.MotorCurve.plot","title":"<code>plot()</code>","text":"<p>Plot the motor curve using matplotlib.</p> <p>Torque is plotted on the left axis in blue. Power is plotted on the right axis in green.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\powertrain.py</code> <pre><code>def plot(self) -&gt; None:\n    \"\"\"\n    Plot the motor curve using matplotlib.\n\n    Torque is plotted on the left axis in blue.\n    Power is plotted on the right axis in green.\n    \"\"\"\n    _, ax_torque = plt.subplots()\n    ax_torque.plot(self.rpm, self.torque, color=\"blue\")\n    ax_torque.set_title(\"Motor Curves\")\n    ax_torque.set_xlabel(\"Motor Speed (RPM)\")\n    ax_torque.set_ylabel(\"Torque (Nm)\")\n    ax_torque.grid()\n\n    ax_power = ax_torque.twinx()\n    ax_power.plot(self.rpm, self.power_kw, color=\"green\")\n    ax_power.set_ylabel(\"Power (kW)\")\n    plt.show()\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/#usmlap.vehicle.powertrain.powertrain.MotorCurveGenerator","title":"<code>MotorCurveGenerator</code>","text":"<p>               Bases: <code>object</code></p> <p>Generates a motor curve for a powertrain.</p> <p>Attributes:</p> Name Type Description <code>resolution</code> <code>int</code> <p>Number of points to generate.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\powertrain.py</code> <pre><code>@dataclass\nclass MotorCurveGenerator(object):\n    \"\"\"\n    Generates a motor curve for a powertrain.\n\n    Attributes:\n        resolution (int): Number of points to generate.\n    \"\"\"\n\n    resolution: int = 100\n\n    def generate(\n        self, powertrain: RWDPowertrain, state_of_charge: float, current: float\n    ) -&gt; MotorCurve:\n        \"\"\"\n        Generate a motor curve for a powertrain.\n\n        Args:\n            powertrain (RWDPowertrain): Powertrain to generate the curve for.\n            state_of_charge (float): State of charge of the accumulator.\n            current (float): Current drawn from the accumulator.\n\n        Returns:\n            MotorCurve: The generated motor curve.\n        \"\"\"\n        maximum_speed = powertrain.get_maximum_motor_speed(state_of_charge)\n        motor_speeds = np.linspace(0, maximum_speed, self.resolution)\n        motor_torques = np.zeros(self.resolution)\n        for i in range(self.resolution):\n            motor_torques[i] = powertrain.get_motor_torque(\n                state_of_charge, motor_speeds[i]\n            )\n        motor_powers = motor_speeds * motor_torques\n\n        return MotorCurve(\n            speed=motor_speeds.tolist(),\n            torque=motor_torques.tolist(),\n            power=motor_powers.tolist(),\n        )\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/#usmlap.vehicle.powertrain.powertrain.MotorCurveGenerator.generate","title":"<code>generate(powertrain, state_of_charge, current)</code>","text":"<p>Generate a motor curve for a powertrain.</p> <p>Parameters:</p> Name Type Description Default <code>powertrain</code> <code>RWDPowertrain</code> <p>Powertrain to generate the curve for.</p> required <code>state_of_charge</code> <code>float</code> <p>State of charge of the accumulator.</p> required <code>current</code> <code>float</code> <p>Current drawn from the accumulator.</p> required <p>Returns:</p> Name Type Description <code>MotorCurve</code> <code>MotorCurve</code> <p>The generated motor curve.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\powertrain.py</code> <pre><code>def generate(\n    self, powertrain: RWDPowertrain, state_of_charge: float, current: float\n) -&gt; MotorCurve:\n    \"\"\"\n    Generate a motor curve for a powertrain.\n\n    Args:\n        powertrain (RWDPowertrain): Powertrain to generate the curve for.\n        state_of_charge (float): State of charge of the accumulator.\n        current (float): Current drawn from the accumulator.\n\n    Returns:\n        MotorCurve: The generated motor curve.\n    \"\"\"\n    maximum_speed = powertrain.get_maximum_motor_speed(state_of_charge)\n    motor_speeds = np.linspace(0, maximum_speed, self.resolution)\n    motor_torques = np.zeros(self.resolution)\n    for i in range(self.resolution):\n        motor_torques[i] = powertrain.get_motor_torque(\n            state_of_charge, motor_speeds[i]\n        )\n    motor_powers = motor_speeds * motor_torques\n\n    return MotorCurve(\n        speed=motor_speeds.tolist(),\n        torque=motor_torques.tolist(),\n        power=motor_powers.tolist(),\n    )\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/#usmlap.vehicle.powertrain.powertrain.Powertrain","title":"<code>Powertrain</code>","text":"<p>               Bases: <code>ABC</code>, <code>Subsystem</code></p> <p>Abstract base class for powertrain models.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\powertrain.py</code> <pre><code>class Powertrain(ABC, Subsystem):\n    \"\"\"\n    Abstract base class for powertrain models.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/#usmlap.vehicle.powertrain.powertrain.RWDPowertrain","title":"<code>RWDPowertrain</code>","text":"<p>               Bases: <code>Powertrain</code></p> <p>Implements a single motor, rear wheel drive electric powertrain.</p> <p>Attributes:</p> Name Type Description <code>accumulator</code> <code>Accumulator</code> <p>The accumulator storing energy.</p> <code>motor</code> <code>Motor</code> <p>The electric motor.</p> <code>motor_controller</code> <code>MotorController</code> <p>The motor controller.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\powertrain.py</code> <pre><code>class RWDPowertrain(Powertrain):\n    \"\"\"\n    Implements a single motor, rear wheel drive electric powertrain.\n\n    Attributes:\n        accumulator (Accumulator): The accumulator storing energy.\n        motor (Motor): The electric motor.\n        motor_controller (MotorController): The motor controller.\n    \"\"\"\n\n    accumulator: Accumulator\n    motor: Motor\n    motor_controller: MotorController\n\n    def get_voltage_drop(self, current: float) -&gt; float:\n        \"\"\"\n        Calculate the voltage drop across the accumulator and motor controller.\n\n        Args:\n            current (float): Current drawn from the accumulator.\n\n        Returns:\n            voltage_drop (float): Voltage drop.\n        \"\"\"\n        resistance = (\n            self.accumulator.resistance + self.motor_controller.resistance\n        )\n        return current * resistance\n\n    def get_motor_voltage(\n        self, state_of_charge: float, current: float\n    ) -&gt; float:\n        \"\"\"\n        Calculate the voltage applied to the motor.\n\n        Args:\n            state_of_charge (float): State of charge of the accumulator.\n            current (float): Current drawn from the accumulator.\n\n        Returns:\n            motor_voltage (float): Voltage across the motor.\n        \"\"\"\n        accumulator_voltage = self.accumulator.get_voltage(state_of_charge)\n        voltage_drop = self.get_voltage_drop(current)\n        return accumulator_voltage - voltage_drop\n\n    def get_knee_speed(self, state_of_charge: float, current: float) -&gt; float:\n        \"\"\"\n        Calculate the knee speed of the motor.\n\n        Args:\n            state_of_charge (float): State of charge of the accumulator.\n            current (float): Current drawn from the accumulator.\n\n        Returns:\n            knee_speed (float): Knee speed of the motor.\n        \"\"\"\n        motor_voltage = self.get_motor_voltage(state_of_charge, current)\n        knee_speed = self.motor.get_speed(motor_voltage)\n        return knee_speed\n\n    def get_maximum_motor_speed(self, state_of_charge: float) -&gt; float:\n        \"\"\"\n        Calculate the maximum speed of the motor.\n\n        Args:\n            state_of_charge (float): State of charge of the accumulator.\n\n        Returns:\n            maximum_speed (float): Maximum speed of the motor.\n        \"\"\"\n        return self.get_knee_speed(state_of_charge, 0)\n\n    def get_motor_torque(\n        self, state_of_charge: float, motor_speed: float\n    ) -&gt; float:\n        current = self.accumulator.get_discharge_current(state_of_charge)\n        knee_speed = self.get_knee_speed(state_of_charge, current)\n        maximum_speed = self.get_maximum_motor_speed(state_of_charge)\n        maximum_torque = self.motor.get_torque(current)\n\n        if motor_speed &lt; knee_speed:\n            return maximum_torque\n        elif motor_speed &gt;= maximum_speed:\n            return 0\n        else:\n            return (\n                maximum_torque\n                * (maximum_speed - motor_speed)\n                / (maximum_speed - knee_speed)\n            )\n\n    def get_motor_power(\n        self, state_of_charge: float, motor_speed: float\n    ) -&gt; float:\n        torque = self.get_motor_torque(state_of_charge, motor_speed)\n        power = motor_speed * torque\n        return power\n\n    def plot_motor_curve(self, state_of_charge: float = 1) -&gt; None:\n        motor_curve = MotorCurveGenerator().generate(\n            powertrain=self,\n            state_of_charge=state_of_charge,\n            current=self.accumulator.maximum_discharge_current,\n        )\n        motor_curve.plot()\n\n    def get_powertrain_efficiency(self) -&gt; float:\n        return 0.8  # TODO: efficiency calculation\n\n    def motor_to_accumulator_power(self, motor_power: float) -&gt; float:\n        return motor_power / self.get_powertrain_efficiency()\n\n    def update_state_of_charge(\n        self, state_of_charge: float, energy_used: float\n    ) -&gt; float:\n        state_of_charge_used = energy_used / self.accumulator.capacity\n        return state_of_charge - state_of_charge_used\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/#usmlap.vehicle.powertrain.powertrain.RWDPowertrain.get_knee_speed","title":"<code>get_knee_speed(state_of_charge, current)</code>","text":"<p>Calculate the knee speed of the motor.</p> <p>Parameters:</p> Name Type Description Default <code>state_of_charge</code> <code>float</code> <p>State of charge of the accumulator.</p> required <code>current</code> <code>float</code> <p>Current drawn from the accumulator.</p> required <p>Returns:</p> Name Type Description <code>knee_speed</code> <code>float</code> <p>Knee speed of the motor.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\powertrain.py</code> <pre><code>def get_knee_speed(self, state_of_charge: float, current: float) -&gt; float:\n    \"\"\"\n    Calculate the knee speed of the motor.\n\n    Args:\n        state_of_charge (float): State of charge of the accumulator.\n        current (float): Current drawn from the accumulator.\n\n    Returns:\n        knee_speed (float): Knee speed of the motor.\n    \"\"\"\n    motor_voltage = self.get_motor_voltage(state_of_charge, current)\n    knee_speed = self.motor.get_speed(motor_voltage)\n    return knee_speed\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/#usmlap.vehicle.powertrain.powertrain.RWDPowertrain.get_maximum_motor_speed","title":"<code>get_maximum_motor_speed(state_of_charge)</code>","text":"<p>Calculate the maximum speed of the motor.</p> <p>Parameters:</p> Name Type Description Default <code>state_of_charge</code> <code>float</code> <p>State of charge of the accumulator.</p> required <p>Returns:</p> Name Type Description <code>maximum_speed</code> <code>float</code> <p>Maximum speed of the motor.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\powertrain.py</code> <pre><code>def get_maximum_motor_speed(self, state_of_charge: float) -&gt; float:\n    \"\"\"\n    Calculate the maximum speed of the motor.\n\n    Args:\n        state_of_charge (float): State of charge of the accumulator.\n\n    Returns:\n        maximum_speed (float): Maximum speed of the motor.\n    \"\"\"\n    return self.get_knee_speed(state_of_charge, 0)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/#usmlap.vehicle.powertrain.powertrain.RWDPowertrain.get_motor_voltage","title":"<code>get_motor_voltage(state_of_charge, current)</code>","text":"<p>Calculate the voltage applied to the motor.</p> <p>Parameters:</p> Name Type Description Default <code>state_of_charge</code> <code>float</code> <p>State of charge of the accumulator.</p> required <code>current</code> <code>float</code> <p>Current drawn from the accumulator.</p> required <p>Returns:</p> Name Type Description <code>motor_voltage</code> <code>float</code> <p>Voltage across the motor.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\powertrain.py</code> <pre><code>def get_motor_voltage(\n    self, state_of_charge: float, current: float\n) -&gt; float:\n    \"\"\"\n    Calculate the voltage applied to the motor.\n\n    Args:\n        state_of_charge (float): State of charge of the accumulator.\n        current (float): Current drawn from the accumulator.\n\n    Returns:\n        motor_voltage (float): Voltage across the motor.\n    \"\"\"\n    accumulator_voltage = self.accumulator.get_voltage(state_of_charge)\n    voltage_drop = self.get_voltage_drop(current)\n    return accumulator_voltage - voltage_drop\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/powertrain/powertrain/#usmlap.vehicle.powertrain.powertrain.RWDPowertrain.get_voltage_drop","title":"<code>get_voltage_drop(current)</code>","text":"<p>Calculate the voltage drop across the accumulator and motor controller.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>float</code> <p>Current drawn from the accumulator.</p> required <p>Returns:</p> Name Type Description <code>voltage_drop</code> <code>float</code> <p>Voltage drop.</p> Source code in <code>src\\usmlap\\vehicle\\powertrain\\powertrain.py</code> <pre><code>def get_voltage_drop(self, current: float) -&gt; float:\n    \"\"\"\n    Calculate the voltage drop across the accumulator and motor controller.\n\n    Args:\n        current (float): Current drawn from the accumulator.\n\n    Returns:\n        voltage_drop (float): Voltage drop.\n    \"\"\"\n    resistance = (\n        self.accumulator.resistance + self.motor_controller.resistance\n    )\n    return current * resistance\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/","title":"tyre","text":""},{"location":"autoapi/usmlap/vehicle/tyre/magic_formula/","title":"magic_formula","text":"<p>This module implements the Pacejka Magic Formula tyre model.</p> <p>Equations are taken from Chapter 4.3.2 of Tire and Vehicle Dynamics (3rd Edition) by Hans Pacejka, and numbered accordingly. https://www.sciencedirect.com/book/9780080970165/tire-and-vehicle-dynamics</p> <p>These equations are in accordance with the MF-Tire/MF-Swift 6.1.2 Equation Manual, or MF612 for short.</p> <p>The following repositories have been used as a starting point for this module:</p> <ul> <li> <p>Tire Dynamics (Python):     https://github.com/JyNing04/Pacejka-tire-model/tree/main</p> </li> <li> <p>Magic Formula Tyre Library (MATLAB):     https://github.com/teasit/magic-formula-tyre-library/tree/main</p> </li> </ul>"},{"location":"autoapi/usmlap/vehicle/tyre/magic_formula/#usmlap.vehicle.tyre.magic_formula.MagicFormula","title":"<code>MagicFormula</code>","text":"<p>               Bases: <code>object</code></p> <p>Contains the Pacejka Magic Formula equations.</p> <p>Attributes:</p> Name Type Description <code>parameters</code> <code>TIRParameters</code> <p>Tyre parameters loaded from a .TIR file.</p> <code>AMU</code> <code>float</code> <p>Constant used in calculation of digressive friction factor.</p> <code>LMUV</code> <code>float</code> <p>Scaling factor with slip speed vs decaying friction.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\magic_formula.py</code> <pre><code>class MagicFormula(object):\n    \"\"\"\n    Contains the Pacejka Magic Formula equations.\n\n    Attributes:\n        parameters (TIRParameters):\n            Tyre parameters loaded from a .TIR file.\n        AMU (float):\n            Constant used in calculation of digressive friction factor.\n        LMUV (float):\n            Scaling factor with slip speed vs decaying friction.\n    \"\"\"\n\n    def __init__(self, parameters: TIRParameters, tyre: TyreAttitude) -&gt; None:\n        self.parameters = parameters\n        self.tyre = tyre\n        self.AMU = 1  # Used in calculation of digressive friction factor.\n        self.LMUV = 0  # Scaling factor with slip speed vs decaying friction.\n        self.use_alpha_star = True\n\n    @property\n    def Fz(self) -&gt; float:  # noqa: S100\n        return self.Fz\n\n    @property\n    def R0(self) -&gt; float:  # noqa: S100\n        return self.parameters.DIMENSION.UNLOADED_RADIUS\n\n    @property\n    def pressure_ratio(self) -&gt; float:\n        return self.tyre.pressure / self.parameters.OPERATING_CONDITIONS.NOMPRES\n\n    @property  # (4.E1)\n    def Fz0_prime(self) -&gt; float:  # noqa: S100\n        nominal_load = self.parameters.VERTICAL.FNOMIN\n        nominal_load_scaling_factor = self.parameters.SCALING_COEFFICIENTS.LFZO\n        return nominal_load_scaling_factor * nominal_load\n\n    @property  # (4.E2a)\n    def dfz(self) -&gt; float:\n        return (self.Fz / self.Fz0_prime) - 1\n\n    @property  # (4.E2b)\n    def dpi(self) -&gt; float:\n        return self.pressure_ratio - 1\n\n    @property  # (4.E3)\n    def alpha(self) -&gt; float:\n        if self.use_alpha_star:\n            return tan(self.tyre.alpha) * sign(self.tyre.Vc.x)\n        else:\n            return self.tyre.alpha\n\n    @property  # (4.E4)\n    def gamma(self) -&gt; float:\n        return sin(self.tyre.gamma)\n\n    @property  # (4.E5)\n    def kappa(self) -&gt; float:\n        return self.tyre.kappa\n\n    @property  # (4.E6)\n    def cos_a(self) -&gt; float:\n        return self.tyre.Vc.x / (self.tyre.Vc.norm() + EPSILON)\n\n    @property  # (4.E7a)\n    def lmux_star(self) -&gt; float:  # With LMUV = 0, LMU* = LMU\n        return self.parameters.SCALING_COEFFICIENTS.LMUX\n\n    @property  # (4.E7b)\n    def lmuy_star(self) -&gt; float:  # With LMUV = 0, LMU* = LMU\n        return self.parameters.SCALING_COEFFICIENTS.LMUY\n\n    # Helper function for (4.E8)\n    def digressive_friction_factor(self, lmu_star: float) -&gt; float:\n        return self.AMU * lmu_star / (1 + (self.AMU - 1) * lmu_star)\n\n    @property  # (4.E8a)\n    def lmux_prime(self) -&gt; float:\n        return self.digressive_friction_factor(self.lmux_star)\n\n    @property  # (4.E8b)\n    def lmuy_prime(self) -&gt; float:\n        return self.digressive_friction_factor(self.lmuy_star)\n\n    @property  # (4.E9)\n    def Fx0(self) -&gt; float:  # noqa: S100\n        return self.magic_formula(\n            self.Bx, self.Cx, self.Dx, self.Ex, self.kx, self.SVx\n        )\n\n    @property  # (4.E10)\n    def kx(self) -&gt; float:\n        return self.kappa + self.SHx\n\n    @property  # (4.E11)\n    def Cx(self) -&gt; float:  # noqa: S100\n        PCX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PCX1\n        LCX = self.parameters.SCALING_COEFFICIENTS.LCX\n        return PCX1 * LCX\n\n    @property  # (4.E12)\n    def Dx(self) -&gt; float:  # noqa: S100\n        return self.mux * self.Fz\n\n    @property  # (4.E13)\n    def mux(self) -&gt; float:\n        PDX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PDX1\n        PDX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PDX2\n        PPX3 = self.parameters.LONGITUDINAL_COEFFICIENTS.PPX3\n        PPX4 = self.parameters.LONGITUDINAL_COEFFICIENTS.PPX4\n        PDX3 = self.parameters.LONGITUDINAL_COEFFICIENTS.PDX3\n        load_factor = PDX1 + PDX2 * self.dfz\n        pressure_factor = 1 + PPX3 * self.dpi + PPX4 * self.dpi**2\n        camber_factor = 1 - PDX3 * self.tyre.gamma**2\n        return load_factor * pressure_factor * camber_factor * self.lmux_star\n\n    @property  # (4.E14)\n    def Ex(self) -&gt; float:  # noqa: S100\n        PEX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PEX1\n        PEX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PEX2\n        PEX3 = self.parameters.LONGITUDINAL_COEFFICIENTS.PEX3\n        PEX4 = self.parameters.LONGITUDINAL_COEFFICIENTS.PEX4\n        LEX = self.parameters.SCALING_COEFFICIENTS.LEX\n        load_factor = PEX1 + PEX2 * self.dfz + PEX3 * self.dfz**2\n        slip_factor = 1 - PEX4 * sign(self.kx)\n        return load_factor * slip_factor * LEX\n\n    @property  # (4.E15)\n    def Kxk(self) -&gt; float:  # noqa: S100\n        PKX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PKX1\n        PKX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PKX2\n        PKX3 = self.parameters.LONGITUDINAL_COEFFICIENTS.PKX3\n        PPX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PPX1\n        PPX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PPX2\n        load_factor = self.Fz * (PKX1 + PKX2 * self.dfz) * exp(PKX3 * self.dfz)\n        pressure_factor = 1 + PPX1 * self.dpi + PPX2 * self.dpi**2\n        return load_factor * pressure_factor\n\n    @property  # (4.E16)\n    def Bx(self) -&gt; float:  # noqa: S100\n        return self.Kxk / (self.Cx * self.Dx + EPSILON)\n\n    @property  # (4.E17)\n    def SHx(self) -&gt; float:  # noqa: S100\n        PHX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PHX1\n        PHX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PHX2\n        LHX = self.parameters.SCALING_COEFFICIENTS.LHX\n        return (PHX1 + PHX2 * self.dfz) * LHX\n\n    @property  # (4.E18)\n    def SVx(self) -&gt; float:  # noqa: S100\n        PVX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.PVX1\n        PVX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.PVX2\n        LVX = self.parameters.SCALING_COEFFICIENTS.LVX\n        return self.Fz * (PVX1 + PVX2 * self.dfz) * LVX * self.lmux_prime\n\n    @property  # (4.E19)\n    def Fy0(self) -&gt; float:  # noqa: S100\n        return self.magic_formula(\n            self.By, self.Cy, self.Dy, self.Ey, self.alpha_y, self.SVy\n        )\n\n    @property  # (4.E20)\n    def alpha_y(self) -&gt; float:\n        return self.alpha + self.SHy\n\n    @property  # (4.E21)\n    def Cy(self) -&gt; float:  # noqa: S100\n        PCY1 = self.parameters.LATERAL_COEFFICIENTS.PCY1\n        LCY = self.parameters.SCALING_COEFFICIENTS.LCY\n        return PCY1 * LCY\n\n    @property  # (4.E22)\n    def Dy(self) -&gt; float:  # noqa: S100\n        return self.muy * self.Fz\n\n    @property  # (4.E23)\n    def muy(self) -&gt; float:\n        PDY1 = self.parameters.LATERAL_COEFFICIENTS.PDY1\n        PDY2 = self.parameters.LATERAL_COEFFICIENTS.PDY2\n        PPY3 = self.parameters.LATERAL_COEFFICIENTS.PPY3\n        PPY4 = self.parameters.LATERAL_COEFFICIENTS.PPY4\n        PDY3 = self.parameters.LATERAL_COEFFICIENTS.PDY3\n        load_factor = PDY1 + PDY2 * self.dfz\n        pressure_factor = 1 + PPY3 * self.dpi + PPY4 * self.dpi**2\n        camber_factor = 1 - PDY3 * self.gamma**2\n        return load_factor * pressure_factor * camber_factor * self.lmuy_star\n\n    @property  # (4.E24)\n    def Ey(self) -&gt; float:  # noqa: S100\n        PEY1 = self.parameters.LATERAL_COEFFICIENTS.PEY1\n        PEY2 = self.parameters.LATERAL_COEFFICIENTS.PEY2\n        PEY3 = self.parameters.LATERAL_COEFFICIENTS.PEY3\n        PEY4 = self.parameters.LATERAL_COEFFICIENTS.PEY4\n        PEY5 = self.parameters.LATERAL_COEFFICIENTS.PEY5\n        LEY = self.parameters.SCALING_COEFFICIENTS.LEY\n        load_factor = PEY1 + PEY2 * self.dfz\n        camber_term = (PEY3 + PEY4 * self.gamma) * sign(self.alpha_y)\n        return load_factor * (1 - camber_term + PEY5 * self.gamma**2) * LEY\n\n    @property  # (4.E25)\n    def Kya(self) -&gt; float:  # noqa: S100\n        PKY1 = self.parameters.LATERAL_COEFFICIENTS.PKY1\n        PKY2 = self.parameters.LATERAL_COEFFICIENTS.PKY2\n        PKY3 = self.parameters.LATERAL_COEFFICIENTS.PKY3\n        PKY4 = self.parameters.LATERAL_COEFFICIENTS.PKY4\n        PKY5 = self.parameters.LATERAL_COEFFICIENTS.PKY5\n        PPY1 = self.parameters.LATERAL_COEFFICIENTS.PPY1\n        PPY2 = self.parameters.LATERAL_COEFFICIENTS.PPY2\n        LKY = self.parameters.SCALING_COEFFICIENTS.LKY\n        load_factor = PKY1 * self.Fz0_prime\n        pressure_factor = 1 + PPY1 * self.dpi\n        camber_factor = 1 - PKY3 * abs(self.gamma)\n        adapted_load_ratio = self.Fz / self.Fz0_prime\n        factor_K = (PKY2 + PKY5 * self.gamma**2) * (1 + PPY2 * self.dpi)\n        sine_factor = sin(PKY4 * atan(adapted_load_ratio / factor_K))\n        return load_factor * pressure_factor * camber_factor * sine_factor * LKY\n\n    @property  # (4.E26)\n    def By(self) -&gt; float:  # noqa: S100\n        return self.Kya / (self.Cy * self.Dy + EPSILON)\n\n    @property  # (4.E27)\n    def SHy(self) -&gt; float:  # noqa: S100\n        PHY1 = self.parameters.LATERAL_COEFFICIENTS.PHY1\n        PHY2 = self.parameters.LATERAL_COEFFICIENTS.PHY2\n        LHY = self.parameters.SCALING_COEFFICIENTS.LHY\n        nominal_shift = (PHY1 + PHY2 * self.dfz) * LHY\n        stiffness_factor = self.Kya + EPSILON\n        camber_shift = (self.Kyc0 * self.gamma - self.SVyc) / stiffness_factor\n        return nominal_shift + camber_shift\n\n    @property  # (4.E28)\n    def SVyc(self) -&gt; float:  # noqa: S100\n        PVY3 = self.parameters.LATERAL_COEFFICIENTS.PVY3\n        PVY4 = self.parameters.LATERAL_COEFFICIENTS.PVY4\n        LKYC = self.parameters.SCALING_COEFFICIENTS.LKYC\n        load_factor = self.Fz * (PVY3 + PVY4 * self.dfz)\n        return load_factor * self.gamma * LKYC * self.lmuy_prime\n\n    @property  # (4.E29)\n    def SVy(self) -&gt; float:  # noqa: S100\n        PVY1 = self.parameters.LATERAL_COEFFICIENTS.PVY1\n        PVY2 = self.parameters.LATERAL_COEFFICIENTS.PVY2\n        LVY = self.parameters.SCALING_COEFFICIENTS.LVY\n        load_factor = self.Fz * (PVY1 + PVY2 * self.dfz)\n        return load_factor * LVY * self.lmuy_prime + self.SVyc\n\n    @property  # (4.E30)\n    def Kyc0(self) -&gt; float:  # noqa: S100\n        PKY6 = self.parameters.LATERAL_COEFFICIENTS.PKY6\n        PKY7 = self.parameters.LATERAL_COEFFICIENTS.PKY7\n        PPY5 = self.parameters.LATERAL_COEFFICIENTS.PKY5\n        LKYC = self.parameters.SCALING_COEFFICIENTS.LKYC\n        return self.Fz * (PKY6 + PKY7 * self.dfz) * (1 + PPY5 * self.dpi) * LKYC\n\n    @property  # (4.E31)\n    def Mz0(self) -&gt; float:  # noqa: S100\n        return self.Mz0_prime + self.Mzr0\n\n    @property  # (4.E32)\n    def Mz0_prime(self) -&gt; float:  # noqa: S100\n        return -self.t0 * self.Fy0\n\n    @property  # (4.E33)\n    def t0(self) -&gt; float:\n        magic_factor = self.magic_formula(\n            self.Bt, self.Ct, self.Dt, self.Et, self.a_t, 0\n        )\n        return magic_factor * self.cos_a\n\n    @property  # (4.E34)\n    def a_t(self) -&gt; float:\n        return self.alpha + self.SHt\n\n    @property  # (4.E35)\n    def SHt(self) -&gt; float:  # noqa: S100\n        QHZ1 = self.parameters.ALIGNING_COEFFICIENTS.QHZ1\n        QHZ2 = self.parameters.ALIGNING_COEFFICIENTS.QHZ2\n        QHZ3 = self.parameters.ALIGNING_COEFFICIENTS.QHZ3\n        QHZ4 = self.parameters.ALIGNING_COEFFICIENTS.QHZ4\n        return QHZ1 + QHZ2 * self.dfz + (QHZ3 + QHZ4 * self.dfz) * self.gamma\n\n    @property  # (4.E36)\n    def Mzr0(self) -&gt; float:  # noqa: S100\n        magic_factor = self.magic_formula_cosine(\n            self.Br, self.Cr, self.Dr, 0, self.a_r\n        )\n        return magic_factor * self.cos_a\n\n    @property  # (4.E37)\n    def a_r(self) -&gt; float:\n        return self.alpha + self.SHf\n\n    @property  # (4.E38)\n    def SHf(self) -&gt; float:  # noqa: S100\n        return self.SHy + self.SVy / (self.Kya + EPSILON)\n\n    @property  # (4.E40)\n    def Bt(self) -&gt; float:  # noqa: S100\n        # Note: QBZ6 is used in place of QBZ4 in Pacejka's book.\n        # However, the 6.1.2 manual uses QBZ4.\n        # The available tyre data also uses QBZ4, not QBZ6.\n        QBZ1 = self.parameters.ALIGNING_COEFFICIENTS.QBZ1\n        QBZ2 = self.parameters.ALIGNING_COEFFICIENTS.QBZ2\n        QBZ3 = self.parameters.ALIGNING_COEFFICIENTS.QBZ3\n        QBZ4 = self.parameters.ALIGNING_COEFFICIENTS.QBZ4\n        QBZ5 = self.parameters.ALIGNING_COEFFICIENTS.QBZ5\n        LKY = self.parameters.SCALING_COEFFICIENTS.LKY\n        load_factor = QBZ1 + QBZ2 * self.dfz + QBZ3 * self.dfz**2\n        camber_factor = 1 + QBZ4 * self.gamma + QBZ5 * abs(self.gamma)\n        return load_factor * camber_factor * LKY / self.lmuy_prime\n\n    @property  # (4.E41)\n    def Ct(self) -&gt; float:  # noqa: S100\n        return self.parameters.ALIGNING_COEFFICIENTS.QCZ1\n\n    @property  # (4.E42)\n    def Dt0(self) -&gt; float:  # noqa: S100\n        QDZ1 = self.parameters.ALIGNING_COEFFICIENTS.QDZ1\n        QDZ2 = self.parameters.ALIGNING_COEFFICIENTS.QDZ2\n        PPZ1 = self.parameters.ALIGNING_COEFFICIENTS.PPZ1\n        LTR = self.parameters.SCALING_COEFFICIENTS.LTR\n        load_factor = (self.R0 / self.Fz0_prime) * (QDZ1 + QDZ2 * self.dfz)\n        pressure_factor = 1 - PPZ1 * self.dpi\n        return self.Fz * load_factor * pressure_factor * LTR\n\n    @property  # (4.E43)\n    def Dt(self) -&gt; float:  # noqa: S100\n        QDZ3 = self.parameters.ALIGNING_COEFFICIENTS.QDZ3\n        QDZ4 = self.parameters.ALIGNING_COEFFICIENTS.QDZ4\n        return self.Dt0 * (1 + QDZ3 * abs(self.gamma) + QDZ4 * self.gamma**2)\n\n    @property  # (4.E44)\n    def Et(self) -&gt; float:  # noqa: S100\n        QEZ1 = self.parameters.ALIGNING_COEFFICIENTS.QEZ1\n        QEZ2 = self.parameters.ALIGNING_COEFFICIENTS.QEZ2\n        QEZ3 = self.parameters.ALIGNING_COEFFICIENTS.QEZ3\n        QEZ4 = self.parameters.ALIGNING_COEFFICIENTS.QEZ4\n        QEZ5 = self.parameters.ALIGNING_COEFFICIENTS.QEZ5\n        load_factor = QEZ1 + QEZ2 * self.dfz + QEZ3 * self.dfz**2\n        camber_factor = QEZ4 + QEZ5 * self.gamma\n        shape_factor = (2 / pi) * atan(self.Bt * self.Ct * self.a_t)\n        return load_factor * (1 + camber_factor * shape_factor)\n\n    @property  # (4.E45)\n    def Br(self) -&gt; float:  # noqa: S100\n        QBZ9 = self.parameters.ALIGNING_COEFFICIENTS.QBZ9\n        QBZ10 = self.parameters.ALIGNING_COEFFICIENTS.QBZ10\n        LKY = self.parameters.SCALING_COEFFICIENTS.LKY\n        return QBZ9 * LKY / self.lmuy_star + QBZ10 * self.By * self.Cy\n\n    @property  # (4.E46)\n    def Cr(self) -&gt; float:  # noqa: S100\n        return 1\n\n    @property  # (4.E47)\n    def Dr(self) -&gt; float:  # noqa: S100\n        align = self.parameters.ALIGNING_COEFFICIENTS\n        LRES = self.parameters.SCALING_COEFFICIENTS.LRES\n        LKZC = self.parameters.SCALING_COEFFICIENTS.LKZC\n        load_factor = (align.QDZ6 + align.QDZ7 * self.dfz) * LRES\n        pressure_load_factor = align.QDZ8 + align.QDZ9 * self.dfz\n        pressure_factor = pressure_load_factor * (1 + align.PPZ2 * self.dpi)\n        camber_load_sensivitity = align.QDZ10 + align.QDZ11 * self.dfz\n        camber_sensitivity = camber_load_sensivitity * abs(self.gamma)\n        camber_factor = load_factor + (pressure_factor + camber_sensitivity)\n        camber_influence = camber_factor * self.gamma * LKZC * self.lmuy_star\n        direction = sign(self.tyre.Vc.x)\n        return self.Fz * self.R0 * camber_influence * direction * self.cos_a\n\n    @property  # (4.E50)\n    def Fx(self) -&gt; float:  # noqa: S100\n        return self.Gxa * self.Fx0\n\n    @property  # (4.E51)\n    def Gxa(self) -&gt; float:  # noqa: S100\n        magic_factor = self.magic_formula_cosine(\n            self.Bxa, self.Cxa, 1, self.Exa, self.alpha_s\n        )\n        return magic_factor / self.Gxa0\n\n    @property  # (4.E52)\n    def Gxa0(self) -&gt; float:  # noqa: S100\n        return self.magic_formula_cosine(\n            self.Bxa, self.Cxa, 1, self.Exa, self.SHxa\n        )\n\n    @property  # (4.E53)\n    def alpha_s(self) -&gt; float:\n        return self.alpha + self.SHxa\n\n    @property  # (4.E54)\n    def Bxa(self) -&gt; float:  # noqa: S100\n        RBX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.RBX1\n        RBX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.RBX2\n        RBX3 = self.parameters.LONGITUDINAL_COEFFICIENTS.RBX3\n        LXAL = self.parameters.SCALING_COEFFICIENTS.LXAL\n        camber_factor = RBX1 + RBX3 * self.gamma**2\n        slip_factor = cos(atan(RBX2 * self.kappa))\n        return camber_factor * slip_factor * LXAL\n\n    @property  # (4.E55)\n    def Cxa(self) -&gt; float:  # noqa: S100\n        return self.parameters.LONGITUDINAL_COEFFICIENTS.RCX1\n\n    @property  # (4.E56)\n    def Exa(self) -&gt; float:  # noqa: S100\n        REX1 = self.parameters.LONGITUDINAL_COEFFICIENTS.REX1\n        REX2 = self.parameters.LONGITUDINAL_COEFFICIENTS.REX2\n        return REX1 + REX2 * self.dfz\n\n    @property  # (4.E57)\n    def SHxa(self) -&gt; float:  # noqa: S100\n        return self.parameters.LONGITUDINAL_COEFFICIENTS.RHX1\n\n    @property  # (4.E58)\n    def Fy(self) -&gt; float:  # noqa: S100\n        return self.Gyk * self.Fy0 + self.SVyk\n\n    @property  # (4.E59)\n    def Gyk(self) -&gt; float:  # noqa: S100\n        magic_factor = self.magic_formula_cosine(\n            self.Byk, self.Cyk, 1, self.Eyk, self.k_s\n        )\n        return magic_factor / self.Gyk0\n\n    @property  # (4.E60)\n    def Gyk0(self) -&gt; float:  # noqa: S100\n        return self.magic_formula_cosine(\n            self.Byk, self.Cyk, 1, self.Eyk, self.SHyk\n        )\n\n    @property  # (4.E61)\n    def k_s(self) -&gt; float:\n        return self.kappa + self.SHyk\n\n    @property  # (4.E62)\n    def Byk(self) -&gt; float:  # noqa: S100\n        RBY1 = self.parameters.LATERAL_COEFFICIENTS.RBY1\n        RBY2 = self.parameters.LATERAL_COEFFICIENTS.RBY2\n        RBY3 = self.parameters.LATERAL_COEFFICIENTS.RBY3\n        RBY4 = self.parameters.LATERAL_COEFFICIENTS.RBY4\n        LYKA = self.parameters.SCALING_COEFFICIENTS.LYKA\n        camber_factor = RBY1 + RBY4 * self.gamma**2\n        slip_factor = cos(atan(RBY2 * (self.alpha - RBY3)))\n        return camber_factor * slip_factor * LYKA\n\n    @property  # (4.E63)\n    def Cyk(self) -&gt; float:  # noqa: S100\n        return self.parameters.LATERAL_COEFFICIENTS.RCY1\n\n    @property  # (4.E64)\n    def Eyk(self) -&gt; float:  # noqa: S100\n        REY1 = self.parameters.LATERAL_COEFFICIENTS.REY1\n        REY2 = self.parameters.LATERAL_COEFFICIENTS.REY2\n        return REY1 + REY2 * self.dfz\n\n    @property  # (4.E65)\n    def SHyk(self) -&gt; float:  # noqa: S100\n        RHY1 = self.parameters.LATERAL_COEFFICIENTS.RHY1\n        RHY2 = self.parameters.LATERAL_COEFFICIENTS.RHY2\n        return RHY1 + RHY2 * self.dfz\n\n    @property  # (4.E66)\n    def SVyk(self) -&gt; float:  # noqa: S100\n        RVY5 = self.parameters.LATERAL_COEFFICIENTS.RVY5\n        RVY6 = self.parameters.LATERAL_COEFFICIENTS.RVY6\n        LVYKA = self.parameters.SCALING_COEFFICIENTS.LVYKA\n        return self.DVyk * sin(RVY5 * atan(RVY6 * self.kappa)) * LVYKA\n\n    @property  # (4.E67)\n    def DVyk(self) -&gt; float:  # noqa: S100\n        RVY1 = self.parameters.LATERAL_COEFFICIENTS.RVY1\n        RVY2 = self.parameters.LATERAL_COEFFICIENTS.RVY2\n        RVY3 = self.parameters.LATERAL_COEFFICIENTS.RVY3\n        RVY4 = self.parameters.LATERAL_COEFFICIENTS.RVY4\n        load_factor = RVY1 + RVY2 * self.dfz + RVY3 * self.gamma\n        slip_factor = cos(atan(RVY4 * self.alpha))\n        return self.muy * self.Fz * load_factor * slip_factor\n\n    @property  # (4.E69)\n    def Mx(self) -&gt; float:  # noqa: S100\n        q = self.parameters.OVERTURNING_COEFFICIENTS\n        LVMX = self.parameters.SCALING_COEFFICIENTS.LVMX\n        LMX = self.parameters.SCALING_COEFFICIENTS.LMX\n        load_ratio = self.Fz / self.parameters.VERTICAL.FNOMIN\n\n        offset = q.QSX1 * LVMX\n        pressure_term = q.QSX2 * self.gamma * (1 + q.PPMX1 * self.dpi)\n        load_term = q.QSX3 * load_ratio\n        cosine_factor = cos(q.QSX5 * atan(q.QSX6 * load_ratio) ** 2)\n        arctan_factor = atan(q.QSX9 * load_ratio)\n        sine_factor = sin(q.QSX7 * self.gamma + q.QSX8 * arctan_factor)\n        trig_term = q.QSX4 * cosine_factor * sine_factor\n        camber_term = q.QSX10 * atan(q.QSX11 * load_ratio) * self.gamma\n        terms = offset - pressure_term + load_term + trig_term + camber_term\n        return self.Fz * self.R0 * terms * LMX\n\n    @property  # (4.E70)\n    def My(self) -&gt; float:  # noqa: S100\n        q = self.parameters.ROLLING_COEFFICIENTS\n        nominal_load = self.parameters.VERTICAL.FNOMIN\n        v_ratio = self.tyre.Vx / self.parameters.MODEL.LONGVL\n        force_ratio = self.Fz / nominal_load\n        LMY = self.parameters.SCALING_COEFFICIENTS.LMY\n\n        longitudinal_term = q.QSY2 * self.Fx / nominal_load\n        velocity_term = q.QSY3 * abs(v_ratio) + q.QSY4 * v_ratio**4\n        camber_term = (q.QSY5 + q.QSY6 * force_ratio) * (self.tyre.gamma**2)\n        factor_a = q.QSY1 + longitudinal_term + velocity_term + camber_term\n        factor_b = pow(force_ratio, q.QSY7) * pow(self.pressure_ratio, q.QSY8)\n        return self.Fz * self.R0 * factor_a * factor_b * LMY\n\n    @property  # (4.E71)\n    def Mz(self) -&gt; float:  # noqa: S100\n        return self.Mz_prime + self.Mzr + self.s * self.Fx\n\n    @property  # (4.E72)\n    def Mz_prime(self) -&gt; float:  # noqa: S100\n        return -self.t * self.Fy_prime\n\n    @property  # (4.E73)\n    def t(self) -&gt; float:\n        magic_factor = self.magic_formula_cosine(\n            self.Bt, self.Ct, self.Dt, self.Et, self.a_teq\n        )\n        return magic_factor * self.cos_a\n\n    @property  # (4.E74)\n    def Fy_prime(self) -&gt; float:  # noqa: S100\n        return self.Gyk * self.Fy0\n\n    @property  # (4.E75)\n    def Mzr(self) -&gt; float:  # noqa: S100\n        magic_factor = self.magic_formula_cosine(\n            self.Br, self.Cr, self.Dr, 0, self.a_req\n        )\n        return magic_factor * self.cos_a\n\n    @property  # (4.E76)\n    def s(self) -&gt; float:\n        SSZ1 = self.parameters.ALIGNING_COEFFICIENTS.SSZ1\n        SSZ2 = self.parameters.ALIGNING_COEFFICIENTS.SSZ2\n        SSZ3 = self.parameters.ALIGNING_COEFFICIENTS.SSZ3\n        SSZ4 = self.parameters.ALIGNING_COEFFICIENTS.SSZ4\n        LS = self.parameters.SCALING_COEFFICIENTS.LS\n        load_factor = SSZ2 * self.Fy / self.Fz0_prime\n        camber_factor = (SSZ3 + SSZ4 * self.dfz) * self.gamma\n        return self.R0 * (SSZ1 + load_factor + camber_factor) * LS\n\n    @property  # Helper function for (4.E77) and (4.E78)\n    def _stiffness_factor(self) -&gt; float:\n        return self.kappa * self.Kxk / (self.Kya + EPSILON)\n\n    @property  # (4.E77)\n    def a_teq(self) -&gt; float:\n        return sqrt(self.a_t**2 + self._stiffness_factor**2) * sign(self.a_t)\n\n    @property  # (4.E78)\n    def a_req(self) -&gt; float:\n        return sqrt(self.a_r**2 + self._stiffness_factor**2) * sign(self.a_r)\n\n    @staticmethod\n    def magic_formula(\n        B: float, C: float, D: float, E: float, x: float, SV: float\n    ) -&gt; float:\n        \"\"\"\n        Implements the Pacejka Magic Formula.\n\n        Calculates longitudinal force Fx,\n        lateral force Fy, or aligning moment Mz.\n\n        Args:\n            B (float): Stiffness factor.\n            C (float): Shape factor.\n            D (float): Peak value.\n            E (float): Curvature factor.\n            x (float): Input variable (kappa, alpha, or gamma),\n                plus horizontal shift.\n            SV (float): Vertical shift.\n\n        Returns:\n            Y (float): Output variable (either Fx, Fy, or Mz).\n        \"\"\"\n        Bx = B * x\n        return D * sin(C * atan(Bx - E * (Bx - atan(Bx)))) + SV\n\n    @staticmethod\n    def magic_formula_cosine(\n        B: float, C: float, D: float, E: float, x: float\n    ) -&gt; float:\n        \"\"\"\n        Implements the cosine version of the Pacejka Magic Formula.\n\n        Args:\n            B (float): Stiffness factor.\n            C (float): Shape factor.\n            D (float): Peak value.\n            E (float): Curvature factor.\n            x (float): Input variable (kappa, alpha, or gamma),\n                plus horizontal shift.\n\n        Returns:\n            Y (float): Output variable.\n        \"\"\"\n        Bx = B * x\n        return D * cos(C * atan(Bx - E * (Bx - atan(Bx))))\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/magic_formula/#usmlap.vehicle.tyre.magic_formula.MagicFormula.magic_formula","title":"<code>magic_formula(B, C, D, E, x, SV)</code>  <code>staticmethod</code>","text":"<p>Implements the Pacejka Magic Formula.</p> <p>Calculates longitudinal force Fx, lateral force Fy, or aligning moment Mz.</p> <p>Parameters:</p> Name Type Description Default <code>B</code> <code>float</code> <p>Stiffness factor.</p> required <code>C</code> <code>float</code> <p>Shape factor.</p> required <code>D</code> <code>float</code> <p>Peak value.</p> required <code>E</code> <code>float</code> <p>Curvature factor.</p> required <code>x</code> <code>float</code> <p>Input variable (kappa, alpha, or gamma), plus horizontal shift.</p> required <code>SV</code> <code>float</code> <p>Vertical shift.</p> required <p>Returns:</p> Name Type Description <code>Y</code> <code>float</code> <p>Output variable (either Fx, Fy, or Mz).</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\magic_formula.py</code> <pre><code>@staticmethod\ndef magic_formula(\n    B: float, C: float, D: float, E: float, x: float, SV: float\n) -&gt; float:\n    \"\"\"\n    Implements the Pacejka Magic Formula.\n\n    Calculates longitudinal force Fx,\n    lateral force Fy, or aligning moment Mz.\n\n    Args:\n        B (float): Stiffness factor.\n        C (float): Shape factor.\n        D (float): Peak value.\n        E (float): Curvature factor.\n        x (float): Input variable (kappa, alpha, or gamma),\n            plus horizontal shift.\n        SV (float): Vertical shift.\n\n    Returns:\n        Y (float): Output variable (either Fx, Fy, or Mz).\n    \"\"\"\n    Bx = B * x\n    return D * sin(C * atan(Bx - E * (Bx - atan(Bx)))) + SV\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/magic_formula/#usmlap.vehicle.tyre.magic_formula.MagicFormula.magic_formula_cosine","title":"<code>magic_formula_cosine(B, C, D, E, x)</code>  <code>staticmethod</code>","text":"<p>Implements the cosine version of the Pacejka Magic Formula.</p> <p>Parameters:</p> Name Type Description Default <code>B</code> <code>float</code> <p>Stiffness factor.</p> required <code>C</code> <code>float</code> <p>Shape factor.</p> required <code>D</code> <code>float</code> <p>Peak value.</p> required <code>E</code> <code>float</code> <p>Curvature factor.</p> required <code>x</code> <code>float</code> <p>Input variable (kappa, alpha, or gamma), plus horizontal shift.</p> required <p>Returns:</p> Name Type Description <code>Y</code> <code>float</code> <p>Output variable.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\magic_formula.py</code> <pre><code>@staticmethod\ndef magic_formula_cosine(\n    B: float, C: float, D: float, E: float, x: float\n) -&gt; float:\n    \"\"\"\n    Implements the cosine version of the Pacejka Magic Formula.\n\n    Args:\n        B (float): Stiffness factor.\n        C (float): Shape factor.\n        D (float): Peak value.\n        E (float): Curvature factor.\n        x (float): Input variable (kappa, alpha, or gamma),\n            plus horizontal shift.\n\n    Returns:\n        Y (float): Output variable.\n    \"\"\"\n    Bx = B * x\n    return D * cos(C * atan(Bx - E * (Bx - atan(Bx))))\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/magic_formula/#usmlap.vehicle.tyre.magic_formula.TyreAttitude","title":"<code>TyreAttitude</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters describing the attitude of a tyre.</p> <p>Attributes:</p> Name Type Description <code>Vx</code> <code>float</code> <p>Longitudinal velocity of wheel centre.</p> <code>Vc</code> <code>Coordinate</code> <p>Velocity of the wheel contact patch.</p> <code>Vs</code> <code>Coordinate</code> <p>Slip velocity.</p> <code>fz</code> <code>float</code> <p>Normal load on the tyre.</p> <code>omega</code> <code>float</code> <p>Wheel speed of revolution.</p> <code>kappa</code> <code>float</code> <p>Longitudinal slip.</p> <code>alpha</code> <code>float</code> <p>Side slip angle.</p> <code>gamma</code> <code>float</code> <p>Camber angle.</p> <code>pressure</code> <code>float</code> <p>Inflation pressure.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\magic_formula.py</code> <pre><code>class TyreAttitude(BaseModel):\n    \"\"\"\n    Parameters describing the attitude of a tyre.\n\n    Attributes:\n        Vx:\n            Longitudinal velocity of wheel centre.\n        Vc:\n            Velocity of the wheel contact patch.\n        Vs:\n            Slip velocity.\n        fz:\n            Normal load on the tyre.\n        omega:\n            Wheel speed of revolution.\n        kappa:\n            Longitudinal slip.\n        alpha:\n            Side slip angle.\n        gamma:\n            Camber angle.\n        pressure:\n            Inflation pressure.\n    \"\"\"\n\n    Vx: float\n    Vc: Coordinate\n    Vs: Coordinate\n    fz: float\n    omega: float\n    kappa: float\n    alpha: float\n    gamma: float\n    pressure: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/","title":"tir","text":"<p>This module provides support for reading tyre data from .TIR files.</p> <p>The .TIR file format specifies a wide range of tyre parameters which can be used in the Pacejka Magic Formula.</p> <p>Documentation for the .TIR file format is available at https://functionbay.com/documentation/onlinehelp/Documents/Tire/MFTyre-MFSwift_Help.pdf, in section 5.3.</p>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.AligningCoefficients","title":"<code>AligningCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for evaluating self-aligning moment, Mz.</p> <p>Attributes:</p> Name Type Description <code>QBZ1</code> <code>float</code> <p>Trail slope factor for trail Bpt at Fznom.</p> <code>QBZ2</code> <code>float</code> <p>Variation of slope Bpt with load.</p> <code>QBZ3</code> <code>float</code> <p>Variation of slope Bpt with load squared.</p> <code>QBZ4</code> <code>float</code> <p>Variation of slope Bpt with camber.</p> <code>QBZ5</code> <code>float</code> <p>Variation of slope Bpt with absolute camber.</p> <code>QBZ6</code> <code>Optional[float]</code> <p>Variation of slope Bpt with camber squared.</p> <code>QBZ9</code> <code>float</code> <p>Slope factor Br of residual torque Mzr.</p> <code>QBZ10</code> <code>float</code> <p>Slope factor Br of residual torque Mzr.</p> <code>QCZ1</code> <code>float</code> <p>Shape factor Cpt for pneumatic trail.</p> <code>QDZ1</code> <code>float</code> <p>Peak trail Dpt = Dpt(Fz/FznomR0).</p> <code>QDZ2</code> <code>float</code> <p>Variation of peak Dpt with load.</p> <code>QDZ3</code> <code>float</code> <p>Variation of peak Dpt with camber.</p> <code>QDZ4</code> <code>float</code> <p>Variation of peak Dpt with camber squared.</p> <code>QDZ6</code> <code>float</code> <p>Peak residual torque Dmr = Dmr/(Fz*R0).</p> <code>QDZ7</code> <code>float</code> <p>Variation of peak factor Dmr with load.</p> <code>QDZ8</code> <code>float</code> <p>Variation of peak factor Dmr with camber.</p> <code>QDZ9</code> <code>float</code> <p>Variation of peak factor Dmr with camber and load.</p> <code>QDZ10</code> <code>float</code> <p>Variation of peak factor Dmr with camber squared.</p> <code>QDZ11</code> <code>float</code> <p>Variation of Dmr with camber squared and load.</p> <code>QEZ1</code> <code>float</code> <p>Trail curvature Ept at Fznom.</p> <code>QEZ2</code> <code>float</code> <p>Variation of curvature Ept with load.</p> <code>QEZ3</code> <code>float</code> <p>Variation of curvature Ept with load squared.</p> <code>QEZ4</code> <code>float</code> <p>Variation of curvature Ept with sign of Alpha-t.</p> <code>QEZ5</code> <code>float</code> <p>Variation of Ept with camber and sign Alpha-t.</p> <code>QHZ1</code> <code>float</code> <p>Trail horizontal shift Sht at Fznom.</p> <code>QHZ2</code> <code>float</code> <p>Variation of shift Sht with load.</p> <code>QHZ3</code> <code>float</code> <p>Variation of shift Sht with camber.</p> <code>QHZ4</code> <code>float</code> <p>Variation of shift Sht with camber and load.</p> <code>SSZ1</code> <code>float</code> <p>Nominal value of s/R0:  of Fx on Mz.</p> <code>SSZ2</code> <code>float</code> <p>Variation of distance s/R0 with Fy/Fznom.</p> <code>SSZ3</code> <code>float</code> <p>Variation of distance s/R0 with camber.</p> <code>SSZ4</code> <code>float</code> <p>Variation of distance s/R0 with load and camber.</p> <code>PPZ1</code> <code>float</code> <p>Linear pressure effect on pneumatic trail.</p> <code>PPZ2</code> <code>float</code> <p>Influence of inflation pressure on residual aligning torque.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class AligningCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for evaluating self-aligning moment, Mz.\n\n    Attributes:\n        QBZ1 (float): Trail slope factor for trail Bpt at Fznom.\n        QBZ2 (float): Variation of slope Bpt with load.\n        QBZ3 (float): Variation of slope Bpt with load squared.\n        QBZ4 (float): Variation of slope Bpt with camber.\n        QBZ5 (float): Variation of slope Bpt with absolute camber.\n        QBZ6 (Optional[float]): Variation of slope Bpt with camber squared.\n        QBZ9 (float): Slope factor Br of residual torque Mzr.\n        QBZ10 (float): Slope factor Br of residual torque Mzr.\n        QCZ1 (float): Shape factor Cpt for pneumatic trail.\n        QDZ1 (float): Peak trail Dpt = Dpt*(Fz/Fznom*R0).\n        QDZ2 (float): Variation of peak Dpt with load.\n        QDZ3 (float): Variation of peak Dpt with camber.\n        QDZ4 (float): Variation of peak Dpt with camber squared.\n        QDZ6 (float): Peak residual torque Dmr = Dmr/(Fz*R0).\n        QDZ7 (float): Variation of peak factor Dmr with load.\n        QDZ8 (float): Variation of peak factor Dmr with camber.\n        QDZ9 (float): Variation of peak factor Dmr with camber and load.\n        QDZ10 (float): Variation of peak factor Dmr with camber squared.\n        QDZ11 (float): Variation of Dmr with camber squared and load.\n        QEZ1 (float): Trail curvature Ept at Fznom.\n        QEZ2 (float): Variation of curvature Ept with load.\n        QEZ3 (float): Variation of curvature Ept with load squared.\n        QEZ4 (float): Variation of curvature Ept with sign of Alpha-t.\n        QEZ5 (float): Variation of Ept with camber and sign Alpha-t.\n        QHZ1 (float): Trail horizontal shift Sht at Fznom.\n        QHZ2 (float): Variation of shift Sht with load.\n        QHZ3 (float): Variation of shift Sht with camber.\n        QHZ4 (float): Variation of shift Sht with camber and load.\n        SSZ1 (float): Nominal value of s/R0:  of Fx on Mz.\n        SSZ2 (float): Variation of distance s/R0 with Fy/Fznom.\n        SSZ3 (float): Variation of distance s/R0 with camber.\n        SSZ4 (float): Variation of distance s/R0 with load and camber.\n        PPZ1 (float): Linear pressure effect on pneumatic trail.\n        PPZ2 (float): Influence of inflation pressure on residual aligning torque.\n    \"\"\"\n\n    QBZ1: float\n    QBZ2: float\n    QBZ3: float\n    QBZ4: float\n    QBZ5: float\n    QBZ6: Optional[float] = None\n    QBZ9: float\n    QBZ10: float\n    QCZ1: float\n    QDZ1: float\n    QDZ2: float\n    QDZ3: float\n    QDZ4: float\n    QDZ6: float\n    QDZ7: float\n    QDZ8: float\n    QDZ9: float\n    QDZ10: float\n    QDZ11: float\n    QEZ1: float\n    QEZ2: float\n    QEZ3: float\n    QEZ4: float\n    QEZ5: float\n    QHZ1: float\n    QHZ2: float\n    QHZ3: float\n    QHZ4: float\n    SSZ1: float\n    SSZ2: float\n    SSZ3: float\n    SSZ4: float\n    PPZ1: float\n    PPZ2: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.ContactPatch","title":"<code>ContactPatch</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Contact length and obstacle enveloping parameters.</p> <p>Attributes:</p> Name Type Description <code>Q_RA1</code> <code>Optional[float]</code> <p>Square root term in contact length equation.</p> <code>Q_RA2</code> <code>Optional[float]</code> <p>Linear term in contact length equation.</p> <code>Q_RB1</code> <code>Optional[float]</code> <p>Root term in contact width equation.</p> <code>Q_RB2</code> <code>Optional[float]</code> <p>Linear term in contact width equation.</p> <code>ELLIPS_SHIFT</code> <code>Optional[float]</code> <p>Scaling of distance between front and rear ellipsoid.</p> <code>ELLIPS_LENGTH</code> <code>Optional[float]</code> <p>Semimajor axis of ellipsoid.</p> <code>ELLIPS_HEIGHT</code> <code>Optional[float]</code> <p>Semiminor axis of ellipsoid.</p> <code>ELLIPS_ORDER</code> <code>Optional[float]</code> <p>Order of ellipsoid.</p> <code>ELLIPS_MAX_STEP</code> <code>Optional[float]</code> <p>Maximum height of road step.</p> <code>ELLIPS_NWIDTH</code> <code>Optional[float]</code> <p>Number of parallel ellipsoids.</p> <code>ELLIPS_NLENGTH</code> <code>Optional[float]</code> <p>Number of ellipsoids at sides of contact patch.</p> <code>ENV_C1</code> <code>Optional[float]</code> <p>Effective height attenuation.</p> <code>ENV_C2</code> <code>Optional[float]</code> <p>Effective plane angle attenuation.</p> <code>Q_A2</code> <code>Optional[float]</code> <p>Linear load term in contact length.</p> <code>Q_A1</code> <code>Optional[float]</code> <p>Square root load term in contact length.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class ContactPatch(_ParameterGroup):\n    \"\"\"\n    Contact length and obstacle enveloping parameters.\n\n    Attributes:\n        Q_RA1 (Optional[float]): Square root term in contact length equation.\n        Q_RA2 (Optional[float]): Linear term in contact length equation.\n        Q_RB1 (Optional[float]): Root term in contact width equation.\n        Q_RB2 (Optional[float]): Linear term in contact width equation.\n        ELLIPS_SHIFT (Optional[float]):\n            Scaling of distance between front and rear ellipsoid.\n        ELLIPS_LENGTH (Optional[float]): Semimajor axis of ellipsoid.\n        ELLIPS_HEIGHT (Optional[float]): Semiminor axis of ellipsoid.\n        ELLIPS_ORDER (Optional[float]): Order of ellipsoid.\n        ELLIPS_MAX_STEP (Optional[float]): Maximum height of road step.\n        ELLIPS_NWIDTH (Optional[float]): Number of parallel ellipsoids.\n        ELLIPS_NLENGTH (Optional[float]):\n            Number of ellipsoids at sides of contact patch.\n        ENV_C1 (Optional[float]): Effective height attenuation.\n        ENV_C2 (Optional[float]): Effective plane angle attenuation.\n        Q_A2 (Optional[float]): Linear load term in contact length.\n        Q_A1 (Optional[float]): Square root load term in contact length.\n    \"\"\"\n\n    Q_RA1: Optional[float] = None\n    Q_RA2: Optional[float] = None\n    Q_RB1: Optional[float] = None\n    Q_RB2: Optional[float] = None\n    ELLIPS_SHIFT: Optional[float] = None\n    ELLIPS_LENGTH: Optional[float] = None\n    ELLIPS_HEIGHT: Optional[float] = None\n    ELLIPS_ORDER: Optional[float] = None\n    ELLIPS_MAX_STEP: Optional[float] = None\n    ELLIPS_NWIDTH: Optional[float] = None\n    ELLIPS_NLENGTH: Optional[float] = None\n    ENV_C1: Optional[float] = None\n    ENV_C2: Optional[float] = None\n    Q_A2: Optional[float] = None\n    Q_A1: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Dimension","title":"<code>Dimension</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Tyre dimensions.</p> <p>Attributes:</p> Name Type Description <code>UNLOADED_RADIUS</code> <code>float</code> <p>Free tyre radius.</p> <code>WIDTH</code> <code>Optional[float]</code> <p>Nominal section width of the tyre.</p> <code>RIM_RADIUS</code> <code>Optional[float]</code> <p>Nominal rim radius.</p> <code>RIM_WIDTH</code> <code>Optional[float]</code> <p>Rim width.</p> <code>ASPECT_RATIO</code> <code>Optional[float]</code> <p>Nominal aspect ratio.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Dimension(_ParameterGroup):\n    \"\"\"\n    Tyre dimensions.\n\n    Attributes:\n        UNLOADED_RADIUS (float): Free tyre radius.\n        WIDTH (Optional[float]): Nominal section width of the tyre.\n        RIM_RADIUS (Optional[float]): Nominal rim radius.\n        RIM_WIDTH (Optional[float]): Rim width.\n        ASPECT_RATIO (Optional[float]): Nominal aspect ratio.\n    \"\"\"\n\n    UNLOADED_RADIUS: float\n    WIDTH: Optional[float] = None\n    RIM_RADIUS: Optional[float] = None\n    RIM_WIDTH: Optional[float] = None\n    ASPECT_RATIO: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.InclinationAngleRange","title":"<code>InclinationAngleRange</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Minimum and maximum valid inclination angles.</p> <p>Attributes:</p> Name Type Description <code>CAMMIN</code> <code>Optional[float]</code> <p>Minimum valid camber angle.</p> <code>CAMMAX</code> <code>Optional[float]</code> <p>Maximum valid camber angle.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class InclinationAngleRange(_ParameterGroup):\n    \"\"\"\n    Minimum and maximum valid inclination angles.\n\n    Attributes:\n        CAMMIN (Optional[float]): Minimum valid camber angle.\n        CAMMAX (Optional[float]): Maximum valid camber angle.\n    \"\"\"\n\n    CAMMIN: Optional[float] = None\n    CAMMAX: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Inertia","title":"<code>Inertia</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Mass and inertia properties of the tyre and tyre belt.</p> <p>Attributes:</p> Name Type Description <code>MASS</code> <code>Optional[float]</code> <p>Tyre mass.</p> <code>IXX</code> <code>Optional[float]</code> <p>Tyre diametral moment of inertia.</p> <code>IYY</code> <code>Optional[float]</code> <p>Tyre polar moment of inertia.</p> <code>BELT_MASS</code> <code>Optional[float]</code> <p>Belt mass.</p> <code>BELT_IXX</code> <code>Optional[float]</code> <p>Belt diametral moment of inertia.</p> <code>BELT_IYY</code> <code>Optional[float]</code> <p>Belt polar moment of inertia.</p> <code>GRAVITY</code> <code>Optional[float]</code> <p>Gravity acting on belt in Z direction.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Inertia(_ParameterGroup):\n    \"\"\"\n    Mass and inertia properties of the tyre and tyre belt.\n\n    Attributes:\n        MASS (Optional[float]): Tyre mass.\n        IXX (Optional[float]): Tyre diametral moment of inertia.\n        IYY (Optional[float]): Tyre polar moment of inertia.\n        BELT_MASS (Optional[float]): Belt mass.\n        BELT_IXX (Optional[float]): Belt diametral moment of inertia.\n        BELT_IYY (Optional[float]): Belt polar moment of inertia.\n        GRAVITY (Optional[float]): Gravity acting on belt in Z direction.\n    \"\"\"\n\n    MASS: Optional[float] = None\n    IXX: Optional[float] = None\n    IYY: Optional[float] = None\n    BELT_MASS: Optional[float] = None\n    BELT_IXX: Optional[float] = None\n    BELT_IYY: Optional[float] = None\n    GRAVITY: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.InflationPressureRange","title":"<code>InflationPressureRange</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Minimum and maximum allowed inflation pressures.</p> <p>Attributes:</p> Name Type Description <code>PRESMIN</code> <code>Optional[float]</code> <p>Minimum allowed inflation pressure.</p> <code>PRESMAX</code> <code>Optional[float]</code> <p>Maximum allowed inflation pressure.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class InflationPressureRange(_ParameterGroup):\n    \"\"\"\n    Minimum and maximum allowed inflation pressures.\n\n    Attributes:\n        PRESMIN (Optional[float]): Minimum allowed inflation pressure.\n        PRESMAX (Optional[float]): Maximum allowed inflation pressure.\n    \"\"\"\n\n    PRESMIN: Optional[float] = None\n    PRESMAX: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.LateralCoefficients","title":"<code>LateralCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for evaluating lateral force, Fy.</p> <p>Attributes:</p> Name Type Description <code>PCY1</code> <code>float</code> <p>Shape factor Cfy for lateral forces.</p> <code>PDY1</code> <code>float</code> <p>Lateral friction Muy.</p> <code>PDY2</code> <code>float</code> <p>Variation of friction Muy with load.</p> <code>PDY3</code> <code>float</code> <p>Variation of friction Muy with squared camber.</p> <code>PEY1</code> <code>float</code> <p>Lateral curvature Efy at Fznom.</p> <code>PEY2</code> <code>float</code> <p>Variation of curvature Efy with load.</p> <code>PEY3</code> <code>float</code> <p>Zero order camber dependency of curvature Efy.</p> <code>PEY4</code> <code>float</code> <p>Variation of curvature Efy with camber.</p> <code>PEY5</code> <code>float</code> <p>Camber curvature Efc.</p> <code>PKY1</code> <code>float</code> <p>Maximum value of stiffness Kfy/Fznom.</p> <code>PKY2</code> <code>float</code> <p>Load at which Kfy reaches maximum value.</p> <code>PKY3</code> <code>float</code> <p>Variation of Kfy/Fznom with camber.</p> <code>PKY4</code> <code>float</code> <p>Curvature of stiffness Kfy.</p> <code>PKY5</code> <code>float</code> <p>Peak stiffness variation with camber squared.</p> <code>PKY6</code> <code>float</code> <p>Camber stiffness factor.</p> <code>PKY7</code> <code>float</code> <p>Load dependency of camber stiffness factor.</p> <code>PHY1</code> <code>float</code> <p>Horizontal shift Shy at Fznom.</p> <code>PHY2</code> <code>float</code> <p>Variation of shift Shy with load.</p> <code>PVY1</code> <code>float</code> <p>Vertical shift in Svy/Fz at Fznom.</p> <code>PVY2</code> <code>float</code> <p>Variation of shift Svy/Fz with load.</p> <code>PVY3</code> <code>float</code> <p>Variation of shift Svy/Fz with camber.</p> <code>PVY4</code> <code>float</code> <p>Variation of shift Svy/Fz with camber and load.</p> <code>RBY1</code> <code>float</code> <p>Slope factor for combined Fy reduction.</p> <code>RBY2</code> <code>float</code> <p>Variation of slope Fy reduction with alpha.</p> <code>RBY3</code> <code>float</code> <p>Shift term for alpha in slope Fy reduction.</p> <code>RBY4</code> <code>float</code> <p>Influence of camber on stiffness of Fy combined.</p> <code>RCY1</code> <code>float</code> <p>Shape factor for combined Fy reduction.</p> <code>REY1</code> <code>float</code> <p>Curvature factor of combined Fy.</p> <code>REY2</code> <code>float</code> <p>Curvature factor of combined Fy with load.</p> <code>RHY1</code> <code>float</code> <p>Shift factor for combined Fy reduction.</p> <code>RHY2</code> <code>float</code> <p>Shift factor for combined Fy reduction with load.</p> <code>RVY1</code> <code>float</code> <p>Kappa induced side force Svyk/Muy*Fz at Fznom.</p> <code>RVY2</code> <code>float</code> <p>Variation of Svyk/Muy*Fz with load.</p> <code>RVY3</code> <code>float</code> <p>Variation of Svyk/Muy*Fz with camber.</p> <code>RVY4</code> <code>float</code> <p>Variation of Svyk/Muy*Fz with alpha.</p> <code>RVY5</code> <code>float</code> <p>Variation of Svyk/Muy*Fz with kappa.</p> <code>RVY6</code> <code>float</code> <p>Variation of Svyk/Muy*Fz with atan(kappa).</p> <code>PPY1</code> <code>float</code> <p>Pressure effect on cornering stiffness magnitude.</p> <code>PPY2</code> <code>float</code> <p>Pressure effect on location of cornering stiffness peak.</p> <code>PPY3</code> <code>float</code> <p>Linear pressure effect on lateral friction.</p> <code>PPY4</code> <code>float</code> <p>Quadratic pressure effect on lateral friction.</p> <code>PPY5</code> <code>float</code> <p>Influence of inflation pressure on camber stiffness.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class LateralCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for evaluating lateral force, Fy.\n\n    Attributes:\n        PCY1 (float): Shape factor Cfy for lateral forces.\n        PDY1 (float): Lateral friction Muy.\n        PDY2 (float): Variation of friction Muy with load.\n        PDY3 (float): Variation of friction Muy with squared camber.\n        PEY1 (float): Lateral curvature Efy at Fznom.\n        PEY2 (float): Variation of curvature Efy with load.\n        PEY3 (float): Zero order camber dependency of curvature Efy.\n        PEY4 (float): Variation of curvature Efy with camber.\n        PEY5 (float): Camber curvature Efc.\n        PKY1 (float): Maximum value of stiffness Kfy/Fznom.\n        PKY2 (float): Load at which Kfy reaches maximum value.\n        PKY3 (float): Variation of Kfy/Fznom with camber.\n        PKY4 (float): Curvature of stiffness Kfy.\n        PKY5 (float): Peak stiffness variation with camber squared.\n        PKY6 (float): Camber stiffness factor.\n        PKY7 (float): Load dependency of camber stiffness factor.\n        PHY1 (float): Horizontal shift Shy at Fznom.\n        PHY2 (float): Variation of shift Shy with load.\n        PVY1 (float): Vertical shift in Svy/Fz at Fznom.\n        PVY2 (float): Variation of shift Svy/Fz with load.\n        PVY3 (float): Variation of shift Svy/Fz with camber.\n        PVY4 (float): Variation of shift Svy/Fz with camber and load.\n        RBY1 (float): Slope factor for combined Fy reduction.\n        RBY2 (float): Variation of slope Fy reduction with alpha.\n        RBY3 (float): Shift term for alpha in slope Fy reduction.\n        RBY4 (float): Influence of camber on stiffness of Fy combined.\n        RCY1 (float): Shape factor for combined Fy reduction.\n        REY1 (float): Curvature factor of combined Fy.\n        REY2 (float): Curvature factor of combined Fy with load.\n        RHY1 (float): Shift factor for combined Fy reduction.\n        RHY2 (float): Shift factor for combined Fy reduction with load.\n        RVY1 (float): Kappa induced side force Svyk/Muy*Fz at Fznom.\n        RVY2 (float): Variation of Svyk/Muy*Fz with load.\n        RVY3 (float): Variation of Svyk/Muy*Fz with camber.\n        RVY4 (float): Variation of Svyk/Muy*Fz with alpha.\n        RVY5 (float): Variation of Svyk/Muy*Fz with kappa.\n        RVY6 (float): Variation of Svyk/Muy*Fz with atan(kappa).\n        PPY1 (float): Pressure effect on cornering stiffness magnitude.\n        PPY2 (float): Pressure effect on location of cornering stiffness peak.\n        PPY3 (float): Linear pressure effect on lateral friction.\n        PPY4 (float): Quadratic pressure effect on lateral friction.\n        PPY5 (float): Influence of inflation pressure on camber stiffness.\n    \"\"\"\n\n    PCY1: float\n    PDY1: float\n    PDY2: float\n    PDY3: float\n    PEY1: float\n    PEY2: float\n    PEY3: float\n    PEY4: float\n    PEY5: float\n    PKY1: float\n    PKY2: float\n    PKY3: float\n    PKY4: float\n    PKY5: float\n    PKY6: float\n    PKY7: float\n    PHY1: float\n    PHY2: float\n    PVY1: float\n    PVY2: float\n    PVY3: float\n    PVY4: float\n    RBY1: float\n    RBY2: float\n    RBY3: float\n    RBY4: float\n    RCY1: float\n    REY1: float\n    REY2: float\n    RHY1: float\n    RHY2: float\n    RVY1: float\n    RVY2: float\n    RVY3: float\n    RVY4: float\n    RVY5: float\n    RVY6: float\n    PPY1: float\n    PPY2: float\n    PPY3: float\n    PPY4: float\n    PPY5: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.LongSlipRange","title":"<code>LongSlipRange</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Minimum and maximum valid longitudinal slips.</p> <p>Attributes:</p> Name Type Description <code>KPUMIN</code> <code>Optional[float]</code> <p>Minimum valid wheel slip.</p> <code>KPUMAX</code> <code>Optional[float]</code> <p>Maximum valid wheel slip.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class LongSlipRange(_ParameterGroup):\n    \"\"\"\n    Minimum and maximum valid longitudinal slips.\n\n    Attributes:\n        KPUMIN (Optional[float]): Minimum valid wheel slip.\n        KPUMAX (Optional[float]): Maximum valid wheel slip.\n    \"\"\"\n\n    KPUMIN: Optional[float] = None\n    KPUMAX: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.LongitudinalCoefficients","title":"<code>LongitudinalCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for evaluating longitudinal force, Fx.</p> <p>Attributes:</p> Name Type Description <code>PCX1</code> <code>float</code> <p>Shape factor Cf for longitudinal force.</p> <code>PDX1</code> <code>float</code> <p>Longitudinal friction Mux at Fznom.</p> <code>PDX2</code> <code>float</code> <p>Variation of friction Mux with load.</p> <code>PDX3</code> <code>float</code> <p>Variation of friction Mux with camber.</p> <code>PEX1</code> <code>float</code> <p>Longitudinal curvature Ef at Fznom.</p> <code>PEX2</code> <code>float</code> <p>Variation of curvature Ef with load.</p> <code>PEX3</code> <code>float</code> <p>Variation of curvature Ef with load squared.</p> <code>PEX4</code> <code>float</code> <p>Factor in curvature Ef while driving.</p> <code>PKX1</code> <code>float</code> <p>Longitudinal slip stiffness Kf/Fz at Fznom.</p> <code>PKX2</code> <code>float</code> <p>Variation of slip stiffness Kf/Fz with load.</p> <code>PKX3</code> <code>float</code> <p>Exponent in slip stiffness Kf/Fz with load.</p> <code>PHX1</code> <code>float</code> <p>Horizontal shift Shx at Fznom.</p> <code>PHX2</code> <code>float</code> <p>Variation of shift Shx with load.</p> <code>PVX1</code> <code>float</code> <p>Vertical shift Sv/Fz at Fznom.</p> <code>PVX2</code> <code>float</code> <p>Variation of shift Sv/Fz with load.</p> <code>RBX1</code> <code>float</code> <p>Slope factor for combined slip Fx reduction.</p> <code>RBX2</code> <code>float</code> <p>Variation of slope Fx reduction with kappa.</p> <code>RBX3</code> <code>float</code> <p>Influence of camber on stiffness for Fx combined.</p> <code>RCX1</code> <code>float</code> <p>Shape factor for combined slip Fx reduction.</p> <code>REX1</code> <code>float</code> <p>Curvature factor of combined Fx.</p> <code>REX2</code> <code>float</code> <p>Curvature factor of combined Fx with load.</p> <code>RHX1</code> <code>float</code> <p>Shift factor for combined slip Fx reduction.</p> <code>PPX1</code> <code>float</code> <p>Linear pressure effect on slip stiffness.</p> <code>PPX2</code> <code>float</code> <p>Quadratic pressure effect on slip stiffness.</p> <code>PPX3</code> <code>float</code> <p>Linear pressure effect on longitudinal friction.</p> <code>PPX4</code> <code>float</code> <p>Quadratic pressure effect on longitudinal friction.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class LongitudinalCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for evaluating longitudinal force, Fx.\n\n    Attributes:\n        PCX1 (float): Shape factor Cf for longitudinal force.\n        PDX1 (float): Longitudinal friction Mux at Fznom.\n        PDX2 (float): Variation of friction Mux with load.\n        PDX3 (float): Variation of friction Mux with camber.\n        PEX1 (float): Longitudinal curvature Ef at Fznom.\n        PEX2 (float): Variation of curvature Ef with load.\n        PEX3 (float): Variation of curvature Ef with load squared.\n        PEX4 (float): Factor in curvature Ef while driving.\n        PKX1 (float): Longitudinal slip stiffness Kf/Fz at Fznom.\n        PKX2 (float): Variation of slip stiffness Kf/Fz with load.\n        PKX3 (float): Exponent in slip stiffness Kf/Fz with load.\n        PHX1 (float): Horizontal shift Shx at Fznom.\n        PHX2 (float): Variation of shift Shx with load.\n        PVX1 (float): Vertical shift Sv/Fz at Fznom.\n        PVX2 (float): Variation of shift Sv/Fz with load.\n        RBX1 (float): Slope factor for combined slip Fx reduction.\n        RBX2 (float): Variation of slope Fx reduction with kappa.\n        RBX3 (float): Influence of camber on stiffness for Fx combined.\n        RCX1 (float): Shape factor for combined slip Fx reduction.\n        REX1 (float): Curvature factor of combined Fx.\n        REX2 (float): Curvature factor of combined Fx with load.\n        RHX1 (float): Shift factor for combined slip Fx reduction.\n        PPX1 (float): Linear pressure effect on slip stiffness.\n        PPX2 (float): Quadratic pressure effect on slip stiffness.\n        PPX3 (float): Linear pressure effect on longitudinal friction.\n        PPX4 (float): Quadratic pressure effect on longitudinal friction.\n    \"\"\"\n\n    PCX1: float\n    PDX1: float\n    PDX2: float\n    PDX3: float\n    PEX1: float\n    PEX2: float\n    PEX3: float\n    PEX4: float\n    PKX1: float\n    PKX2: float\n    PKX3: float\n    PHX1: float\n    PHX2: float\n    PVX1: float\n    PVX2: float\n    RBX1: float\n    RBX2: float\n    RBX3: float\n    RCX1: float\n    REX1: float\n    REX2: float\n    RHX1: float\n    PPX1: float\n    PPX2: float\n    PPX3: float\n    PPX4: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Parameters on the usage of the tyre model.</p> <p>Attributes:</p> Name Type Description <code>FITTYP</code> <code>int</code> <p>Magic Formula version number.</p> <code>TYRESIDE</code> <code>str</code> <p>Position of tyre during measurements. \"LEFT\" or \"RIGHT\" (default = \"LEFT\").</p> <code>LONGVL</code> <code>float</code> <p>Reference speed.</p> <code>VXLOW</code> <code>float</code> <p>Lower boundary velocity in slip calculation.</p> <code>ROAD_INCREMENT</code> <code>Optional[float]</code> <p>Increment in road sampling.</p> <code>ROAD_DIRECTION</code> <code>Optional[float]</code> <p>Direction of travelled distance. 1 = default, -1 = reverse (default = 1)</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Model(_ParameterGroup):\n    \"\"\"\n    Parameters on the usage of the tyre model.\n\n    Attributes:\n        FITTYP (int): Magic Formula version number.\n        TYRESIDE (str): Position of tyre during measurements.\n            \"LEFT\" or \"RIGHT\" (default = \"LEFT\").\n        LONGVL (float): Reference speed.\n        VXLOW (float): Lower boundary velocity in slip calculation.\n        ROAD_INCREMENT (Optional[float]): Increment in road sampling.\n        ROAD_DIRECTION (Optional[float]): Direction of travelled distance.\n            1 = default, -1 = reverse (default = 1)\n    \"\"\"\n\n    FITTYP: int\n    TYRESIDE: str = \"LEFT\"\n    LONGVL: float\n    VXLOW: float\n    ROAD_INCREMENT: Optional[float] = None\n    ROAD_DIRECTION: Optional[float] = 1\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.OperatingConditions","title":"<code>OperatingConditions</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Operating conditions of the tyre.</p> <p>Attributes:</p> Name Type Description <code>INFLPRES</code> <code>float</code> <p>Tyre inflation pressure.</p> <code>NOMPRES</code> <code>float</code> <p>Nominal pressure used in Magic Formula equations.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class OperatingConditions(_ParameterGroup):\n    \"\"\"\n    Operating conditions of the tyre.\n\n    Attributes:\n        INFLPRES (float): Tyre inflation pressure.\n        NOMPRES (float): Nominal pressure used in Magic Formula equations.\n    \"\"\"\n\n    INFLPRES: float\n    NOMPRES: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.OverturningCoefficients","title":"<code>OverturningCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for evaluating overturning moment, Mx.</p> <p>Attributes:</p> Name Type Description <code>QSX1</code> <code>float</code> <p>Overturning moment offset.</p> <code>QSX2</code> <code>float</code> <p>Camber induced overturning couple.</p> <code>QSX3</code> <code>float</code> <p>Fy induced overturning couple.</p> <code>QSX4</code> <code>float</code> <p>Mixed load, lateral force and camber on Mx.</p> <code>QSX5</code> <code>float</code> <p>Load effect on Mx with lateral force and camber.</p> <code>QSX6</code> <code>float</code> <p>B-factor of load with Mx.</p> <code>QSX7</code> <code>float</code> <p>Camber with load on Mx.</p> <code>QSX8</code> <code>float</code> <p>Lateral force with load on Mx.</p> <code>QSX9</code> <code>float</code> <p>B-factor of lateral force with load on Mx.</p> <code>QSX10</code> <code>float</code> <p>Vertical force with camber on Mx.</p> <code>QSX11</code> <code>float</code> <p>B-factor of vertical force with camber on Mx.</p> <code>QSX12</code> <code>Optional[float]</code> <p>Camber squared induced overturning moment.</p> <code>QSX13</code> <code>Optional[float]</code> <p>Lateral force induced overturning moment.</p> <code>QSX14</code> <code>Optional[float]</code> <p>Lateral force induced overturning moment with camber.</p> <code>PPMX1</code> <code>float</code> <p>Influence of inflation pressure on overturning moment.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class OverturningCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for evaluating overturning moment, Mx.\n\n    Attributes:\n        QSX1 (float): Overturning moment offset.\n        QSX2 (float): Camber induced overturning couple.\n        QSX3 (float): Fy induced overturning couple.\n        QSX4 (float): Mixed load, lateral force and camber on Mx.\n        QSX5 (float): Load effect on Mx with lateral force and camber.\n        QSX6 (float): B-factor of load with Mx.\n        QSX7 (float): Camber with load on Mx.\n        QSX8 (float): Lateral force with load on Mx.\n        QSX9 (float): B-factor of lateral force with load on Mx.\n        QSX10 (float): Vertical force with camber on Mx.\n        QSX11 (float): B-factor of vertical force with camber on Mx.\n        QSX12 (Optional[float]): Camber squared induced overturning moment.\n        QSX13 (Optional[float]): Lateral force induced overturning moment.\n        QSX14 (Optional[float]): Lateral force induced overturning moment with camber.\n        PPMX1 (float): Influence of inflation pressure on overturning moment.\n    \"\"\"\n\n    QSX1: float\n    QSX2: float\n    QSX3: float\n    QSX4: float\n    QSX5: float\n    QSX6: float\n    QSX7: float\n    QSX8: float\n    QSX9: float\n    QSX10: float\n    QSX11: float\n    QSX12: Optional[float] = None\n    QSX13: Optional[float] = None\n    QSX14: Optional[float] = None\n    PPMX1: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.RollingCoefficients","title":"<code>RollingCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for evaluating rolling resistance moment, My.</p> <p>Attributes:</p> Name Type Description <code>QSY1</code> <code>float</code> <p>Rolling resistance torque coefficient.</p> <code>QSY2</code> <code>float</code> <p>Rolling resistance torque depending on Fx.</p> <code>QSY3</code> <code>float</code> <p>Rolling resistance torque depending on speed.</p> <code>QSY4</code> <code>float</code> <p>Rolling resistance torque depending on the fourth power of speed.</p> <code>QSY5</code> <code>float</code> <p>Rolling resistance torque depending on camber squared.</p> <code>QSY6</code> <code>float</code> <p>Rolling resistance torque depending on load and camber squared.</p> <code>QSY7</code> <code>float</code> <p>Rolling resistance torque coefficient load dependency.</p> <code>QSY8</code> <code>float</code> <p>Rolling resistance torque coefficient pressure dependency.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class RollingCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for evaluating rolling resistance moment, My.\n\n    Attributes:\n        QSY1 (float): Rolling resistance torque coefficient.\n        QSY2 (float): Rolling resistance torque depending on Fx.\n        QSY3 (float): Rolling resistance torque depending on speed.\n        QSY4 (float): Rolling resistance torque depending on the fourth power of speed.\n        QSY5 (float): Rolling resistance torque depending on camber squared.\n        QSY6 (float): Rolling resistance torque depending on load and camber squared.\n        QSY7 (float): Rolling resistance torque coefficient load dependency.\n        QSY8 (float): Rolling resistance torque coefficient pressure dependency.\n    \"\"\"\n\n    QSY1: float\n    QSY2: float\n    QSY3: float\n    QSY4: float\n    QSY5: float\n    QSY6: float\n    QSY7: float\n    QSY8: float\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.ScalingCoefficients","title":"<code>ScalingCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Magic Formula scaling factors.</p> <p>Attributes:</p> Name Type Description <code>LFZO</code> <code>float</code> <p>Scale factor of nominal (rated) load.</p> <code>LCX</code> <code>float</code> <p>Scale factor of Fx shape factor.</p> <code>LMUX</code> <code>float</code> <p>Scale factor of Fx peak friction coefficient.</p> <code>LEX</code> <code>float</code> <p>Scale factor of Fx curvature factor.</p> <code>LKX</code> <code>float</code> <p>Scale factor of slip stiffness.</p> <code>LHX</code> <code>float</code> <p>Scale factor of Fx horizontal shift.</p> <code>LVX</code> <code>float</code> <p>Scale factor of Fx vertical shift.</p> <code>LCY</code> <code>float</code> <p>Scale factor of Fy shape factor.</p> <code>LMUY</code> <code>float</code> <p>Scale factor of Fy peak friction coefficient.</p> <code>LEY</code> <code>float</code> <p>Scale factor of Fy curvature factor.</p> <code>LKY</code> <code>float</code> <p>Scale factor of cornering stiffness.</p> <code>LKYC</code> <code>float</code> <p>Scale factor of camber stiffness.</p> <code>LKZC</code> <code>float</code> <p>Scale factor of camber moment stiffness.</p> <code>LHY</code> <code>float</code> <p>Scale factor of Fy horizontal shift.</p> <code>LVY</code> <code>float</code> <p>Scale factor of Fy vertical shift.</p> <code>LTR</code> <code>float</code> <p>Scale factor of peak of pneumatic trail.</p> <code>LRES</code> <code>float</code> <p>Scale factor for offset of residual torque.</p> <code>LXAL</code> <code>float</code> <p>Scale factor of alpha influence on Fx.</p> <code>LYKA</code> <code>float</code> <p>Scale factor of kappa influence on Fy.</p> <code>LVYKA</code> <code>float</code> <p>Scale factor of kappa induced 'ply-steer' Fy.</p> <code>LS</code> <code>float</code> <p>Scale factor of moment arm of Fx.</p> <code>LMX</code> <code>float</code> <p>Scale factor of overturning moment.</p> <code>LVMX</code> <code>float</code> <p>Scale factor of Mx vertical shift.</p> <code>LMY</code> <code>float</code> <p>Scale factor of rolling resistance torque.</p> <code>LMP</code> <code>Optional[float]</code> <p>Scale factor of parking moment.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class ScalingCoefficients(_ParameterGroup):\n    \"\"\"\n    Magic Formula scaling factors.\n\n    Attributes:\n        LFZO (float): Scale factor of nominal (rated) load.\n        LCX (float): Scale factor of Fx shape factor.\n        LMUX (float): Scale factor of Fx peak friction coefficient.\n        LEX (float): Scale factor of Fx curvature factor.\n        LKX (float): Scale factor of slip stiffness.\n        LHX (float): Scale factor of Fx horizontal shift.\n        LVX (float): Scale factor of Fx vertical shift.\n        LCY (float): Scale factor of Fy shape factor.\n        LMUY (float): Scale factor of Fy peak friction coefficient.\n        LEY (float): Scale factor of Fy curvature factor.\n        LKY (float): Scale factor of cornering stiffness.\n        LKYC (float): Scale factor of camber stiffness.\n        LKZC (float): Scale factor of camber moment stiffness.\n        LHY (float): Scale factor of Fy horizontal shift.\n        LVY (float): Scale factor of Fy vertical shift.\n        LTR (float): Scale factor of peak of pneumatic trail.\n        LRES (float): Scale factor for offset of residual torque.\n        LXAL (float): Scale factor of alpha influence on Fx.\n        LYKA (float): Scale factor of kappa influence on Fy.\n        LVYKA (float): Scale factor of kappa induced 'ply-steer' Fy.\n        LS (float): Scale factor of moment arm of Fx.\n        LMX (float): Scale factor of overturning moment.\n        LVMX (float): Scale factor of Mx vertical shift.\n        LMY (float): Scale factor of rolling resistance torque.\n        LMP (Optional[float]): Scale factor of parking moment.\n    \"\"\"\n\n    LFZO: float = 1\n    LCX: float = 1\n    LMUX: float = 1\n    LEX: float = 1\n    LKX: float = 1\n    LHX: float = 1\n    LVX: float = 1\n    LCY: float = 1\n    LMUY: float = 1\n    LEY: float = 1\n    LKY: float = 1\n    LKYC: float = 1\n    LKZC: float = 1\n    LHY: float = 1\n    LVY: float = 1\n    LTR: float = 1\n    LRES: float = 1\n    LXAL: float = 1\n    LYKA: float = 1\n    LVYKA: float = 1\n    LS: float = 1\n    LMX: float = 1\n    LVMX: float = 1\n    LMY: float = 1\n    LMP: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.SlipAngleRange","title":"<code>SlipAngleRange</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Minimum and maximum valid sideslip angles.</p> <p>Attributes:</p> Name Type Description <code>ALPMIN</code> <code>Optional[float]</code> <p>Minimum valid slip angle.</p> <code>ALPMAX</code> <code>Optional[float]</code> <p>Maximum valid slip angle.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class SlipAngleRange(_ParameterGroup):\n    \"\"\"\n    Minimum and maximum valid sideslip angles.\n\n    Attributes:\n        ALPMIN (Optional[float]): Minimum valid slip angle.\n        ALPMAX (Optional[float]): Maximum valid slip angle.\n    \"\"\"\n\n    ALPMIN: Optional[float] = None\n    ALPMAX: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Structural","title":"<code>Structural</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Tyre stiffness, damping, and eigenfrequencies.</p> <p>Attributes:</p> Name Type Description <code>LONGITUDINAL_STIFFNESS</code> <code>Optional[float]</code> <p>Tyre overall longitudinal stiffness.</p> <code>LATERAL_STIFFNESS</code> <code>Optional[float]</code> <p>Tyre overall lateral stiffness.</p> <code>YAW_STIFFNESS</code> <code>Optional[float]</code> <p>Tyre overall yaw stiffness.</p> <code>FREQ_LONG</code> <code>Optional[float]</code> <p>Undamped frequency fore/aft and vertical mode.</p> <code>FREQ_LAT</code> <code>Optional[float]</code> <p>Undamped frequency lateral mode.</p> <code>FREQ_YAW</code> <code>Optional[float]</code> <p>Undamped frequency yaw and camber mode.</p> <code>FREQ_WINDUP</code> <code>Optional[float]</code> <p>Undamped frequency wind-up mode.</p> <code>DAMP_LONG</code> <code>Optional[float]</code> <p>Dimensionless damping fore/aft and vertical mode.</p> <code>DAMP_LAT</code> <code>Optional[float]</code> <p>Dimensionless damping lateral mode.</p> <code>DAMP_YAW</code> <code>Optional[float]</code> <p>Dimensionless damping yaw and camber mode.</p> <code>DAMP_WINDUP</code> <code>Optional[float]</code> <p>Dimensionless damping wind-up mode.</p> <code>DAMP_RESIDUAL</code> <code>Optional[float]</code> <p>Residual damping (proportional to stiffness).</p> <code>DAMP_VLOW</code> <code>Optional[float]</code> <p>Additional low speed damping (proportional to stiffness).</p> <code>Q_BVX</code> <code>Optional[float]</code> <p>Load and speed influence on in-plane translation stiffness.</p> <code>Q_BVT</code> <code>Optional[float]</code> <p>Load and speed influence on in-plane rotation stiffness.</p> <code>PCFX1</code> <code>Optional[float]</code> <p>Tyre overall longitudinal stiffness vertical deflection dependency linear term.</p> <code>PCFX2</code> <code>Optional[float]</code> <p>Tyre overall longitudinal stiffness vertical deflection dependency quadratic term.</p> <code>PCFX3</code> <code>Optional[float]</code> <p>Tyre overall longitudinal stiffness pressure dependency.</p> <code>PCFY1</code> <code>Optional[float]</code> <p>Tyre overall lateral stiffness vertical deflection dependency linear term.</p> <code>PCFY2</code> <code>Optional[float]</code> <p>Tyre overall lateral stiffness vertical deflection dependency quadratic term.</p> <code>PCFY3</code> <code>Optional[float]</code> <p>Tyre overall lateral stiffness pressure dependency.</p> <code>PCMZ1</code> <code>Optional[float]</code> <p>Tyre overall yaw stiffness pressure dependency.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Structural(_ParameterGroup):\n    \"\"\"\n    Tyre stiffness, damping, and eigenfrequencies.\n\n    Attributes:\n        LONGITUDINAL_STIFFNESS (Optional[float]):\n            Tyre overall longitudinal stiffness.\n        LATERAL_STIFFNESS (Optional[float]): Tyre overall lateral stiffness.\n        YAW_STIFFNESS (Optional[float]): Tyre overall yaw stiffness.\n        FREQ_LONG (Optional[float]):\n            Undamped frequency fore/aft and vertical mode.\n        FREQ_LAT (Optional[float]): Undamped frequency lateral mode.\n        FREQ_YAW (Optional[float]): Undamped frequency yaw and camber mode.\n        FREQ_WINDUP (Optional[float]): Undamped frequency wind-up mode.\n        DAMP_LONG (Optional[float]):\n            Dimensionless damping fore/aft and vertical mode.\n        DAMP_LAT (Optional[float]): Dimensionless damping lateral mode.\n        DAMP_YAW (Optional[float]): Dimensionless damping yaw and camber mode.\n        DAMP_WINDUP (Optional[float]): Dimensionless damping wind-up mode.\n        DAMP_RESIDUAL (Optional[float]):\n            Residual damping (proportional to stiffness).\n        DAMP_VLOW (Optional[float]):\n            Additional low speed damping (proportional to stiffness).\n        Q_BVX (Optional[float]):\n            Load and speed influence on in-plane translation stiffness.\n        Q_BVT (Optional[float]):\n            Load and speed influence on in-plane rotation stiffness.\n        PCFX1 (Optional[float]): Tyre overall longitudinal stiffness\n            vertical deflection dependency linear term.\n        PCFX2 (Optional[float]): Tyre overall longitudinal stiffness\n            vertical deflection dependency quadratic term.\n        PCFX3 (Optional[float]):\n            Tyre overall longitudinal stiffness pressure dependency.\n        PCFY1 (Optional[float]): Tyre overall lateral stiffness\n            vertical deflection dependency linear term.\n        PCFY2 (Optional[float]): Tyre overall lateral stiffness\n            vertical deflection dependency quadratic term.\n        PCFY3 (Optional[float]):\n            Tyre overall lateral stiffness pressure dependency.\n        PCMZ1 (Optional[float]): Tyre overall yaw stiffness pressure dependency.\n    \"\"\"\n\n    LONGITUDINAL_STIFFNESS: Optional[float] = None\n    LATERAL_STIFFNESS: Optional[float] = None\n    YAW_STIFFNESS: Optional[float] = None\n    FREQ_LONG: Optional[float] = None\n    FREQ_LAT: Optional[float] = None\n    FREQ_YAW: Optional[float] = None\n    FREQ_WINDUP: Optional[float] = None\n    DAMP_LONG: Optional[float] = None\n    DAMP_LAT: Optional[float] = None\n    DAMP_YAW: Optional[float] = None\n    DAMP_WINDUP: Optional[float] = None\n    DAMP_RESIDUAL: Optional[float] = None\n    DAMP_VLOW: Optional[float] = None\n    Q_BVX: Optional[float] = None\n    Q_BVT: Optional[float] = None\n    PCFX1: Optional[float] = None\n    PCFX2: Optional[float] = None\n    PCFX3: Optional[float] = None\n    PCFY1: Optional[float] = None\n    PCFY2: Optional[float] = None\n    PCFY3: Optional[float] = None\n    PCMZ1: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.TIRParameters","title":"<code>TIRParameters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Tyre parameters specified in a .TIR file.</p> <p>For ease of use, parameters are split into groups.</p> <p>Values can be accessed using dot notation:</p> <p>Attributes:</p> Name Type Description <code>UNITS</code> <code>Units</code> <p>Units used in the .TIR file.</p> <code>MODEL</code> <code>Model</code> <p>Parameters on the usage of the tyre model.</p> <code>DIMENSION</code> <code>Dimension</code> <p>Tyre dimensions.</p> <code>OPERATING_CONDITIONS</code> <code>OperatingConditions</code> <p>Operating conditions of the tyre.</p> <code>INERTIA</code> <code>Inertia</code> <p>Mass and inertia properties of the tyre and tyre belt.</p> <code>VERTICAL</code> <code>Vertical</code> <p>Vertical stiffness, loaded and effective rolling radius.</p> <code>STRUCTURAL</code> <code>Structural</code> <p>Tyre stiffness, damping, and eigenfrequencies.</p> <code>CONTACT_PATCH</code> <code>ContactPatch</code> <p>Contact length and obstacle enveloping parameters.</p> <code>INFLATION_PRESSURE_RANGE</code> <code>InflationPressureRange</code> <p>Minimum and maximum allowed inflation pressures.</p> <code>VERTICAL_FORCE_RANGE</code> <code>VerticalForceRange</code> <p>Minimum and maximum allowed wheel loads.</p> <code>LONG_SLIP_RANGE</code> <code>LongSlipRange</code> <p>Minimum and maximum valid longitudinal slips.</p> <code>SLIP_ANGLE_RANGE</code> <code>SlipAngleRange</code> <p>Minimum and maximum valid sideslip angles.</p> <code>INCLINATION_ANGLE_RANGE</code> <code>InclinationAngleRange</code> <p>Minimum and maximum valid inclination angles.</p> <code>SCALING_COEFFICIENTS</code> <code>ScalingCoefficients</code> <p>Magic Formula scaling factors.</p> <code>LONGITUDINAL_COEFFICIENTS</code> <code>LongitudinalCoefficients</code> <p>Coefficients for evaluating longitudinal force, Fx.</p> <code>OVERTURNING_COEFFICIENTS</code> <code>OverturningCoefficients</code> <p>Coefficients for evaluating overturning moment, Mx.</p> <code>LATERAL_COEFFICIENTS</code> <code>LateralCoefficients</code> <p>Coefficients for evaluating lateral force, Fy.</p> <code>ROLLING_COEFFICIENTS</code> <code>RollingCoefficients</code> <p>Coefficients for evaluating rolling resistance moment, My.</p> <code>ALIGNING_COEFFICIENTS</code> <code>AligningCoefficients</code> <p>Coefficients for evaluating self-aligning moment, Mz.</p> <code>TURNSLIP_COEFFICIENTS</code> <code>TurnslipCoefficients</code> <p>Coefficients for turn slip, affecting all forces and moments.</p> <p>Examples:</p> <p>Load tyre parameters from a .TIR file <code>Example Tyre.tir</code>, and get the inflation pressure of the tyre (<code>INFLPRES</code>).</p> <pre><code>&gt;&gt;&gt; tir_parameters = TIRParameters.from_file(\"Example Tyre.tir\")\n&gt;&gt;&gt; inflation_pressure = tir_parameters.OPERATING_CONDITIONS.INFLPRES\n</code></pre> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class TIRParameters(BaseModel):\n    \"\"\"\n    Tyre parameters specified in a .TIR file.\n\n    For ease of use, parameters are split into groups.\n\n    Values can be accessed using dot notation:\n\n    Attributes:\n        UNITS (Units):\n            Units used in the .TIR file.\n        MODEL (Model):\n            Parameters on the usage of the tyre model.\n        DIMENSION (Dimension):\n            Tyre dimensions.\n        OPERATING_CONDITIONS (OperatingConditions):\n            Operating conditions of the tyre.\n        INERTIA (Inertia):\n            Mass and inertia properties of the tyre and tyre belt.\n        VERTICAL (Vertical):\n            Vertical stiffness, loaded and effective rolling radius.\n        STRUCTURAL (Structural):\n            Tyre stiffness, damping, and eigenfrequencies.\n        CONTACT_PATCH (ContactPatch):\n            Contact length and obstacle enveloping parameters.\n        INFLATION_PRESSURE_RANGE (InflationPressureRange):\n            Minimum and maximum allowed inflation pressures.\n        VERTICAL_FORCE_RANGE (VerticalForceRange):\n            Minimum and maximum allowed wheel loads.\n        LONG_SLIP_RANGE (LongSlipRange):\n            Minimum and maximum valid longitudinal slips.\n        SLIP_ANGLE_RANGE (SlipAngleRange):\n            Minimum and maximum valid sideslip angles.\n        INCLINATION_ANGLE_RANGE (InclinationAngleRange):\n            Minimum and maximum valid inclination angles.\n        SCALING_COEFFICIENTS (ScalingCoefficients):\n            Magic Formula scaling factors.\n        LONGITUDINAL_COEFFICIENTS (LongitudinalCoefficients):\n            Coefficients for evaluating longitudinal force, Fx.\n        OVERTURNING_COEFFICIENTS (OverturningCoefficients):\n            Coefficients for evaluating overturning moment, Mx.\n        LATERAL_COEFFICIENTS (LateralCoefficients):\n            Coefficients for evaluating lateral force, Fy.\n        ROLLING_COEFFICIENTS (RollingCoefficients):\n            Coefficients for evaluating rolling resistance moment, My.\n        ALIGNING_COEFFICIENTS (AligningCoefficients):\n            Coefficients for evaluating self-aligning moment, Mz.\n        TURNSLIP_COEFFICIENTS (TurnslipCoefficients):\n            Coefficients for turn slip, affecting all forces and moments.\n\n    Examples:\n        Load tyre parameters from a .TIR file `Example Tyre.tir`,\n        and get the inflation pressure of the tyre (`INFLPRES`).\n\n        &gt;&gt;&gt; tir_parameters = TIRParameters.from_file(\"Example Tyre.tir\")\n        &gt;&gt;&gt; inflation_pressure = tir_parameters.OPERATING_CONDITIONS.INFLPRES\n    \"\"\"\n\n    UNITS: Units\n    MODEL: Model\n    DIMENSION: Dimension\n    OPERATING_CONDITIONS: OperatingConditions\n    INERTIA: Inertia\n    VERTICAL: Vertical\n    STRUCTURAL: Structural\n    CONTACT_PATCH: ContactPatch\n    INFLATION_PRESSURE_RANGE: InflationPressureRange\n    VERTICAL_FORCE_RANGE: VerticalForceRange\n    LONG_SLIP_RANGE: LongSlipRange\n    SLIP_ANGLE_RANGE: SlipAngleRange\n    INCLINATION_ANGLE_RANGE: InclinationAngleRange\n    SCALING_COEFFICIENTS: ScalingCoefficients\n    LONGITUDINAL_COEFFICIENTS: LongitudinalCoefficients\n    OVERTURNING_COEFFICIENTS: OverturningCoefficients\n    LATERAL_COEFFICIENTS: LateralCoefficients\n    ROLLING_COEFFICIENTS: RollingCoefficients\n    ALIGNING_COEFFICIENTS: AligningCoefficients\n    TURNSLIP_COEFFICIENTS: TurnslipCoefficients\n\n    def __str__(self) -&gt; str:\n        return self.model_dump_json(indent=4)\n\n    @classmethod\n    def from_file(cls, filepath: str) -&gt; Self:\n        \"\"\"\n        Generate a TIRParameters object from a .TIR file.\n\n        Uses _TIRReader to parse the .TIR file into a dictionary,\n        then converts it to a TIRParameters object.\n\n        Args:\n            filepath (str):\n                Filepath to the .TIR file.\n\n        Returns:\n            self (TIRParameters):\n                A TIRParameters object.\n\n        Raises:\n            FileNotFoundError:\n                If the file is not found.\n            ValueError:\n                If an error occurs while parsing the .TIR file.\n            ValidationError:\n                If the data cannot be converted\n                into a valid `TIRParameters` object.\n        \"\"\"\n        tir_data = _TIRReader().read(filepath)\n        return cls.model_validate(tir_data)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.TIRParameters.from_file","title":"<code>from_file(filepath)</code>  <code>classmethod</code>","text":"<p>Generate a TIRParameters object from a .TIR file.</p> <p>Uses _TIRReader to parse the .TIR file into a dictionary, then converts it to a TIRParameters object.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Filepath to the .TIR file.</p> required <p>Returns:</p> Name Type Description <code>self</code> <code>TIRParameters</code> <p>A TIRParameters object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file is not found.</p> <code>ValueError</code> <p>If an error occurs while parsing the .TIR file.</p> <code>ValidationError</code> <p>If the data cannot be converted into a valid <code>TIRParameters</code> object.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>@classmethod\ndef from_file(cls, filepath: str) -&gt; Self:\n    \"\"\"\n    Generate a TIRParameters object from a .TIR file.\n\n    Uses _TIRReader to parse the .TIR file into a dictionary,\n    then converts it to a TIRParameters object.\n\n    Args:\n        filepath (str):\n            Filepath to the .TIR file.\n\n    Returns:\n        self (TIRParameters):\n            A TIRParameters object.\n\n    Raises:\n        FileNotFoundError:\n            If the file is not found.\n        ValueError:\n            If an error occurs while parsing the .TIR file.\n        ValidationError:\n            If the data cannot be converted\n            into a valid `TIRParameters` object.\n    \"\"\"\n    tir_data = _TIRReader().read(filepath)\n    return cls.model_validate(tir_data)\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.TurnslipCoefficients","title":"<code>TurnslipCoefficients</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Coefficients for turn slip, affecting all forces and moments.</p> <p>Attributes:</p> Name Type Description <code>PDXP1</code> <code>Optional[float]</code> <p>Peak Fx reduction due to spin parameter.</p> <code>PDXP2</code> <code>Optional[float]</code> <p>Peak Fx reduction due to spin with varying load parameter.</p> <code>PDXP3</code> <code>Optional[float]</code> <p>Peak Fx reduction due to spin with kappa parameter.</p> <code>PKYP1</code> <code>Optional[float]</code> <p>Cornering stiffness reduction due to spin.</p> <code>PDYP1</code> <code>Optional[float]</code> <p>Peak Fy reduction due to spin parameter.</p> <code>PDYP2</code> <code>Optional[float]</code> <p>Peak Fy reduction due to spin with varying load parameter.</p> <code>PDYP3</code> <code>Optional[float]</code> <p>Peak Fy reduction due to spin with alpha parameter.</p> <code>PDYP4</code> <code>Optional[float]</code> <p>Peak Fy reduction due to square root of spin parameter.</p> <code>PHYP1</code> <code>Optional[float]</code> <p>Fy-alpha curve lateral shift limitation.</p> <code>PHYP2</code> <code>Optional[float]</code> <p>Fy-alpha curve maximum lateral shift parameter.</p> <code>PHYP3</code> <code>Optional[float]</code> <p>Fy-alpha curve maximum lateral shift varying with load parameter.</p> <code>PHYP4</code> <code>Optional[float]</code> <p>Fy-alpha curve maximum lateral shift parameter.</p> <code>PECP1</code> <code>Optional[float]</code> <p>Camber w.r.t. spin reduction factor parameter in camber stiffness.</p> <code>PECP2</code> <code>Optional[float]</code> <p>Camber w.r.t. spin reduction factor varying with load parameter in camber stiffness.</p> <code>QDTP1</code> <code>Optional[float]</code> <p>Pneumatic trail reduction factor due to turn slip parameter.</p> <code>QCRP1</code> <code>Optional[float]</code> <p>Turning moment at constant turning and zero forward speed parameter.</p> <code>QCRP2</code> <code>Optional[float]</code> <p>Turn slip moment (at alpha=90deg) parameter for increase with spin.</p> <code>QBRP1</code> <code>Optional[float]</code> <p>Residual (spin) torque reduction factor parameter due to side slip.</p> <code>QDRP1</code> <code>Optional[float]</code> <p>Turn slip moment peak magnitude parameter.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class TurnslipCoefficients(_ParameterGroup):\n    \"\"\"\n    Coefficients for turn slip, affecting all forces and moments.\n\n    Attributes:\n        PDXP1 (Optional[float]): Peak Fx reduction due to spin parameter.\n        PDXP2 (Optional[float]): Peak Fx reduction due to spin with varying load parameter.\n        PDXP3 (Optional[float]): Peak Fx reduction due to spin with kappa parameter.\n        PKYP1 (Optional[float]): Cornering stiffness reduction due to spin.\n        PDYP1 (Optional[float]): Peak Fy reduction due to spin parameter.\n        PDYP2 (Optional[float]): Peak Fy reduction due to spin with varying load parameter.\n        PDYP3 (Optional[float]): Peak Fy reduction due to spin with alpha parameter.\n        PDYP4 (Optional[float]): Peak Fy reduction due to square root of spin parameter.\n        PHYP1 (Optional[float]): Fy-alpha curve lateral shift limitation.\n        PHYP2 (Optional[float]): Fy-alpha curve maximum lateral shift parameter.\n        PHYP3 (Optional[float]): Fy-alpha curve maximum lateral shift varying with load parameter.\n        PHYP4 (Optional[float]): Fy-alpha curve maximum lateral shift parameter.\n        PECP1 (Optional[float]): Camber w.r.t. spin reduction factor parameter in camber stiffness.\n        PECP2 (Optional[float]): Camber w.r.t. spin reduction factor\n            varying with load parameter in camber stiffness.\n        QDTP1 (Optional[float]): Pneumatic trail reduction factor due to turn slip parameter.\n        QCRP1 (Optional[float]): Turning moment at constant turning and zero forward speed parameter.\n        QCRP2 (Optional[float]): Turn slip moment (at alpha=90deg) parameter for increase with spin.\n        QBRP1 (Optional[float]): Residual (spin) torque reduction factor parameter due to side slip.\n        QDRP1 (Optional[float]): Turn slip moment peak magnitude parameter.\n    \"\"\"\n\n    PDXP1: Optional[float] = None\n    PDXP2: Optional[float] = None\n    PDXP3: Optional[float] = None\n    PKYP1: Optional[float] = None\n    PDYP1: Optional[float] = None\n    PDYP2: Optional[float] = None\n    PDYP3: Optional[float] = None\n    PDYP4: Optional[float] = None\n    PHYP1: Optional[float] = None\n    PHYP2: Optional[float] = None\n    PHYP3: Optional[float] = None\n    PHYP4: Optional[float] = None\n    PECP1: Optional[float] = None\n    PECP2: Optional[float] = None\n    QDTP1: Optional[float] = None\n    QCRP1: Optional[float] = None\n    QCRP2: Optional[float] = None\n    QBRP1: Optional[float] = None\n    QDRP1: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Units","title":"<code>Units</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Units used in the .TIR file.</p> <p>Attributes:</p> Name Type Description <code>LENGTH</code> <code>str</code> <p>Length units (default: \"meter\").</p> <code>FORCE</code> <code>str</code> <p>Force units (default: \"newton\").</p> <code>ANGLE</code> <code>str</code> <p>Angle units (default: \"radians\").</p> <code>MASS</code> <code>str</code> <p>Mass units (default: \"kg\").</p> <code>TIME</code> <code>str</code> <p>Time units (default: \"second\").</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Units(_ParameterGroup):\n    \"\"\"\n    Units used in the .TIR file.\n\n    Attributes:\n        LENGTH: Length units (default: \"meter\").\n        FORCE: Force units (default: \"newton\").\n        ANGLE: Angle units (default: \"radians\").\n        MASS: Mass units (default: \"kg\").\n        TIME: Time units (default: \"second\").\n    \"\"\"\n\n    LENGTH: str\n    FORCE: str\n    ANGLE: str\n    MASS: str\n    TIME: str\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.Vertical","title":"<code>Vertical</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Vertical stiffness, loaded and effective rolling radius.</p> <p>Attributes:</p> Name Type Description <code>FNOMIN</code> <code>float</code> <p>Nominal wheel load.</p> <code>VERTICAL_STIFFNESS</code> <code>Optional[float]</code> <p>tyre vertical stiffness.</p> <code>VERTICAL_DAMPING</code> <code>Optional[float]</code> <p>tyre vertical damping.</p> <code>MC_CONTOUR_A</code> <code>Optional[float]</code> <p>Motorcycle contour ellipse A.</p> <code>MC_CONTOUR_B</code> <code>Optional[float]</code> <p>Motorcycle contour ellipse B.</p> <code>BREFF</code> <code>Optional[float]</code> <p>Low load stiffness of effective rolling radius.</p> <code>DREFF</code> <code>Optional[float]</code> <p>Peak value of effective rolling radius.</p> <code>FREFF</code> <code>Optional[float]</code> <p>High load stiffness of effective rolling radius.</p> <code>Q_RE0</code> <code>Optional[float]</code> <p>Ratio of free tyre radius with nominal tyre radius.</p> <code>Q_V1</code> <code>Optional[float]</code> <p>tyre radius increase with speed.</p> <code>Q_V2</code> <code>Optional[float]</code> <p>Vertical stiffness increase with speed.</p> <code>Q_FZ2</code> <code>Optional[float]</code> <p>Quadratic term in load vs. deflection.</p> <code>Q_FCX</code> <code>Optional[float]</code> <p>Longitudinal force influence on vertical stiffness.</p> <code>Q_FCY</code> <code>Optional[float]</code> <p>Lateral force influence on vertical stiffness.</p> <code>Q_FCY2</code> <code>Optional[float]</code> <p>Explicit load dependency for including the lateral force influence on vertical stiffness.</p> <code>Q_CAM</code> <code>Optional[float]</code> <p>Stiffness reduction due to camber.</p> <code>Q_CAM1</code> <code>Optional[float]</code> <p>Linear load dependent camber angle influence on vertical stiffness.</p> <code>Q_CAM2</code> <code>Optional[float]</code> <p>Quadratic load dependent camber angle influence on vertical stiffness.</p> <code>Q_CAM3</code> <code>Optional[float]</code> <p>Linear load and camber angle dependent reduction on vertical stiffness.</p> <code>Q_FYS1</code> <code>Optional[float]</code> <p>Combined camber angle and side slip angle effect on vertical stiffness (constant).</p> <code>Q_FYS2</code> <code>Optional[float]</code> <p>Combined camber angle and side slip angle linear effect on vertical stiffness.</p> <code>Q_FYS3</code> <code>Optional[float]</code> <p>Combined camber angle and side slip angle quadratic effect on vertical stiffness.</p> <code>PFZ1</code> <code>Optional[float]</code> <p>Pressure effect on vertical stiffness.</p> <code>BOTTOM_OFFST</code> <code>Optional[float]</code> <p>Distance to rim when bottoming starts to occur.</p> <code>BOTTOM_STIFF</code> <code>Optional[float]</code> <p>Vertical stiffness of bottomed tyre.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class Vertical(_ParameterGroup):\n    \"\"\"\n    Vertical stiffness, loaded and effective rolling radius.\n\n    Attributes:\n        FNOMIN (float): Nominal wheel load.\n        VERTICAL_STIFFNESS (Optional[float]): tyre vertical stiffness.\n        VERTICAL_DAMPING (Optional[float]): tyre vertical damping.\n        MC_CONTOUR_A (Optional[float]): Motorcycle contour ellipse A.\n        MC_CONTOUR_B (Optional[float]): Motorcycle contour ellipse B.\n        BREFF (Optional[float]): Low load stiffness of effective rolling radius.\n        DREFF (Optional[float]): Peak value of effective rolling radius.\n        FREFF (Optional[float]):\n            High load stiffness of effective rolling radius.\n        Q_RE0 (Optional[float]):\n            Ratio of free tyre radius with nominal tyre radius.\n        Q_V1 (Optional[float]): tyre radius increase with speed.\n        Q_V2 (Optional[float]): Vertical stiffness increase with speed.\n        Q_FZ2 (Optional[float]): Quadratic term in load vs. deflection.\n        Q_FCX (Optional[float]):\n            Longitudinal force influence on vertical stiffness.\n        Q_FCY (Optional[float]): Lateral force influence on vertical stiffness.\n        Q_FCY2 (Optional[float]): Explicit load dependency for including\n            the lateral force influence on vertical stiffness.\n        Q_CAM (Optional[float]): Stiffness reduction due to camber.\n        Q_CAM1 (Optional[float]): Linear load dependent camber angle\n            influence on vertical stiffness.\n        Q_CAM2 (Optional[float]): Quadratic load dependent camber angle\n            influence on vertical stiffness.\n        Q_CAM3 (Optional[float]): Linear load and camber angle dependent\n            reduction on vertical stiffness.\n        Q_FYS1 (Optional[float]): Combined camber angle and side slip angle\n            effect on vertical stiffness (constant).\n        Q_FYS2 (Optional[float]): Combined camber angle and side slip angle\n            linear effect on vertical stiffness.\n        Q_FYS3 (Optional[float]): Combined camber angle and side slip angle\n            quadratic effect on vertical stiffness.\n        PFZ1 (Optional[float]): Pressure effect on vertical stiffness.\n        BOTTOM_OFFST (Optional[float]):\n            Distance to rim when bottoming starts to occur.\n        BOTTOM_STIFF (Optional[float]): Vertical stiffness of bottomed tyre.\n    \"\"\"\n\n    FNOMIN: float\n    VERTICAL_STIFFNESS: Optional[float] = None\n    VERTICAL_DAMPING: Optional[float] = None\n    MC_CONTOUR_A: Optional[float] = None\n    MC_CONTOUR_B: Optional[float] = None\n    BREFF: Optional[float] = None\n    DREFF: Optional[float] = None\n    FREFF: Optional[float] = None\n    Q_RE0: Optional[float] = None\n    Q_V1: Optional[float] = None\n    Q_V2: Optional[float] = None\n    Q_FZ2: Optional[float] = None\n    Q_FCX: Optional[float] = None\n    Q_FCY: Optional[float] = None\n    Q_FCY2: Optional[float] = None\n    Q_CAM: Optional[float] = None\n    Q_CAM1: Optional[float] = None\n    Q_CAM2: Optional[float] = None\n    Q_CAM3: Optional[float] = None\n    Q_FYS1: Optional[float] = None\n    Q_FYS2: Optional[float] = None\n    Q_FYS3: Optional[float] = None\n    PFZ1: Optional[float] = None\n    BOTTOM_OFFST: Optional[float] = None\n    BOTTOM_STIFF: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tir/#usmlap.vehicle.tyre.tir.VerticalForceRange","title":"<code>VerticalForceRange</code>","text":"<p>               Bases: <code>_ParameterGroup</code></p> <p>Minimum and maximum allowed wheel loads.</p> <p>Attributes:</p> Name Type Description <code>FZMIN</code> <code>Optional[float]</code> <p>Minimum allowed wheel load.</p> <code>FZMAX</code> <code>Optional[float]</code> <p>Maximum allowed wheel load.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tir.py</code> <pre><code>class VerticalForceRange(_ParameterGroup):\n    \"\"\"\n    Minimum and maximum allowed wheel loads.\n\n    Attributes:\n        FZMIN (Optional[float]): Minimum allowed wheel load.\n        FZMAX (Optional[float]): Maximum allowed wheel load.\n    \"\"\"\n\n    FZMIN: Optional[float] = None\n    FZMAX: Optional[float] = None\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tyre_model/","title":"tyre_model","text":"<p>This module contains various tyre model implementations.</p>"},{"location":"autoapi/usmlap/vehicle/tyre/tyre_model/#usmlap.vehicle.tyre.tyre_model.LinearTyreModel","title":"<code>LinearTyreModel</code>","text":"<p>               Bases: <code>TyreModelInterface</code></p> <p>Implements a load-sensitive linear tyre model.</p> <p>Attributes:</p> Name Type Description <code>mu_x_peak</code> <code>float</code> <p>The peak coefficient of longitudinal friction.</p> <code>mu_x_load_sensitivity</code> <code>float</code> <p>The sensitivity of longitudinal friction to load.</p> <code>mu_y_peak</code> <code>float</code> <p>The peak coefficient of lateral friction.</p> <code>mu_y_load_sensitivity</code> <code>float</code> <p>The sensitivity of lateral friction to load.</p> <code>slip_stiffness</code> <code>float</code> <p>The longitudinal force generated per unit of slip ratio.</p> <code>cornering_stiffness</code> <code>float</code> <p>The lateral force generated per unit of slip angle.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tyre_model.py</code> <pre><code>class LinearTyreModel(TyreModelInterface, type=\"linear_tyre_model\"):\n    \"\"\"\n    Implements a load-sensitive linear tyre model.\n\n    Attributes:\n        mu_x_peak (float):\n            The peak coefficient of longitudinal friction.\n        mu_x_load_sensitivity (float):\n            The sensitivity of longitudinal friction to load.\n        mu_y_peak (float):\n            The peak coefficient of lateral friction.\n        mu_y_load_sensitivity (float):\n            The sensitivity of lateral friction to load.\n        slip_stiffness (float):\n            The longitudinal force generated per unit of slip ratio.\n        cornering_stiffness (float):\n            The lateral force generated per unit of slip angle.\n    \"\"\"\n\n    model_type: Literal[\"linear\"]\n\n    mu_x_peak: PositiveFloat\n    mu_x_load_sensitivity: Annotated[float, Unit(\"1/N\")]\n    mu_y_peak: PositiveFloat\n    mu_y_load_sensitivity: Annotated[float, Unit(\"1/N\")]\n    slip_stiffness: float\n    cornering_stiffness: float\n\n    def _get_mu_x(self, normal_load: float) -&gt; float:\n        return self.mu_x_peak - (self.mu_x_load_sensitivity * normal_load)\n\n    def _get_mu_y(self, normal_load: float) -&gt; float:\n        return self.mu_y_peak - (self.mu_y_load_sensitivity * normal_load)\n\n    def _get_fx_max(self, normal_load: float) -&gt; float:\n        return self._get_mu_x(normal_load) * normal_load\n\n    def _get_fy_max(self, normal_load: float) -&gt; float:\n        return self._get_mu_y(normal_load) * normal_load\n\n    @staticmethod\n    def _get_scale_factor(required_force: float, maximum_force: float) -&gt; float:\n        if required_force &gt; maximum_force:\n            raise ValueError(\"Required force is greater than maximum\")\n        return sqrt(1 - (required_force / maximum_force) ** 2)\n\n    def calculate_lateral_force(\n        self, tyre_attitude: TyreAttitude, required_fx: float = 0\n    ) -&gt; float:\n        fx_max = self._get_fx_max(tyre_attitude.normal_load)\n        fy_max = self._get_fy_max(tyre_attitude.normal_load)\n        return fy_max * self._get_scale_factor(required_fx, fx_max)\n\n    def calculate_longitudinal_force(\n        self, tyre_attitude: TyreAttitude, required_fy: float = 0\n    ) -&gt; float:\n        fx_max = self._get_fx_max(tyre_attitude.normal_load)\n        fy_max = self._get_fy_max(tyre_attitude.normal_load)\n        return fx_max * self._get_scale_factor(required_fy, fy_max)\n\n    def get_slip_ratio(self, tyre_attitude: TyreAttitude, fx: float) -&gt; float:\n        return fx / self.slip_stiffness\n\n    def get_slip_angle(self, tyre_attitude: TyreAttitude, fy: float) -&gt; float:\n        return fy / self.cornering_stiffness\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tyre_model/#usmlap.vehicle.tyre.tyre_model.Tyre","title":"<code>Tyre</code>","text":"<p>               Bases: <code>Component</code></p> <p>A racing tyre.</p> <p>Attributes:</p> Name Type Description <code>unloaded_radius</code> <code>float</code> <p>The unloaded radius of the tyre.</p> <code>tyre_model</code> <code>TyreModel</code> <p>The tyre model.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tyre_model.py</code> <pre><code>class Tyre(Component, library=\"tyres.json\"):\n    \"\"\"\n    A racing tyre.\n\n    Attributes:\n        unloaded_radius (float): The unloaded radius of the tyre.\n        tyre_model (TyreModel): The tyre model.\n    \"\"\"\n\n    unloaded_radius: float\n    tyre_model: TyreModel\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tyre_model/#usmlap.vehicle.tyre.tyre_model.TyreAttitude","title":"<code>TyreAttitude</code>","text":"<p>               Bases: <code>object</code></p> <p>Parameters describing the attitude of a tyre.</p> <p>Attributes:</p> Name Type Description <code>normal_load</code> <code>float</code> <p>The normal load acting on the tyre.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tyre_model.py</code> <pre><code>@dataclass\nclass TyreAttitude(object):\n    \"\"\"\n    Parameters describing the attitude of a tyre.\n\n    Attributes:\n        normal_load (float): The normal load acting on the tyre.\n    \"\"\"\n\n    normal_load: Annotated[float, Field(ge=0), Unit(\"N\")]\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tyre_model/#usmlap.vehicle.tyre.tyre_model.TyreModelInterface","title":"<code>TyreModelInterface</code>","text":"<p>               Bases: <code>AbstractSubsystem</code></p> <p>Abstract base class for tyre models.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tyre_model.py</code> <pre><code>class TyreModelInterface(AbstractSubsystem):\n    \"\"\"\n    Abstract base class for tyre models.\n    \"\"\"\n\n    @abstractmethod\n    def calculate_lateral_force(\n        self, tyre_attitude: TyreAttitude, required_fx: float = 0\n    ) -&gt; float:\n        \"\"\"\n        Calculates the lateral force available at the tyre.\n\n        Args:\n            tyre_attitude (TyreAttitude):\n                The attitude of the tyre.\n            required_fx (float, optional):\n                The longitudinal force which must be maintained. Defaults to 0.\n\n        Returns:\n            fy (float): The lateral force available at the tyre.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def calculate_longitudinal_force(\n        self, tyre_attitude: TyreAttitude, required_fy: float = 0\n    ) -&gt; float:\n        \"\"\"\n        Calculates the longitudinal force available at the tyre.\n\n        Args:\n            tyre_attitude (TyreAttitude):\n                The attitude of the tyre.\n            required_fy (float, optional):\n                The lateral force which must be maintained. Defaults to 0.\n\n        Returns:\n            fx (float): The longitudinal force available at the tyre.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_slip_ratio(self, tyre_attitude: TyreAttitude, fx: float) -&gt; float:\n        \"\"\"\n        Calculate the slip ratio required to generate longitudinal force.\n\n        Args:\n            tyre_attitude (TyreAttitude): The attitude of the tyre.\n            fx (float): The longitudinal force required.\n\n        Returns:\n            slip_ratio (float):\n                The slip ratio required to generate the longitudinal force.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_slip_angle(self, tyre_attitude: TyreAttitude, fy: float) -&gt; float:\n        \"\"\"\n        Calculate the slip angle required to generate lateral force.\n\n        Args:\n            tyre_attitude (TyreAttitude): The attitude of the tyre.\n            fy (float): The lateral force required.\n\n        Returns:\n            slip_angle (float):\n                The slip angle required to generate the lateral force.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tyre_model/#usmlap.vehicle.tyre.tyre_model.TyreModelInterface.calculate_lateral_force","title":"<code>calculate_lateral_force(tyre_attitude, required_fx=0)</code>  <code>abstractmethod</code>","text":"<p>Calculates the lateral force available at the tyre.</p> <p>Parameters:</p> Name Type Description Default <code>tyre_attitude</code> <code>TyreAttitude</code> <p>The attitude of the tyre.</p> required <code>required_fx</code> <code>float</code> <p>The longitudinal force which must be maintained. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>fy</code> <code>float</code> <p>The lateral force available at the tyre.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tyre_model.py</code> <pre><code>@abstractmethod\ndef calculate_lateral_force(\n    self, tyre_attitude: TyreAttitude, required_fx: float = 0\n) -&gt; float:\n    \"\"\"\n    Calculates the lateral force available at the tyre.\n\n    Args:\n        tyre_attitude (TyreAttitude):\n            The attitude of the tyre.\n        required_fx (float, optional):\n            The longitudinal force which must be maintained. Defaults to 0.\n\n    Returns:\n        fy (float): The lateral force available at the tyre.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tyre_model/#usmlap.vehicle.tyre.tyre_model.TyreModelInterface.calculate_longitudinal_force","title":"<code>calculate_longitudinal_force(tyre_attitude, required_fy=0)</code>  <code>abstractmethod</code>","text":"<p>Calculates the longitudinal force available at the tyre.</p> <p>Parameters:</p> Name Type Description Default <code>tyre_attitude</code> <code>TyreAttitude</code> <p>The attitude of the tyre.</p> required <code>required_fy</code> <code>float</code> <p>The lateral force which must be maintained. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>fx</code> <code>float</code> <p>The longitudinal force available at the tyre.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tyre_model.py</code> <pre><code>@abstractmethod\ndef calculate_longitudinal_force(\n    self, tyre_attitude: TyreAttitude, required_fy: float = 0\n) -&gt; float:\n    \"\"\"\n    Calculates the longitudinal force available at the tyre.\n\n    Args:\n        tyre_attitude (TyreAttitude):\n            The attitude of the tyre.\n        required_fy (float, optional):\n            The lateral force which must be maintained. Defaults to 0.\n\n    Returns:\n        fx (float): The longitudinal force available at the tyre.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tyre_model/#usmlap.vehicle.tyre.tyre_model.TyreModelInterface.get_slip_angle","title":"<code>get_slip_angle(tyre_attitude, fy)</code>  <code>abstractmethod</code>","text":"<p>Calculate the slip angle required to generate lateral force.</p> <p>Parameters:</p> Name Type Description Default <code>tyre_attitude</code> <code>TyreAttitude</code> <p>The attitude of the tyre.</p> required <code>fy</code> <code>float</code> <p>The lateral force required.</p> required <p>Returns:</p> Name Type Description <code>slip_angle</code> <code>float</code> <p>The slip angle required to generate the lateral force.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tyre_model.py</code> <pre><code>@abstractmethod\ndef get_slip_angle(self, tyre_attitude: TyreAttitude, fy: float) -&gt; float:\n    \"\"\"\n    Calculate the slip angle required to generate lateral force.\n\n    Args:\n        tyre_attitude (TyreAttitude): The attitude of the tyre.\n        fy (float): The lateral force required.\n\n    Returns:\n        slip_angle (float):\n            The slip angle required to generate the lateral force.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tyre_model/#usmlap.vehicle.tyre.tyre_model.TyreModelInterface.get_slip_ratio","title":"<code>get_slip_ratio(tyre_attitude, fx)</code>  <code>abstractmethod</code>","text":"<p>Calculate the slip ratio required to generate longitudinal force.</p> <p>Parameters:</p> Name Type Description Default <code>tyre_attitude</code> <code>TyreAttitude</code> <p>The attitude of the tyre.</p> required <code>fx</code> <code>float</code> <p>The longitudinal force required.</p> required <p>Returns:</p> Name Type Description <code>slip_ratio</code> <code>float</code> <p>The slip ratio required to generate the longitudinal force.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tyre_model.py</code> <pre><code>@abstractmethod\ndef get_slip_ratio(self, tyre_attitude: TyreAttitude, fx: float) -&gt; float:\n    \"\"\"\n    Calculate the slip ratio required to generate longitudinal force.\n\n    Args:\n        tyre_attitude (TyreAttitude): The attitude of the tyre.\n        fx (float): The longitudinal force required.\n\n    Returns:\n        slip_ratio (float):\n            The slip ratio required to generate the longitudinal force.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/usmlap/vehicle/tyre/tyre_model/#usmlap.vehicle.tyre.tyre_model.Tyres","title":"<code>Tyres</code>","text":"<p>               Bases: <code>Subsystem</code></p> <p>The tyres of a vehicle.</p> <p>Attributes:</p> Name Type Description <code>front</code> <code>TyreModel</code> <p>The front tyres of the vehicle.</p> <code>rear</code> <code>TyreModel</code> <p>The rear tyres of the vehicle.</p> Source code in <code>src\\usmlap\\vehicle\\tyre\\tyre_model.py</code> <pre><code>class Tyres(Subsystem):\n    \"\"\"\n    The tyres of a vehicle.\n\n    Attributes:\n        front (TyreModel): The front tyres of the vehicle.\n        rear (TyreModel): The rear tyres of the vehicle.\n    \"\"\"\n\n    front: Tyre\n    rear: Tyre\n</code></pre>"}]}